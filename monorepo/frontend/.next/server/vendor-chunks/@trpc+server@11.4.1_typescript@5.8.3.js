"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@trpc+server@11.4.1_typescript@5.8.3";
exports.ids = ["vendor-chunks/@trpc+server@11.4.1_typescript@5.8.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTP_CODE_TO_JSONRPC2: () => (/* binding */ HTTP_CODE_TO_JSONRPC2),\n/* harmony export */   JSONRPC2_TO_HTTP_CODE: () => (/* binding */ JSONRPC2_TO_HTTP_CODE),\n/* harmony export */   createFlatProxy: () => (/* binding */ createFlatProxy),\n/* harmony export */   createRecursiveProxy: () => (/* binding */ createRecursiveProxy),\n/* harmony export */   getErrorShape: () => (/* binding */ getErrorShape),\n/* harmony export */   getHTTPStatusCode: () => (/* binding */ getHTTPStatusCode),\n/* harmony export */   getHTTPStatusCodeFromError: () => (/* binding */ getHTTPStatusCodeFromError),\n/* harmony export */   getStatusCodeFromKey: () => (/* binding */ getStatusCodeFromKey),\n/* harmony export */   getStatusKeyFromCode: () => (/* binding */ getStatusKeyFromCode)\n/* harmony export */ });\n/* harmony import */ var _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-BHZJcBRv.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\");\n\n\n//#region src/unstable-core-do-not-import/createProxy.ts\nconst noop = () => {};\nconst freezeIfAvailable = (obj) => {\n\tif (Object.freeze) Object.freeze(obj);\n};\nfunction createInnerProxy(callback, path, memo) {\n\tconst cacheKey = path.join(\".\");\n\tmemo[cacheKey] ??= new Proxy(noop, {\n\t\tget(_obj, key) {\n\t\t\tif (typeof key !== \"string\" || key === \"then\") return void 0;\n\t\t\treturn createInnerProxy(callback, [...path, key], memo);\n\t\t},\n\t\tapply(_1, _2, args) {\n\t\t\tconst lastOfPath = path[path.length - 1];\n\t\t\tlet opts = {\n\t\t\t\targs,\n\t\t\t\tpath\n\t\t\t};\n\t\t\tif (lastOfPath === \"call\") opts = {\n\t\t\t\targs: args.length >= 2 ? [args[1]] : [],\n\t\t\t\tpath: path.slice(0, -1)\n\t\t\t};\n\t\t\telse if (lastOfPath === \"apply\") opts = {\n\t\t\t\targs: args.length >= 2 ? args[1] : [],\n\t\t\t\tpath: path.slice(0, -1)\n\t\t\t};\n\t\t\tfreezeIfAvailable(opts.args);\n\t\t\tfreezeIfAvailable(opts.path);\n\t\t\treturn callback(opts);\n\t\t}\n\t});\n\treturn memo[cacheKey];\n}\n/**\n* Creates a proxy that calls the callback with the path and arguments\n*\n* @internal\n*/\nconst createRecursiveProxy = (callback) => createInnerProxy(callback, [], Object.create(null));\n/**\n* Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n*\n* @internal\n*/\nconst createFlatProxy = (callback) => {\n\treturn new Proxy(noop, { get(_obj, name) {\n\t\tif (name === \"then\") return void 0;\n\t\treturn callback(name);\n\t} });\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/getHTTPStatusCode.ts\nconst JSONRPC2_TO_HTTP_CODE = {\n\tPARSE_ERROR: 400,\n\tBAD_REQUEST: 400,\n\tUNAUTHORIZED: 401,\n\tPAYMENT_REQUIRED: 402,\n\tFORBIDDEN: 403,\n\tNOT_FOUND: 404,\n\tMETHOD_NOT_SUPPORTED: 405,\n\tTIMEOUT: 408,\n\tCONFLICT: 409,\n\tPRECONDITION_FAILED: 412,\n\tPAYLOAD_TOO_LARGE: 413,\n\tUNSUPPORTED_MEDIA_TYPE: 415,\n\tUNPROCESSABLE_CONTENT: 422,\n\tTOO_MANY_REQUESTS: 429,\n\tCLIENT_CLOSED_REQUEST: 499,\n\tINTERNAL_SERVER_ERROR: 500,\n\tNOT_IMPLEMENTED: 501,\n\tBAD_GATEWAY: 502,\n\tSERVICE_UNAVAILABLE: 503,\n\tGATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n\t400: \"BAD_REQUEST\",\n\t401: \"UNAUTHORIZED\",\n\t402: \"PAYMENT_REQUIRED\",\n\t403: \"FORBIDDEN\",\n\t404: \"NOT_FOUND\",\n\t405: \"METHOD_NOT_SUPPORTED\",\n\t408: \"TIMEOUT\",\n\t409: \"CONFLICT\",\n\t412: \"PRECONDITION_FAILED\",\n\t413: \"PAYLOAD_TOO_LARGE\",\n\t415: \"UNSUPPORTED_MEDIA_TYPE\",\n\t422: \"UNPROCESSABLE_CONTENT\",\n\t429: \"TOO_MANY_REQUESTS\",\n\t499: \"CLIENT_CLOSED_REQUEST\",\n\t500: \"INTERNAL_SERVER_ERROR\",\n\t501: \"NOT_IMPLEMENTED\",\n\t502: \"BAD_GATEWAY\",\n\t503: \"SERVICE_UNAVAILABLE\",\n\t504: \"GATEWAY_TIMEOUT\"\n};\nfunction getStatusCodeFromKey(code) {\n\treturn JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getStatusKeyFromCode(code) {\n\treturn HTTP_CODE_TO_JSONRPC2[code] ?? \"INTERNAL_SERVER_ERROR\";\n}\nfunction getHTTPStatusCode(json) {\n\tconst arr = Array.isArray(json) ? json : [json];\n\tconst httpStatuses = new Set(arr.map((res) => {\n\t\tif (\"error\" in res && (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(res.error.data)) {\n\t\t\tif (typeof res.error.data?.[\"httpStatus\"] === \"number\") return res.error.data[\"httpStatus\"];\n\t\t\tconst code = _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n\t\t\treturn getStatusCodeFromKey(code);\n\t\t}\n\t\treturn 200;\n\t}));\n\tif (httpStatuses.size !== 1) return 207;\n\tconst httpStatus = httpStatuses.values().next().value;\n\treturn httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n\treturn getStatusCodeFromKey(error.code);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/error/getErrorShape.ts\n/**\n* @internal\n*/\nfunction getErrorShape(opts) {\n\tconst { path, error, config } = opts;\n\tconst { code } = opts.error;\n\tconst shape = {\n\t\tmessage: error.message,\n\t\tcode: _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_KEY[code],\n\t\tdata: {\n\t\t\tcode,\n\t\t\thttpStatus: getHTTPStatusCodeFromError(error)\n\t\t}\n\t};\n\tif (config.isDev && typeof opts.error.stack === \"string\") shape.data.stack = opts.error.stack;\n\tif (typeof path === \"string\") shape.data.path = path;\n\treturn config.errorFormatter({\n\t\t...opts,\n\t\tshape\n\t});\n}\n\n//#endregion\n\n//# sourceMappingURL=getErrorShape-DyYil4aT.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9nZXRFcnJvclNoYXBlLUR5WWlsNGFULm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXFHOztBQUVyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZEQUFRO0FBQ2hDO0FBQ0EsZ0JBQWdCLDJFQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0IsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxRQUFRLHdFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUN5TTtBQUN6TSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvZ2V0RXJyb3JTaGFwZS1EeVlpbDRhVC5tanM/NWVmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSwgVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVIsIGlzT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHMtQkhaSmNCUnYubWpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2NyZWF0ZVByb3h5LnRzXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBmcmVlemVJZkF2YWlsYWJsZSA9IChvYmopID0+IHtcblx0aWYgKE9iamVjdC5mcmVlemUpIE9iamVjdC5mcmVlemUob2JqKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVJbm5lclByb3h5KGNhbGxiYWNrLCBwYXRoLCBtZW1vKSB7XG5cdGNvbnN0IGNhY2hlS2V5ID0gcGF0aC5qb2luKFwiLlwiKTtcblx0bWVtb1tjYWNoZUtleV0gPz89IG5ldyBQcm94eShub29wLCB7XG5cdFx0Z2V0KF9vYmosIGtleSkge1xuXHRcdFx0aWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIgfHwga2V5ID09PSBcInRoZW5cIikgcmV0dXJuIHZvaWQgMDtcblx0XHRcdHJldHVybiBjcmVhdGVJbm5lclByb3h5KGNhbGxiYWNrLCBbLi4ucGF0aCwga2V5XSwgbWVtbyk7XG5cdFx0fSxcblx0XHRhcHBseShfMSwgXzIsIGFyZ3MpIHtcblx0XHRcdGNvbnN0IGxhc3RPZlBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cdFx0XHRsZXQgb3B0cyA9IHtcblx0XHRcdFx0YXJncyxcblx0XHRcdFx0cGF0aFxuXHRcdFx0fTtcblx0XHRcdGlmIChsYXN0T2ZQYXRoID09PSBcImNhbGxcIikgb3B0cyA9IHtcblx0XHRcdFx0YXJnczogYXJncy5sZW5ndGggPj0gMiA/IFthcmdzWzFdXSA6IFtdLFxuXHRcdFx0XHRwYXRoOiBwYXRoLnNsaWNlKDAsIC0xKVxuXHRcdFx0fTtcblx0XHRcdGVsc2UgaWYgKGxhc3RPZlBhdGggPT09IFwiYXBwbHlcIikgb3B0cyA9IHtcblx0XHRcdFx0YXJnczogYXJncy5sZW5ndGggPj0gMiA/IGFyZ3NbMV0gOiBbXSxcblx0XHRcdFx0cGF0aDogcGF0aC5zbGljZSgwLCAtMSlcblx0XHRcdH07XG5cdFx0XHRmcmVlemVJZkF2YWlsYWJsZShvcHRzLmFyZ3MpO1xuXHRcdFx0ZnJlZXplSWZBdmFpbGFibGUob3B0cy5wYXRoKTtcblx0XHRcdHJldHVybiBjYWxsYmFjayhvcHRzKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gbWVtb1tjYWNoZUtleV07XG59XG4vKipcbiogQ3JlYXRlcyBhIHByb3h5IHRoYXQgY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHBhdGggYW5kIGFyZ3VtZW50c1xuKlxuKiBAaW50ZXJuYWxcbiovXG5jb25zdCBjcmVhdGVSZWN1cnNpdmVQcm94eSA9IChjYWxsYmFjaykgPT4gY3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgW10sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuLyoqXG4qIFVzZWQgaW4gcGxhY2Ugb2YgYG5ldyBQcm94eWAgd2hlcmUgZWFjaCBoYW5kbGVyIHdpbGwgbWFwIDEgbGV2ZWwgZGVlcCB0byBhbm90aGVyIHZhbHVlLlxuKlxuKiBAaW50ZXJuYWxcbiovXG5jb25zdCBjcmVhdGVGbGF0UHJveHkgPSAoY2FsbGJhY2spID0+IHtcblx0cmV0dXJuIG5ldyBQcm94eShub29wLCB7IGdldChfb2JqLCBuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09IFwidGhlblwiKSByZXR1cm4gdm9pZCAwO1xuXHRcdHJldHVybiBjYWxsYmFjayhuYW1lKTtcblx0fSB9KTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9nZXRIVFRQU3RhdHVzQ29kZS50c1xuY29uc3QgSlNPTlJQQzJfVE9fSFRUUF9DT0RFID0ge1xuXHRQQVJTRV9FUlJPUjogNDAwLFxuXHRCQURfUkVRVUVTVDogNDAwLFxuXHRVTkFVVEhPUklaRUQ6IDQwMSxcblx0UEFZTUVOVF9SRVFVSVJFRDogNDAyLFxuXHRGT1JCSURERU46IDQwMyxcblx0Tk9UX0ZPVU5EOiA0MDQsXG5cdE1FVEhPRF9OT1RfU1VQUE9SVEVEOiA0MDUsXG5cdFRJTUVPVVQ6IDQwOCxcblx0Q09ORkxJQ1Q6IDQwOSxcblx0UFJFQ09ORElUSU9OX0ZBSUxFRDogNDEyLFxuXHRQQVlMT0FEX1RPT19MQVJHRTogNDEzLFxuXHRVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiA0MTUsXG5cdFVOUFJPQ0VTU0FCTEVfQ09OVEVOVDogNDIyLFxuXHRUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuXHRDTElFTlRfQ0xPU0VEX1JFUVVFU1Q6IDQ5OSxcblx0SU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG5cdE5PVF9JTVBMRU1FTlRFRDogNTAxLFxuXHRCQURfR0FURVdBWTogNTAyLFxuXHRTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG5cdEdBVEVXQVlfVElNRU9VVDogNTA0XG59O1xuY29uc3QgSFRUUF9DT0RFX1RPX0pTT05SUEMyID0ge1xuXHQ0MDA6IFwiQkFEX1JFUVVFU1RcIixcblx0NDAxOiBcIlVOQVVUSE9SSVpFRFwiLFxuXHQ0MDI6IFwiUEFZTUVOVF9SRVFVSVJFRFwiLFxuXHQ0MDM6IFwiRk9SQklEREVOXCIsXG5cdDQwNDogXCJOT1RfRk9VTkRcIixcblx0NDA1OiBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCIsXG5cdDQwODogXCJUSU1FT1VUXCIsXG5cdDQwOTogXCJDT05GTElDVFwiLFxuXHQ0MTI6IFwiUFJFQ09ORElUSU9OX0ZBSUxFRFwiLFxuXHQ0MTM6IFwiUEFZTE9BRF9UT09fTEFSR0VcIixcblx0NDE1OiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0NDIyOiBcIlVOUFJPQ0VTU0FCTEVfQ09OVEVOVFwiLFxuXHQ0Mjk6IFwiVE9PX01BTllfUkVRVUVTVFNcIixcblx0NDk5OiBcIkNMSUVOVF9DTE9TRURfUkVRVUVTVFwiLFxuXHQ1MDA6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG5cdDUwMTogXCJOT1RfSU1QTEVNRU5URURcIixcblx0NTAyOiBcIkJBRF9HQVRFV0FZXCIsXG5cdDUwMzogXCJTRVJWSUNFX1VOQVZBSUxBQkxFXCIsXG5cdDUwNDogXCJHQVRFV0FZX1RJTUVPVVRcIlxufTtcbmZ1bmN0aW9uIGdldFN0YXR1c0NvZGVGcm9tS2V5KGNvZGUpIHtcblx0cmV0dXJuIEpTT05SUEMyX1RPX0hUVFBfQ09ERVtjb2RlXSA/PyA1MDA7XG59XG5mdW5jdGlvbiBnZXRTdGF0dXNLZXlGcm9tQ29kZShjb2RlKSB7XG5cdHJldHVybiBIVFRQX0NPREVfVE9fSlNPTlJQQzJbY29kZV0gPz8gXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIjtcbn1cbmZ1bmN0aW9uIGdldEhUVFBTdGF0dXNDb2RlKGpzb24pIHtcblx0Y29uc3QgYXJyID0gQXJyYXkuaXNBcnJheShqc29uKSA/IGpzb24gOiBbanNvbl07XG5cdGNvbnN0IGh0dHBTdGF0dXNlcyA9IG5ldyBTZXQoYXJyLm1hcCgocmVzKSA9PiB7XG5cdFx0aWYgKFwiZXJyb3JcIiBpbiByZXMgJiYgaXNPYmplY3QocmVzLmVycm9yLmRhdGEpKSB7XG5cdFx0XHRpZiAodHlwZW9mIHJlcy5lcnJvci5kYXRhPy5bXCJodHRwU3RhdHVzXCJdID09PSBcIm51bWJlclwiKSByZXR1cm4gcmVzLmVycm9yLmRhdGFbXCJodHRwU3RhdHVzXCJdO1xuXHRcdFx0Y29uc3QgY29kZSA9IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSW3Jlcy5lcnJvci5jb2RlXTtcblx0XHRcdHJldHVybiBnZXRTdGF0dXNDb2RlRnJvbUtleShjb2RlKTtcblx0XHR9XG5cdFx0cmV0dXJuIDIwMDtcblx0fSkpO1xuXHRpZiAoaHR0cFN0YXR1c2VzLnNpemUgIT09IDEpIHJldHVybiAyMDc7XG5cdGNvbnN0IGh0dHBTdGF0dXMgPSBodHRwU3RhdHVzZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXHRyZXR1cm4gaHR0cFN0YXR1cztcbn1cbmZ1bmN0aW9uIGdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yKGVycm9yKSB7XG5cdHJldHVybiBnZXRTdGF0dXNDb2RlRnJvbUtleShlcnJvci5jb2RlKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9lcnJvci9nZXRFcnJvclNoYXBlLnRzXG4vKipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZ2V0RXJyb3JTaGFwZShvcHRzKSB7XG5cdGNvbnN0IHsgcGF0aCwgZXJyb3IsIGNvbmZpZyB9ID0gb3B0cztcblx0Y29uc3QgeyBjb2RlIH0gPSBvcHRzLmVycm9yO1xuXHRjb25zdCBzaGFwZSA9IHtcblx0XHRtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuXHRcdGNvZGU6IFRSUENfRVJST1JfQ09ERVNfQllfS0VZW2NvZGVdLFxuXHRcdGRhdGE6IHtcblx0XHRcdGNvZGUsXG5cdFx0XHRodHRwU3RhdHVzOiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcilcblx0XHR9XG5cdH07XG5cdGlmIChjb25maWcuaXNEZXYgJiYgdHlwZW9mIG9wdHMuZXJyb3Iuc3RhY2sgPT09IFwic3RyaW5nXCIpIHNoYXBlLmRhdGEuc3RhY2sgPSBvcHRzLmVycm9yLnN0YWNrO1xuXHRpZiAodHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIpIHNoYXBlLmRhdGEucGF0aCA9IHBhdGg7XG5cdHJldHVybiBjb25maWcuZXJyb3JGb3JtYXR0ZXIoe1xuXHRcdC4uLm9wdHMsXG5cdFx0c2hhcGVcblx0fSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgSFRUUF9DT0RFX1RPX0pTT05SUEMyLCBKU09OUlBDMl9UT19IVFRQX0NPREUsIGNyZWF0ZUZsYXRQcm94eSwgY3JlYXRlUmVjdXJzaXZlUHJveHksIGdldEVycm9yU2hhcGUsIGdldEhUVFBTdGF0dXNDb2RlLCBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvciwgZ2V0U3RhdHVzQ29kZUZyb21LZXksIGdldFN0YXR1c0tleUZyb21Db2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRFcnJvclNoYXBlLUR5WWlsNGFULm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isObservable: () => (/* binding */ isObservable),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   observableToAsyncIterable: () => (/* binding */ observableToAsyncIterable),\n/* harmony export */   observableToPromise: () => (/* binding */ observableToPromise)\n/* harmony export */ });\n//#region src/observable/observable.ts\n/** @public */\nfunction isObservable(x) {\n\treturn typeof x === \"object\" && x !== null && \"subscribe\" in x;\n}\n/** @public */\nfunction observable(subscribe) {\n\tconst self = {\n\t\tsubscribe(observer) {\n\t\t\tlet teardownRef = null;\n\t\t\tlet isDone = false;\n\t\t\tlet unsubscribed = false;\n\t\t\tlet teardownImmediately = false;\n\t\t\tfunction unsubscribe() {\n\t\t\t\tif (teardownRef === null) {\n\t\t\t\t\tteardownImmediately = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (unsubscribed) return;\n\t\t\t\tunsubscribed = true;\n\t\t\t\tif (typeof teardownRef === \"function\") teardownRef();\n\t\t\t\telse if (teardownRef) teardownRef.unsubscribe();\n\t\t\t}\n\t\t\tteardownRef = subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tobserver.next?.(value);\n\t\t\t\t},\n\t\t\t\terror(err) {\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tisDone = true;\n\t\t\t\t\tobserver.error?.(err);\n\t\t\t\t\tunsubscribe();\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tisDone = true;\n\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\tunsubscribe();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (teardownImmediately) unsubscribe();\n\t\t\treturn { unsubscribe };\n\t\t},\n\t\tpipe(...operations) {\n\t\t\treturn operations.reduce(pipeReducer, self);\n\t\t}\n\t};\n\treturn self;\n}\nfunction pipeReducer(prev, fn) {\n\treturn fn(prev);\n}\n/** @internal */\nfunction observableToPromise(observable$1) {\n\tconst ac = new AbortController();\n\tconst promise = new Promise((resolve, reject) => {\n\t\tlet isDone = false;\n\t\tfunction onDone() {\n\t\t\tif (isDone) return;\n\t\t\tisDone = true;\n\t\t\tobs$.unsubscribe();\n\t\t}\n\t\tac.signal.addEventListener(\"abort\", () => {\n\t\t\treject(ac.signal.reason);\n\t\t});\n\t\tconst obs$ = observable$1.subscribe({\n\t\t\tnext(data) {\n\t\t\t\tisDone = true;\n\t\t\t\tresolve(data);\n\t\t\t\tonDone();\n\t\t\t},\n\t\t\terror(data) {\n\t\t\t\treject(data);\n\t\t\t},\n\t\t\tcomplete() {\n\t\t\t\tac.abort();\n\t\t\t\tonDone();\n\t\t\t}\n\t\t});\n\t});\n\treturn promise;\n}\n/**\n* @internal\n*/\nfunction observableToReadableStream(observable$1, signal) {\n\tlet unsub = null;\n\tconst onAbort = () => {\n\t\tunsub?.unsubscribe();\n\t\tunsub = null;\n\t\tsignal.removeEventListener(\"abort\", onAbort);\n\t};\n\treturn new ReadableStream({\n\t\tstart(controller) {\n\t\t\tunsub = observable$1.subscribe({\n\t\t\t\tnext(data) {\n\t\t\t\t\tcontroller.enqueue({\n\t\t\t\t\t\tok: true,\n\t\t\t\t\t\tvalue: data\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tcontroller.enqueue({\n\t\t\t\t\t\tok: false,\n\t\t\t\t\t\terror\n\t\t\t\t\t});\n\t\t\t\t\tcontroller.close();\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (signal.aborted) onAbort();\n\t\t\telse signal.addEventListener(\"abort\", onAbort, { once: true });\n\t\t},\n\t\tcancel() {\n\t\t\tonAbort();\n\t\t}\n\t});\n}\n/** @internal */\nfunction observableToAsyncIterable(observable$1, signal) {\n\tconst stream = observableToReadableStream(observable$1, signal);\n\tconst reader = stream.getReader();\n\tconst iterator = {\n\t\tasync next() {\n\t\t\tconst value = await reader.read();\n\t\t\tif (value.done) return {\n\t\t\t\tvalue: void 0,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t\tconst { value: result } = value;\n\t\t\tif (!result.ok) throw result.error;\n\t\t\treturn {\n\t\t\t\tvalue: result.value,\n\t\t\t\tdone: false\n\t\t\t};\n\t\t},\n\t\tasync return() {\n\t\t\tawait reader.cancel();\n\t\t\treturn {\n\t\t\t\tvalue: void 0,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\t};\n\treturn { [Symbol.asyncIterator]() {\n\t\treturn iterator;\n\t} };\n}\n\n//#endregion\n\n//# sourceMappingURL=observable-B1orLHHI.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLUIxb3JMSEhJLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ29GO0FBQ3BGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLUIxb3JMSEhJLm1qcz9lYTk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vI3JlZ2lvbiBzcmMvb2JzZXJ2YWJsZS9vYnNlcnZhYmxlLnRzXG4vKiogQHB1YmxpYyAqL1xuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHgpIHtcblx0cmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGwgJiYgXCJzdWJzY3JpYmVcIiBpbiB4O1xufVxuLyoqIEBwdWJsaWMgKi9cbmZ1bmN0aW9uIG9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG5cdGNvbnN0IHNlbGYgPSB7XG5cdFx0c3Vic2NyaWJlKG9ic2VydmVyKSB7XG5cdFx0XHRsZXQgdGVhcmRvd25SZWYgPSBudWxsO1xuXHRcdFx0bGV0IGlzRG9uZSA9IGZhbHNlO1xuXHRcdFx0bGV0IHVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuXHRcdFx0bGV0IHRlYXJkb3duSW1tZWRpYXRlbHkgPSBmYWxzZTtcblx0XHRcdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuXHRcdFx0XHRpZiAodGVhcmRvd25SZWYgPT09IG51bGwpIHtcblx0XHRcdFx0XHR0ZWFyZG93bkltbWVkaWF0ZWx5ID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHVuc3Vic2NyaWJlZCkgcmV0dXJuO1xuXHRcdFx0XHR1bnN1YnNjcmliZWQgPSB0cnVlO1xuXHRcdFx0XHRpZiAodHlwZW9mIHRlYXJkb3duUmVmID09PSBcImZ1bmN0aW9uXCIpIHRlYXJkb3duUmVmKCk7XG5cdFx0XHRcdGVsc2UgaWYgKHRlYXJkb3duUmVmKSB0ZWFyZG93blJlZi51bnN1YnNjcmliZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGVhcmRvd25SZWYgPSBzdWJzY3JpYmUoe1xuXHRcdFx0XHRuZXh0KHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKGlzRG9uZSkgcmV0dXJuO1xuXHRcdFx0XHRcdG9ic2VydmVyLm5leHQ/Lih2YWx1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yKGVycikge1xuXHRcdFx0XHRcdGlmIChpc0RvbmUpIHJldHVybjtcblx0XHRcdFx0XHRpc0RvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdG9ic2VydmVyLmVycm9yPy4oZXJyKTtcblx0XHRcdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0XHRpZiAoaXNEb25lKSByZXR1cm47XG5cdFx0XHRcdFx0aXNEb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG5cdFx0XHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAodGVhcmRvd25JbW1lZGlhdGVseSkgdW5zdWJzY3JpYmUoKTtcblx0XHRcdHJldHVybiB7IHVuc3Vic2NyaWJlIH07XG5cdFx0fSxcblx0XHRwaXBlKC4uLm9wZXJhdGlvbnMpIHtcblx0XHRcdHJldHVybiBvcGVyYXRpb25zLnJlZHVjZShwaXBlUmVkdWNlciwgc2VsZik7XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIHBpcGVSZWR1Y2VyKHByZXYsIGZuKSB7XG5cdHJldHVybiBmbihwcmV2KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG9ic2VydmFibGVUb1Byb21pc2Uob2JzZXJ2YWJsZSQxKSB7XG5cdGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHRjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGxldCBpc0RvbmUgPSBmYWxzZTtcblx0XHRmdW5jdGlvbiBvbkRvbmUoKSB7XG5cdFx0XHRpZiAoaXNEb25lKSByZXR1cm47XG5cdFx0XHRpc0RvbmUgPSB0cnVlO1xuXHRcdFx0b2JzJC51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0XHRhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcblx0XHRcdHJlamVjdChhYy5zaWduYWwucmVhc29uKTtcblx0XHR9KTtcblx0XHRjb25zdCBvYnMkID0gb2JzZXJ2YWJsZSQxLnN1YnNjcmliZSh7XG5cdFx0XHRuZXh0KGRhdGEpIHtcblx0XHRcdFx0aXNEb25lID0gdHJ1ZTtcblx0XHRcdFx0cmVzb2x2ZShkYXRhKTtcblx0XHRcdFx0b25Eb25lKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3IoZGF0YSkge1xuXHRcdFx0XHRyZWplY3QoZGF0YSk7XG5cdFx0XHR9LFxuXHRcdFx0Y29tcGxldGUoKSB7XG5cdFx0XHRcdGFjLmFib3J0KCk7XG5cdFx0XHRcdG9uRG9uZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIHByb21pc2U7XG59XG4vKipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW0ob2JzZXJ2YWJsZSQxLCBzaWduYWwpIHtcblx0bGV0IHVuc3ViID0gbnVsbDtcblx0Y29uc3Qgb25BYm9ydCA9ICgpID0+IHtcblx0XHR1bnN1Yj8udW5zdWJzY3JpYmUoKTtcblx0XHR1bnN1YiA9IG51bGw7XG5cdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcblx0fTtcblx0cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG5cdFx0c3RhcnQoY29udHJvbGxlcikge1xuXHRcdFx0dW5zdWIgPSBvYnNlcnZhYmxlJDEuc3Vic2NyaWJlKHtcblx0XHRcdFx0bmV4dChkYXRhKSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0XHRcdG9rOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGRhdGFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdFx0b2s6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoc2lnbmFsLmFib3J0ZWQpIG9uQWJvcnQoKTtcblx0XHRcdGVsc2Ugc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0LCB7IG9uY2U6IHRydWUgfSk7XG5cdFx0fSxcblx0XHRjYW5jZWwoKSB7XG5cdFx0XHRvbkFib3J0KCk7XG5cdFx0fVxuXHR9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUob2JzZXJ2YWJsZSQxLCBzaWduYWwpIHtcblx0Y29uc3Qgc3RyZWFtID0gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW0ob2JzZXJ2YWJsZSQxLCBzaWduYWwpO1xuXHRjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdGNvbnN0IGl0ZXJhdG9yID0ge1xuXHRcdGFzeW5jIG5leHQoKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cdFx0XHRpZiAodmFsdWUuZG9uZSkgcmV0dXJuIHtcblx0XHRcdFx0dmFsdWU6IHZvaWQgMCxcblx0XHRcdFx0ZG9uZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHRcdGNvbnN0IHsgdmFsdWU6IHJlc3VsdCB9ID0gdmFsdWU7XG5cdFx0XHRpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0LmVycm9yO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dmFsdWU6IHJlc3VsdC52YWx1ZSxcblx0XHRcdFx0ZG9uZTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fSxcblx0XHRhc3luYyByZXR1cm4oKSB7XG5cdFx0XHRhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogdm9pZCAwLFxuXHRcdFx0XHRkb25lOiB0cnVlXG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIHsgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcblx0XHRyZXR1cm4gaXRlcmF0b3I7XG5cdH0gfTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBpc09ic2VydmFibGUsIG9ic2VydmFibGUsIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUsIG9ic2VydmFibGVUb1Byb21pc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUtQjFvckxISEkubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-CFXA_tyK.mjs":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-CFXA_tyK.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   behaviorSubject: () => (/* binding */ behaviorSubject),\n/* harmony export */   distinctUntilChanged: () => (/* binding */ distinctUntilChanged),\n/* harmony export */   distinctUntilDeepChanged: () => (/* binding */ distinctUntilDeepChanged),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   share: () => (/* binding */ share),\n/* harmony export */   tap: () => (/* binding */ tap)\n/* harmony export */ });\n/* harmony import */ var _observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observable-B1orLHHI.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs\");\n\n\n//#region src/observable/operators.ts\nfunction map(project) {\n\treturn (source) => {\n\t\treturn (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\tlet index = 0;\n\t\t\tconst subscription = source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tdestination.next(project(value, index++));\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn subscription;\n\t\t});\n\t};\n}\nfunction share(_opts) {\n\treturn (source) => {\n\t\tlet refCount = 0;\n\t\tlet subscription = null;\n\t\tconst observers = [];\n\t\tfunction startIfNeeded() {\n\t\t\tif (subscription) return;\n\t\t\tsubscription = source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tfor (const observer of observers) observer.next?.(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tfor (const observer of observers) observer.error?.(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tfor (const observer of observers) observer.complete?.();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction resetIfNeeded() {\n\t\t\tif (refCount === 0 && subscription) {\n\t\t\t\tconst _sub = subscription;\n\t\t\t\tsubscription = null;\n\t\t\t\t_sub.unsubscribe();\n\t\t\t}\n\t\t}\n\t\treturn (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((subscriber) => {\n\t\t\trefCount++;\n\t\t\tobservers.push(subscriber);\n\t\t\tstartIfNeeded();\n\t\t\treturn { unsubscribe() {\n\t\t\t\trefCount--;\n\t\t\t\tresetIfNeeded();\n\t\t\t\tconst index = observers.findIndex((v) => v === subscriber);\n\t\t\t\tif (index > -1) observers.splice(index, 1);\n\t\t\t} };\n\t\t});\n\t};\n}\nfunction tap(observer) {\n\treturn (source) => {\n\t\treturn (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\treturn source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tobserver.next?.(value);\n\t\t\t\t\tdestination.next(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tobserver.error?.(error);\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tobserver.complete?.();\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\nconst distinctUnsetMarker = Symbol();\nfunction distinctUntilChanged(compare = (a, b) => a === b) {\n\treturn (source) => {\n\t\treturn (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\tlet lastValue = distinctUnsetMarker;\n\t\t\treturn source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tif (lastValue !== distinctUnsetMarker && compare(lastValue, value)) return;\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tdestination.next(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\nconst isDeepEqual = (a, b) => {\n\tif (a === b) return true;\n\tconst bothAreObjects = a && b && typeof a === \"object\" && typeof b === \"object\";\n\treturn !!bothAreObjects && Object.keys(a).length === Object.keys(b).length && Object.entries(a).every(([k, v]) => isDeepEqual(v, b[k]));\n};\nfunction distinctUntilDeepChanged() {\n\treturn distinctUntilChanged(isDeepEqual);\n}\n\n//#endregion\n//#region src/observable/behaviorSubject.ts\n/**\n* @internal\n* An observable that maintains and provides a \"current value\" to subscribers\n* @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n*/\nfunction behaviorSubject(initialValue) {\n\tlet value = initialValue;\n\tconst observerList = [];\n\tconst addObserver = (observer) => {\n\t\tif (value !== void 0) observer.next(value);\n\t\tobserverList.push(observer);\n\t};\n\tconst removeObserver = (observer) => {\n\t\tobserverList.splice(observerList.indexOf(observer), 1);\n\t};\n\tconst obs = (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((observer) => {\n\t\taddObserver(observer);\n\t\treturn () => {\n\t\t\tremoveObserver(observer);\n\t\t};\n\t});\n\tobs.next = (nextValue) => {\n\t\tif (value === nextValue) return;\n\t\tvalue = nextValue;\n\t\tfor (const observer of observerList) observer.next(nextValue);\n\t};\n\tobs.get = () => value;\n\treturn obs;\n}\n\n//#endregion\n\n//# sourceMappingURL=observable-CFXA_tyK.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLUNGWEFfdHlLLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvRUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0VBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvRUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEY7QUFDNUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTEuNC4xX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0B0cnBjL3NlcnZlci9kaXN0L29ic2VydmFibGUtQ0ZYQV90eUsubWpzPzg4ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb2JzZXJ2YWJsZSB9IGZyb20gXCIuL29ic2VydmFibGUtQjFvckxISEkubWpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvb2JzZXJ2YWJsZS9vcGVyYXRvcnMudHNcbmZ1bmN0aW9uIG1hcChwcm9qZWN0KSB7XG5cdHJldHVybiAoc291cmNlKSA9PiB7XG5cdFx0cmV0dXJuIG9ic2VydmFibGUoKGRlc3RpbmF0aW9uKSA9PiB7XG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0Y29uc3Qgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZSh7XG5cdFx0XHRcdG5leHQodmFsdWUpIHtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5uZXh0KHByb2plY3QodmFsdWUsIGluZGV4KyspKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHN1YnNjcmlwdGlvbjtcblx0XHR9KTtcblx0fTtcbn1cbmZ1bmN0aW9uIHNoYXJlKF9vcHRzKSB7XG5cdHJldHVybiAoc291cmNlKSA9PiB7XG5cdFx0bGV0IHJlZkNvdW50ID0gMDtcblx0XHRsZXQgc3Vic2NyaXB0aW9uID0gbnVsbDtcblx0XHRjb25zdCBvYnNlcnZlcnMgPSBbXTtcblx0XHRmdW5jdGlvbiBzdGFydElmTmVlZGVkKCkge1xuXHRcdFx0aWYgKHN1YnNjcmlwdGlvbikgcmV0dXJuO1xuXHRcdFx0c3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZSh7XG5cdFx0XHRcdG5leHQodmFsdWUpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVycykgb2JzZXJ2ZXIubmV4dD8uKHZhbHVlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVycykgb2JzZXJ2ZXIuZXJyb3I/LihlcnJvcik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2Ygb2JzZXJ2ZXJzKSBvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRmdW5jdGlvbiByZXNldElmTmVlZGVkKCkge1xuXHRcdFx0aWYgKHJlZkNvdW50ID09PSAwICYmIHN1YnNjcmlwdGlvbikge1xuXHRcdFx0XHRjb25zdCBfc3ViID0gc3Vic2NyaXB0aW9uO1xuXHRcdFx0XHRzdWJzY3JpcHRpb24gPSBudWxsO1xuXHRcdFx0XHRfc3ViLnVuc3Vic2NyaWJlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvYnNlcnZhYmxlKChzdWJzY3JpYmVyKSA9PiB7XG5cdFx0XHRyZWZDb3VudCsrO1xuXHRcdFx0b2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG5cdFx0XHRzdGFydElmTmVlZGVkKCk7XG5cdFx0XHRyZXR1cm4geyB1bnN1YnNjcmliZSgpIHtcblx0XHRcdFx0cmVmQ291bnQtLTtcblx0XHRcdFx0cmVzZXRJZk5lZWRlZCgpO1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IG9ic2VydmVycy5maW5kSW5kZXgoKHYpID0+IHYgPT09IHN1YnNjcmliZXIpO1xuXHRcdFx0XHRpZiAoaW5kZXggPiAtMSkgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR9IH07XG5cdFx0fSk7XG5cdH07XG59XG5mdW5jdGlvbiB0YXAob2JzZXJ2ZXIpIHtcblx0cmV0dXJuIChzb3VyY2UpID0+IHtcblx0XHRyZXR1cm4gb2JzZXJ2YWJsZSgoZGVzdGluYXRpb24pID0+IHtcblx0XHRcdHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKHtcblx0XHRcdFx0bmV4dCh2YWx1ZSkge1xuXHRcdFx0XHRcdG9ic2VydmVyLm5leHQ/Lih2YWx1ZSk7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yKGVycm9yKSB7XG5cdFx0XHRcdFx0b2JzZXJ2ZXIuZXJyb3I/LihlcnJvcik7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0XHRvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24uY29tcGxldGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH07XG59XG5jb25zdCBkaXN0aW5jdFVuc2V0TWFya2VyID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJlID0gKGEsIGIpID0+IGEgPT09IGIpIHtcblx0cmV0dXJuIChzb3VyY2UpID0+IHtcblx0XHRyZXR1cm4gb2JzZXJ2YWJsZSgoZGVzdGluYXRpb24pID0+IHtcblx0XHRcdGxldCBsYXN0VmFsdWUgPSBkaXN0aW5jdFVuc2V0TWFya2VyO1xuXHRcdFx0cmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoe1xuXHRcdFx0XHRuZXh0KHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKGxhc3RWYWx1ZSAhPT0gZGlzdGluY3RVbnNldE1hcmtlciAmJiBjb21wYXJlKGxhc3RWYWx1ZSwgdmFsdWUpKSByZXR1cm47XG5cdFx0XHRcdFx0bGFzdFZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yKGVycm9yKSB7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fTtcbn1cbmNvbnN0IGlzRGVlcEVxdWFsID0gKGEsIGIpID0+IHtcblx0aWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXHRjb25zdCBib3RoQXJlT2JqZWN0cyA9IGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIjtcblx0cmV0dXJuICEhYm90aEFyZU9iamVjdHMgJiYgT2JqZWN0LmtleXMoYSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhiKS5sZW5ndGggJiYgT2JqZWN0LmVudHJpZXMoYSkuZXZlcnkoKFtrLCB2XSkgPT4gaXNEZWVwRXF1YWwodiwgYltrXSkpO1xufTtcbmZ1bmN0aW9uIGRpc3RpbmN0VW50aWxEZWVwQ2hhbmdlZCgpIHtcblx0cmV0dXJuIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGlzRGVlcEVxdWFsKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL29ic2VydmFibGUvYmVoYXZpb3JTdWJqZWN0LnRzXG4vKipcbiogQGludGVybmFsXG4qIEFuIG9ic2VydmFibGUgdGhhdCBtYWludGFpbnMgYW5kIHByb3ZpZGVzIGEgXCJjdXJyZW50IHZhbHVlXCIgdG8gc3Vic2NyaWJlcnNcbiogQHNlZSBodHRwczovL3d3dy5sZWFybnJ4anMuaW8vbGVhcm4tcnhqcy9zdWJqZWN0cy9iZWhhdmlvcnN1YmplY3RcbiovXG5mdW5jdGlvbiBiZWhhdmlvclN1YmplY3QoaW5pdGlhbFZhbHVlKSB7XG5cdGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcblx0Y29uc3Qgb2JzZXJ2ZXJMaXN0ID0gW107XG5cdGNvbnN0IGFkZE9ic2VydmVyID0gKG9ic2VydmVyKSA9PiB7XG5cdFx0aWYgKHZhbHVlICE9PSB2b2lkIDApIG9ic2VydmVyLm5leHQodmFsdWUpO1xuXHRcdG9ic2VydmVyTGlzdC5wdXNoKG9ic2VydmVyKTtcblx0fTtcblx0Y29uc3QgcmVtb3ZlT2JzZXJ2ZXIgPSAob2JzZXJ2ZXIpID0+IHtcblx0XHRvYnNlcnZlckxpc3Quc3BsaWNlKG9ic2VydmVyTGlzdC5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG5cdH07XG5cdGNvbnN0IG9icyA9IG9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG5cdFx0YWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRyZW1vdmVPYnNlcnZlcihvYnNlcnZlcik7XG5cdFx0fTtcblx0fSk7XG5cdG9icy5uZXh0ID0gKG5leHRWYWx1ZSkgPT4ge1xuXHRcdGlmICh2YWx1ZSA9PT0gbmV4dFZhbHVlKSByZXR1cm47XG5cdFx0dmFsdWUgPSBuZXh0VmFsdWU7XG5cdFx0Zm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlckxpc3QpIG9ic2VydmVyLm5leHQobmV4dFZhbHVlKTtcblx0fTtcblx0b2JzLmdldCA9ICgpID0+IHZhbHVlO1xuXHRyZXR1cm4gb2JzO1xufVxuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IGJlaGF2aW9yU3ViamVjdCwgZGlzdGluY3RVbnRpbENoYW5nZWQsIGRpc3RpbmN0VW50aWxEZWVwQ2hhbmdlZCwgbWFwLCBzaGFyZSwgdGFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLUNGWEFfdHlLLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-CFXA_tyK.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-DPbYgJDD.mjs":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-DPbYgJDD.mjs ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Unpromise: () => (/* binding */ Unpromise),\n/* harmony export */   __commonJS: () => (/* binding */ __commonJS),\n/* harmony export */   __toESM: () => (/* binding */ __toESM),\n/* harmony export */   createDeferred: () => (/* binding */ createDeferred),\n/* harmony export */   getRequestInfo: () => (/* binding */ getRequestInfo),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   iteratorResource: () => (/* binding */ iteratorResource),\n/* harmony export */   jsonlStreamConsumer: () => (/* binding */ jsonlStreamConsumer),\n/* harmony export */   jsonlStreamProducer: () => (/* binding */ jsonlStreamProducer),\n/* harmony export */   makeAsyncResource: () => (/* binding */ makeAsyncResource),\n/* harmony export */   makeResource: () => (/* binding */ makeResource),\n/* harmony export */   parseConnectionParamsFromString: () => (/* binding */ parseConnectionParamsFromString),\n/* harmony export */   parseConnectionParamsFromUnknown: () => (/* binding */ parseConnectionParamsFromUnknown),\n/* harmony export */   require_usingCtx: () => (/* binding */ require_usingCtx),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   sseHeaders: () => (/* binding */ sseHeaders),\n/* harmony export */   sseStreamConsumer: () => (/* binding */ sseStreamConsumer),\n/* harmony export */   sseStreamProducer: () => (/* binding */ sseStreamProducer),\n/* harmony export */   takeWithGrace: () => (/* binding */ takeWithGrace),\n/* harmony export */   throwAbortError: () => (/* binding */ throwAbortError),\n/* harmony export */   withMaxDuration: () => (/* binding */ withMaxDuration)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getErrorShape-DyYil4aT.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs\");\n/* harmony import */ var _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracked-GEWPoL0C.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs\");\n/* harmony import */ var _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-BHZJcBRv.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\");\n/* harmony import */ var _observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observable-B1orLHHI.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs\");\n\n\n\n\n\n//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function() {\n\treturn mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\tkey = keys[i];\n\t\tif (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t});\n\t}\n\treturn to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n\tvalue: mod,\n\tenumerable: true\n}) : target, mod));\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/parseConnectionParams.ts\nfunction parseConnectionParamsFromUnknown(parsed) {\n\ttry {\n\t\tif (parsed === null) return null;\n\t\tif (!(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(parsed)) throw new Error(\"Expected object\");\n\t\tconst nonStringValues = Object.entries(parsed).filter(([_key, value]) => typeof value !== \"string\");\n\t\tif (nonStringValues.length > 0) throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value]) => `${key}: ${typeof value}`).join(\", \")}`);\n\t\treturn parsed;\n\t} catch (cause) {\n\t\tthrow new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"PARSE_ERROR\",\n\t\t\tmessage: \"Invalid connection params shape\",\n\t\t\tcause\n\t\t});\n\t}\n}\nfunction parseConnectionParamsFromString(str) {\n\tlet parsed;\n\ttry {\n\t\tparsed = JSON.parse(str);\n\t} catch (cause) {\n\t\tthrow new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"PARSE_ERROR\",\n\t\t\tmessage: \"Not JSON-parsable query params\",\n\t\t\tcause\n\t\t});\n\t}\n\treturn parseConnectionParamsFromUnknown(parsed);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/contentType.ts\n/**\n* Memoize a function that takes no arguments\n* @internal\n*/\nfunction memo(fn) {\n\tlet promise = null;\n\tconst sym = Symbol.for(\"@trpc/server/http/memo\");\n\tlet value = sym;\n\treturn {\n\t\tread: async () => {\n\t\t\tif (value !== sym) return value;\n\t\t\tpromise ??= fn().catch((cause) => {\n\t\t\t\tif (cause instanceof _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError) throw cause;\n\t\t\t\tthrow new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\t\tmessage: cause instanceof Error ? cause.message : \"Invalid input\",\n\t\t\t\t\tcause\n\t\t\t\t});\n\t\t\t});\n\t\t\tvalue = await promise;\n\t\t\tpromise = null;\n\t\t\treturn value;\n\t\t},\n\t\tresult: () => {\n\t\t\treturn value !== sym ? value : void 0;\n\t\t}\n\t};\n}\nconst jsonContentTypeHandler = {\n\tisMatch(req) {\n\t\treturn !!req.headers.get(\"content-type\")?.startsWith(\"application/json\");\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tconst isBatchCall = opts.searchParams.get(\"batch\") === \"1\";\n\t\tconst paths = isBatchCall ? opts.path.split(\",\") : [opts.path];\n\t\tconst getInputs = memo(async () => {\n\t\t\tlet inputs = void 0;\n\t\t\tif (req.method === \"GET\") {\n\t\t\t\tconst queryInput = opts.searchParams.get(\"input\");\n\t\t\t\tif (queryInput) inputs = JSON.parse(queryInput);\n\t\t\t} else inputs = await req.json();\n\t\t\tif (inputs === void 0) return {};\n\t\t\tif (!isBatchCall) return { 0: opts.router._def._config.transformer.input.deserialize(inputs) };\n\t\t\tif (!(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(inputs)) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\tmessage: \"\\\"input\\\" needs to be an object when doing a batch call\"\n\t\t\t});\n\t\t\tconst acc = {};\n\t\t\tfor (const index of paths.keys()) {\n\t\t\t\tconst input = inputs[index];\n\t\t\t\tif (input !== void 0) acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n\t\t\t}\n\t\t\treturn acc;\n\t\t});\n\t\tconst calls = await Promise.all(paths.map(async (path, index) => {\n\t\t\tconst procedure = await (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, path);\n\t\t\treturn {\n\t\t\t\tpath,\n\t\t\t\tprocedure,\n\t\t\t\tgetRawInput: async () => {\n\t\t\t\t\tconst inputs = await getInputs.read();\n\t\t\t\t\tlet input = inputs[index];\n\t\t\t\t\tif (procedure?._def.type === \"subscription\") {\n\t\t\t\t\t\tconst lastEventId = opts.headers.get(\"last-event-id\") ?? opts.searchParams.get(\"lastEventId\") ?? opts.searchParams.get(\"Last-Event-Id\");\n\t\t\t\t\t\tif (lastEventId) if ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) input = {\n\t\t\t\t\t\t\t...input,\n\t\t\t\t\t\t\tlastEventId\n\t\t\t\t\t\t};\n\t\t\t\t\t\telse input ??= { lastEventId };\n\t\t\t\t\t}\n\t\t\t\t\treturn input;\n\t\t\t\t},\n\t\t\t\tresult: () => {\n\t\t\t\t\treturn getInputs.result()?.[index];\n\t\t\t\t}\n\t\t\t};\n\t\t}));\n\t\tconst types = new Set(calls.map((call) => call.procedure?._def.type).filter(Boolean));\n\t\t/* istanbul ignore if -- @preserve */\n\t\tif (types.size > 1) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"BAD_REQUEST\",\n\t\t\tmessage: `Cannot mix procedure types in call: ${Array.from(types).join(\", \")}`\n\t\t});\n\t\tconst type = types.values().next().value ?? \"unknown\";\n\t\tconst connectionParamsStr = opts.searchParams.get(\"connectionParams\");\n\t\tconst info = {\n\t\t\tisBatchCall,\n\t\t\taccept: req.headers.get(\"trpc-accept\"),\n\t\t\tcalls,\n\t\t\ttype,\n\t\t\tconnectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t\treturn info;\n\t}\n};\nconst formDataContentTypeHandler = {\n\tisMatch(req) {\n\t\treturn !!req.headers.get(\"content-type\")?.startsWith(\"multipart/form-data\");\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tif (req.method !== \"POST\") throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\tmessage: \"Only POST requests are supported for multipart/form-data requests\"\n\t\t});\n\t\tconst getInputs = memo(async () => {\n\t\t\tconst fd = await req.formData();\n\t\t\treturn fd;\n\t\t});\n\t\tconst procedure = await (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path);\n\t\treturn {\n\t\t\taccept: null,\n\t\t\tcalls: [{\n\t\t\t\tpath: opts.path,\n\t\t\t\tgetRawInput: getInputs.read,\n\t\t\t\tresult: getInputs.result,\n\t\t\t\tprocedure\n\t\t\t}],\n\t\t\tisBatchCall: false,\n\t\t\ttype: \"mutation\",\n\t\t\tconnectionParams: null,\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t}\n};\nconst octetStreamContentTypeHandler = {\n\tisMatch(req) {\n\t\treturn !!req.headers.get(\"content-type\")?.startsWith(\"application/octet-stream\");\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tif (req.method !== \"POST\") throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\tmessage: \"Only POST requests are supported for application/octet-stream requests\"\n\t\t});\n\t\tconst getInputs = memo(async () => {\n\t\t\treturn req.body;\n\t\t});\n\t\treturn {\n\t\t\tcalls: [{\n\t\t\t\tpath: opts.path,\n\t\t\t\tgetRawInput: getInputs.read,\n\t\t\t\tresult: getInputs.result,\n\t\t\t\tprocedure: await (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path)\n\t\t\t}],\n\t\t\tisBatchCall: false,\n\t\t\taccept: null,\n\t\t\ttype: \"mutation\",\n\t\t\tconnectionParams: null,\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t}\n};\nconst handlers = [\n\tjsonContentTypeHandler,\n\tformDataContentTypeHandler,\n\toctetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n\tconst handler = handlers.find((handler$1) => handler$1.isMatch(req));\n\tif (handler) return handler;\n\tif (!handler && req.method === \"GET\") return jsonContentTypeHandler;\n\tthrow new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\tmessage: req.headers.has(\"content-type\") ? `Unsupported content-type \"${req.headers.get(\"content-type\")}` : \"Missing content-type header\"\n\t});\n}\nasync function getRequestInfo(opts) {\n\tconst handler = getContentTypeHandler(opts.req);\n\treturn await handler.parse(opts);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/abortError.ts\nfunction isAbortError(error) {\n\treturn (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(error) && error[\"name\"] === \"AbortError\";\n}\nfunction throwAbortError(message = \"AbortError\") {\n\tthrow new DOMException(message, \"AbortError\");\n}\n\n//#endregion\n//#region src/vendor/unpromise/unpromise.ts\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n* which is retained for the lifetime of the original Promise.\n*/\nconst subscribableCache = /* @__PURE__ */ new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n* SubscribedPromises (settled promises are not subscribed - they resolve\n* immediately). */\nconst NOOP = () => {};\n/**\n* Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n* created once, cached and reused throughout the lifetime of the Promise. Get a\n* Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n*\n* The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n* `.then()` and `.catch()` just once. Promises derived from it use a\n* subscription- (and unsubscription-) based mechanism that monitors these\n* handlers.\n*\n* Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n* `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n* `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n* from the original, potentially long-lived Promise, eliminating memory leaks.\n*\n* This approach can eliminate the memory leaks that otherwise come about from\n* repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n* times on the same long-lived native Promise (subscriptions which can never be\n* cleaned up).\n*\n* `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n* any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n* the scenes, `resolve` is implemented simply as\n* `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n* to tidy up!\n*\n*/\nvar Unpromise = class Unpromise {\n\t/** INSTANCE IMPLEMENTATION */\n\t/** The promise shadowed by this Unpromise<T>  */\n\tpromise;\n\t/** Promises expecting eventual settlement (unless unsubscribed first). This list is deleted\n\t* after the original promise settles - no further notifications will be issued. */\n\tsubscribers = [];\n\t/** The Promise's settlement (recorded when it fulfils or rejects). This is consulted when\n\t* calling .subscribe() .then() .catch() .finally() to see if an immediately-resolving Promise\n\t* can be returned, and therefore subscription can be bypassed. */\n\tsettlement = null;\n\tconstructor(arg) {\n\t\tif (typeof arg === \"function\") this.promise = new Promise(arg);\n\t\telse this.promise = arg;\n\t\tconst thenReturn = this.promise.then((value) => {\n\t\t\tconst { subscribers } = this;\n\t\t\tthis.subscribers = null;\n\t\t\tthis.settlement = {\n\t\t\t\tstatus: \"fulfilled\",\n\t\t\t\tvalue\n\t\t\t};\n\t\t\tsubscribers?.forEach(({ resolve }) => {\n\t\t\t\tresolve(value);\n\t\t\t});\n\t\t});\n\t\tif (\"catch\" in thenReturn) thenReturn.catch((reason) => {\n\t\t\tconst { subscribers } = this;\n\t\t\tthis.subscribers = null;\n\t\t\tthis.settlement = {\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\treason\n\t\t\t};\n\t\t\tsubscribers?.forEach(({ reject }) => {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t});\n\t}\n\t/** Create a promise that mitigates uncontrolled subscription to a long-lived\n\t* Promise via .then() and .catch() - otherwise a source of memory leaks.\n\t*\n\t* The returned promise has an `unsubscribe()` method which can be called when\n\t* the Promise is no longer being tracked by application logic, and which\n\t* ensures that there is no reference chain from the original promise to the\n\t* new one, and therefore no memory leak.\n\t*\n\t* If original promise has not yet settled, this adds a new unique promise\n\t* that listens to then/catch events, along with an `unsubscribe()` method to\n\t* detach it.\n\t*\n\t* If original promise has settled, then creates a new Promise.resolve() or\n\t* Promise.reject() and provided unsubscribe is a noop.\n\t*\n\t* If you call `unsubscribe()` before the returned Promise has settled, it\n\t* will never settle.\n\t*/\n\tsubscribe() {\n\t\tlet promise;\n\t\tlet unsubscribe;\n\t\tconst { settlement } = this;\n\t\tif (settlement === null) {\n\t\t\tif (this.subscribers === null) throw new Error(\"Unpromise settled but still has subscribers\");\n\t\t\tconst subscriber = withResolvers();\n\t\t\tthis.subscribers = listWithMember(this.subscribers, subscriber);\n\t\t\tpromise = subscriber.promise;\n\t\t\tunsubscribe = () => {\n\t\t\t\tif (this.subscribers !== null) this.subscribers = listWithoutMember(this.subscribers, subscriber);\n\t\t\t};\n\t\t} else {\n\t\t\tconst { status } = settlement;\n\t\t\tif (status === \"fulfilled\") promise = Promise.resolve(settlement.value);\n\t\t\telse promise = Promise.reject(settlement.reason);\n\t\t\tunsubscribe = NOOP;\n\t\t}\n\t\treturn Object.assign(promise, { unsubscribe });\n\t}\n\t/** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */\n\tthen(onfulfilled, onrejected) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.then(onfulfilled, onrejected), { unsubscribe });\n\t}\n\tcatch(onrejected) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.catch(onrejected), { unsubscribe });\n\t}\n\tfinally(onfinally) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.finally(onfinally), { unsubscribe });\n\t}\n\t/** TOSTRING SUPPORT */\n\t[Symbol.toStringTag] = \"Unpromise\";\n\t/** Unpromise STATIC METHODS */\n\t/** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n\t* of the provided Promise reference) */\n\tstatic proxy(promise) {\n\t\tconst cached = Unpromise.getSubscribablePromise(promise);\n\t\treturn typeof cached !== \"undefined\" ? cached : Unpromise.createSubscribablePromise(promise);\n\t}\n\t/** Create and store an Unpromise keyed by an original Promise. */\n\tstatic createSubscribablePromise(promise) {\n\t\tconst created = new Unpromise(promise);\n\t\tsubscribableCache.set(promise, created);\n\t\tsubscribableCache.set(created, created);\n\t\treturn created;\n\t}\n\t/** Retrieve a previously-created Unpromise keyed by an original Promise. */\n\tstatic getSubscribablePromise(promise) {\n\t\treturn subscribableCache.get(promise);\n\t}\n\t/** Promise STATIC METHODS */\n\t/** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n\t* it (that can be later unsubscribed to eliminate Memory leaks) */\n\tstatic resolve(value) {\n\t\tconst promise = typeof value === \"object\" && value !== null && \"then\" in value && typeof value.then === \"function\" ? value : Promise.resolve(value);\n\t\treturn Unpromise.proxy(promise).subscribe();\n\t}\n\tstatic async any(values) {\n\t\tconst valuesArray = Array.isArray(values) ? values : [...values];\n\t\tconst subscribedPromises = valuesArray.map(Unpromise.resolve);\n\t\ttry {\n\t\t\treturn await Promise.any(subscribedPromises);\n\t\t} finally {\n\t\t\tsubscribedPromises.forEach(({ unsubscribe }) => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\t}\n\tstatic async race(values) {\n\t\tconst valuesArray = Array.isArray(values) ? values : [...values];\n\t\tconst subscribedPromises = valuesArray.map(Unpromise.resolve);\n\t\ttry {\n\t\t\treturn await Promise.race(subscribedPromises);\n\t\t} finally {\n\t\t\tsubscribedPromises.forEach(({ unsubscribe }) => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\t}\n\t/** Create a race of SubscribedPromises that will fulfil to a single winning\n\t* Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n\t* accumulating .then() and .catch() subscribers. Allows simple logic to\n\t* consume the result, like...\n\t* ```ts\n\t* const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n\t* if(winner === promiseB){\n\t*   const result = await promiseB;\n\t*   // do the thing\n\t* }\n\t* ```\n\t* */\n\tstatic async raceReferences(promises) {\n\t\tconst selfPromises = promises.map(resolveSelfTuple);\n\t\ttry {\n\t\t\treturn await Promise.race(selfPromises);\n\t\t} finally {\n\t\t\tfor (const promise of selfPromises) promise.unsubscribe();\n\t\t}\n\t}\n};\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n* awaiting the eventual Promise ***reference*** (easy to destructure and\n* exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n* may be ambiguous and therefore hard to identify as the winner of a race).\n* You can call unsubscribe on the Promise to mitigate memory leaks.\n* */\nfunction resolveSelfTuple(promise) {\n\treturn Unpromise.proxy(promise).then(() => [promise]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */\n/** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */\nfunction withResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n/** IMMUTABLE LIST OPERATIONS */\nfunction listWithMember(arr, member) {\n\treturn [...arr, member];\n}\nfunction listWithoutIndex(arr, index) {\n\treturn [...arr.slice(0, index), ...arr.slice(index + 1)];\n}\nfunction listWithoutMember(arr, member) {\n\tconst index = arr.indexOf(member);\n\tif (index !== -1) return listWithoutIndex(arr, index);\n\treturn arr;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/disposable.ts\nSymbol.dispose ??= Symbol();\nSymbol.asyncDispose ??= Symbol();\n/**\n* Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n* The returned object is the original value augmented with a Symbol.dispose method.\n* @param thing The value to make disposable\n* @param dispose Function to call when disposing the resource\n* @returns The original value with Symbol.dispose method added\n*/\nfunction makeResource(thing, dispose) {\n\tconst it = thing;\n\tconst existing = it[Symbol.dispose];\n\tit[Symbol.dispose] = () => {\n\t\tdispose();\n\t\texisting?.();\n\t};\n\treturn it;\n}\n/**\n* Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n* The returned object is the original value augmented with a Symbol.asyncDispose method.\n* @param thing The value to make async disposable\n* @param dispose Async function to call when disposing the resource\n* @returns The original value with Symbol.asyncDispose method added\n*/\nfunction makeAsyncResource(thing, dispose) {\n\tconst it = thing;\n\tconst existing = it[Symbol.asyncDispose];\n\tit[Symbol.asyncDispose] = async () => {\n\t\tawait dispose();\n\t\tawait existing?.();\n\t};\n\treturn it;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/timerResource.ts\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n\tlet timer = null;\n\treturn makeResource({ start() {\n\t\tif (timer) throw new Error(\"Timer already started\");\n\t\tconst promise = new Promise((resolve) => {\n\t\t\ttimer = setTimeout(() => resolve(disposablePromiseTimerResult), ms);\n\t\t});\n\t\treturn promise;\n\t} }, () => {\n\t\tif (timer) clearTimeout(timer);\n\t});\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\nvar require_usingCtx = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\"(exports, module) {\n\tfunction _usingCtx() {\n\t\tvar r = \"function\" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {\n\t\t\tvar n$1 = Error();\n\t\t\treturn n$1.name = \"SuppressedError\", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n\t\t}, e = {}, n = [];\n\t\tfunction using(r$1, e$1) {\n\t\t\tif (null != e$1) {\n\t\t\t\tif (Object(e$1) !== e$1) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n\t\t\t\tif (r$1) var o = e$1[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n\t\t\t\tif (void 0 === o && (o = e$1[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r$1)) var t = o;\n\t\t\t\tif (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n\t\t\t\tt && (o = function o$1() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.call(e$1);\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn Promise.reject(r$2);\n\t\t\t\t\t}\n\t\t\t\t}), n.push({\n\t\t\t\t\tv: e$1,\n\t\t\t\t\td: o,\n\t\t\t\t\ta: r$1\n\t\t\t\t});\n\t\t\t} else r$1 && n.push({\n\t\t\t\td: e$1,\n\t\t\t\ta: r$1\n\t\t\t});\n\t\t\treturn e$1;\n\t\t}\n\t\treturn {\n\t\t\te,\n\t\t\tu: using.bind(null, !1),\n\t\t\ta: using.bind(null, !0),\n\t\t\td: function d() {\n\t\t\t\tvar o, t = this.e, s = 0;\n\t\t\t\tfunction next() {\n\t\t\t\t\tfor (; o = n.pop();) try {\n\t\t\t\t\t\tif (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n\t\t\t\t\t\tif (o.d) {\n\t\t\t\t\t\t\tvar r$1 = o.d.call(o.v);\n\t\t\t\t\t\t\tif (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n\t\t\t\t\t\t} else s |= 1;\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn err(r$2);\n\t\t\t\t\t}\n\t\t\t\t\tif (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n\t\t\t\t\tif (t !== e) throw t;\n\t\t\t\t}\n\t\t\t\tfunction err(n$1) {\n\t\t\t\t\treturn t = t !== e ? new r(n$1, t) : n$1, next();\n\t\t\t\t}\n\t\t\t\treturn next();\n\t\t\t}\n\t\t};\n\t}\n\tmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/asyncIterable.ts\nvar import_usingCtx$4 = __toESM(require_usingCtx(), 1);\nfunction iteratorResource(iterable) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\tif (iterator[Symbol.asyncDispose]) return iterator;\n\treturn makeAsyncResource(iterator, async () => {\n\t\tawait iterator.return?.();\n\t});\n}\n/**\n* Derives a new {@link AsyncGenerator} based on {@link iterable}, that automatically aborts after the specified duration.\n*/\nasync function* withMaxDuration(iterable, opts) {\n\ttry {\n\t\tvar _usingCtx$1 = (0, import_usingCtx$4.default)();\n\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable));\n\t\tconst timer = _usingCtx$1.u(timerResource(opts.maxDurationMs));\n\t\tconst timerPromise = timer.start();\n\t\tlet result;\n\t\twhile (true) {\n\t\t\tresult = await Unpromise.race([iterator.next(), timerPromise]);\n\t\t\tif (result === disposablePromiseTimerResult) throwAbortError();\n\t\t\tif (result.done) return result;\n\t\t\tyield result.value;\n\t\t\tresult = null;\n\t\t}\n\t} catch (_) {\n\t\t_usingCtx$1.e = _;\n\t} finally {\n\t\tawait _usingCtx$1.d();\n\t}\n}\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n* {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n* values may still come through. After this period, the generator aborts.\n*/\nasync function* takeWithGrace(iterable, opts) {\n\ttry {\n\t\tvar _usingCtx3 = (0, import_usingCtx$4.default)();\n\t\tconst iterator = _usingCtx3.a(iteratorResource(iterable));\n\t\tlet result;\n\t\tconst timer = _usingCtx3.u(timerResource(opts.gracePeriodMs));\n\t\tlet count = opts.count;\n\t\tlet timerPromise = new Promise(() => {});\n\t\twhile (true) {\n\t\t\tresult = await Unpromise.race([iterator.next(), timerPromise]);\n\t\t\tif (result === disposablePromiseTimerResult) throwAbortError();\n\t\t\tif (result.done) return result.value;\n\t\t\tyield result.value;\n\t\t\tif (--count === 0) timerPromise = timer.start();\n\t\t\tresult = null;\n\t\t}\n\t} catch (_) {\n\t\t_usingCtx3.e = _;\n\t} finally {\n\t\tawait _usingCtx3.d();\n\t}\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/createDeferred.ts\nfunction createDeferred() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts\nvar import_usingCtx$3 = __toESM(require_usingCtx(), 1);\nfunction createManagedIterator(iterable, onResult) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\tlet state = \"idle\";\n\tfunction cleanup() {\n\t\tstate = \"done\";\n\t\tonResult = () => {};\n\t}\n\tfunction pull() {\n\t\tif (state !== \"idle\") return;\n\t\tstate = \"pending\";\n\t\tconst next = iterator.next();\n\t\tnext.then((result) => {\n\t\t\tif (result.done) {\n\t\t\t\tstate = \"done\";\n\t\t\t\tonResult({\n\t\t\t\t\tstatus: \"return\",\n\t\t\t\t\tvalue: result.value\n\t\t\t\t});\n\t\t\t\tcleanup();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstate = \"idle\";\n\t\t\tonResult({\n\t\t\t\tstatus: \"yield\",\n\t\t\t\tvalue: result.value\n\t\t\t});\n\t\t}).catch((cause) => {\n\t\t\tonResult({\n\t\t\t\tstatus: \"error\",\n\t\t\t\terror: cause\n\t\t\t});\n\t\t\tcleanup();\n\t\t});\n\t}\n\treturn {\n\t\tpull,\n\t\tdestroy: async () => {\n\t\t\tcleanup();\n\t\t\tawait iterator.return?.();\n\t\t}\n\t};\n}\n/**\n* Creates a new async iterable that merges multiple async iterables into a single stream.\n* Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n*\n* New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n*\n* If any of the input iterables throws an error, that error will be propagated through the merged stream.\n* Other iterables will not continue to be processed.\n*\n* @template TYield The type of values yielded by the input iterables\n*/\nfunction mergeAsyncIterables() {\n\tlet state = \"idle\";\n\tlet flushSignal = createDeferred();\n\t/**\n\t* used while {@link state} is `idle`\n\t*/\n\tconst iterables = [];\n\t/**\n\t* used while {@link state} is `pending`\n\t*/\n\tconst iterators = /* @__PURE__ */ new Set();\n\tconst buffer = [];\n\tfunction initIterable(iterable) {\n\t\tif (state !== \"pending\") return;\n\t\tconst iterator = createManagedIterator(iterable, (result) => {\n\t\t\tif (state !== \"pending\") return;\n\t\t\tswitch (result.status) {\n\t\t\t\tcase \"yield\":\n\t\t\t\t\tbuffer.push([iterator, result]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"return\":\n\t\t\t\t\titerators.delete(iterator);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"error\":\n\t\t\t\t\tbuffer.push([iterator, result]);\n\t\t\t\t\titerators.delete(iterator);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflushSignal.resolve();\n\t\t});\n\t\titerators.add(iterator);\n\t\titerator.pull();\n\t}\n\treturn {\n\t\tadd(iterable) {\n\t\t\tswitch (state) {\n\t\t\t\tcase \"idle\":\n\t\t\t\t\titerables.push(iterable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pending\":\n\t\t\t\t\tinitIterable(iterable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"done\": break;\n\t\t\t}\n\t\t},\n\t\tasync *[Symbol.asyncIterator]() {\n\t\t\ttry {\n\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx$3.default)();\n\t\t\t\tif (state !== \"idle\") throw new Error(\"Cannot iterate twice\");\n\t\t\t\tstate = \"pending\";\n\t\t\t\tconst _finally = _usingCtx$1.a(makeAsyncResource({}, async () => {\n\t\t\t\t\tstate = \"done\";\n\t\t\t\t\tconst errors = [];\n\t\t\t\t\tawait Promise.all(Array.from(iterators.values()).map(async (it) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait it.destroy();\n\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\terrors.push(cause);\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t\tbuffer.length = 0;\n\t\t\t\t\titerators.clear();\n\t\t\t\t\tflushSignal.resolve();\n\t\t\t\t\tif (errors.length > 0) throw new AggregateError(errors);\n\t\t\t\t}));\n\t\t\t\twhile (iterables.length > 0) initIterable(iterables.shift());\n\t\t\t\twhile (iterators.size > 0) {\n\t\t\t\t\tawait flushSignal.promise;\n\t\t\t\t\twhile (buffer.length > 0) {\n\t\t\t\t\t\tconst [iterator, result] = buffer.shift();\n\t\t\t\t\t\tswitch (result.status) {\n\t\t\t\t\t\t\tcase \"yield\":\n\t\t\t\t\t\t\t\tyield result.value;\n\t\t\t\t\t\t\t\titerator.pull();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"error\": throw result.error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tflushSignal = createDeferred();\n\t\t\t\t}\n\t\t\t} catch (_) {\n\t\t\t\t_usingCtx$1.e = _;\n\t\t\t} finally {\n\t\t\t\tawait _usingCtx$1.d();\n\t\t\t}\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts\n/**\n* Creates a ReadableStream from an AsyncIterable.\n*\n* @param iterable - The source AsyncIterable to stream from\n* @returns A ReadableStream that yields values from the AsyncIterable\n*/\nfunction readableStreamFrom(iterable) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\treturn new ReadableStream({\n\t\tasync cancel() {\n\t\t\tawait iterator.return?.();\n\t\t},\n\t\tasync pull(controller) {\n\t\t\tconst result = await iterator.next();\n\t\t\tif (result.done) {\n\t\t\t\tcontroller.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontroller.enqueue(result.value);\n\t\t}\n\t});\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/withPing.ts\nvar import_usingCtx$2 = __toESM(require_usingCtx(), 1);\nconst PING_SYM = Symbol(\"ping\");\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n* whenever no value has been yielded for {@link pingIntervalMs}.\n*/\nasync function* withPing(iterable, pingIntervalMs) {\n\ttry {\n\t\tvar _usingCtx$1 = (0, import_usingCtx$2.default)();\n\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable));\n\t\tlet result;\n\t\tlet nextPromise = iterator.next();\n\t\twhile (true) try {\n\t\t\tvar _usingCtx3 = (0, import_usingCtx$2.default)();\n\t\t\tconst pingPromise = _usingCtx3.u(timerResource(pingIntervalMs));\n\t\t\tresult = await Unpromise.race([nextPromise, pingPromise.start()]);\n\t\t\tif (result === disposablePromiseTimerResult) {\n\t\t\t\tyield PING_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (result.done) return result.value;\n\t\t\tnextPromise = iterator.next();\n\t\t\tyield result.value;\n\t\t\tresult = null;\n\t\t} catch (_) {\n\t\t\t_usingCtx3.e = _;\n\t\t} finally {\n\t\t\t_usingCtx3.d();\n\t\t}\n\t} catch (_) {\n\t\t_usingCtx$1.e = _;\n\t} finally {\n\t\tawait _usingCtx$1.d();\n\t}\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/jsonl.ts\nvar import_usingCtx$1 = __toESM(require_usingCtx(), 1);\nfunction isPlainObject(value) {\n\treturn Object.prototype.toString.call(value) === \"[object Object]\";\n}\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n\treturn ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) && typeof value?.[\"then\"] === \"function\" && typeof value?.[\"catch\"] === \"function\";\n}\nvar MaxDepthError = class extends Error {\n\tconstructor(path) {\n\t\tsuper(\"Max depth reached at path: \" + path.join(\".\"));\n\t\tthis.path = path;\n\t}\n};\nasync function* createBatchStreamProducer(opts) {\n\tconst { data } = opts;\n\tlet counter = 0;\n\tconst placeholder = 0;\n\tconst mergedIterables = mergeAsyncIterables();\n\tfunction registerAsync(callback) {\n\t\tconst idx = counter++;\n\t\tconst iterable$1 = callback(idx);\n\t\tmergedIterables.add(iterable$1);\n\t\treturn idx;\n\t}\n\tfunction encodePromise(promise, path) {\n\t\treturn registerAsync(async function* (idx) {\n\t\t\tconst error = checkMaxDepth(path);\n\t\t\tif (error) {\n\t\t\t\tpromise.catch((cause) => {\n\t\t\t\t\topts.onError?.({\n\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\tpath\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tpromise = Promise.reject(error);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst next = await promise;\n\t\t\t\tyield [\n\t\t\t\t\tidx,\n\t\t\t\t\tPROMISE_STATUS_FULFILLED,\n\t\t\t\t\tencode(next, path)\n\t\t\t\t];\n\t\t\t} catch (cause) {\n\t\t\t\topts.onError?.({\n\t\t\t\t\terror: cause,\n\t\t\t\t\tpath\n\t\t\t\t});\n\t\t\t\tyield [\n\t\t\t\t\tidx,\n\t\t\t\t\tPROMISE_STATUS_REJECTED,\n\t\t\t\t\topts.formatError?.({\n\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\tpath\n\t\t\t\t\t})\n\t\t\t\t];\n\t\t\t}\n\t\t});\n\t}\n\tfunction encodeAsyncIterable(iterable$1, path) {\n\t\treturn registerAsync(async function* (idx) {\n\t\t\ttry {\n\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx$1.default)();\n\t\t\t\tconst error = checkMaxDepth(path);\n\t\t\t\tif (error) throw error;\n\t\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable$1));\n\t\t\t\ttry {\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tconst next = await iterator.next();\n\t\t\t\t\t\tif (next.done) {\n\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_RETURN,\n\t\t\t\t\t\t\t\tencode(next.value, path)\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_YIELD,\n\t\t\t\t\t\t\tencode(next.value, path)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t} catch (cause) {\n\t\t\t\t\topts.onError?.({\n\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\tpath\n\t\t\t\t\t});\n\t\t\t\t\tyield [\n\t\t\t\t\t\tidx,\n\t\t\t\t\t\tASYNC_ITERABLE_STATUS_ERROR,\n\t\t\t\t\t\topts.formatError?.({\n\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t})\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t} catch (_) {\n\t\t\t\t_usingCtx$1.e = _;\n\t\t\t} finally {\n\t\t\t\tawait _usingCtx$1.d();\n\t\t\t}\n\t\t});\n\t}\n\tfunction checkMaxDepth(path) {\n\t\tif (opts.maxDepth && path.length > opts.maxDepth) return new MaxDepthError(path);\n\t\treturn null;\n\t}\n\tfunction encodeAsync(value, path) {\n\t\tif (isPromise(value)) return [CHUNK_VALUE_TYPE_PROMISE, encodePromise(value, path)];\n\t\tif ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(value)) {\n\t\t\tif (opts.maxDepth && path.length >= opts.maxDepth) throw new Error(\"Max depth reached\");\n\t\t\treturn [CHUNK_VALUE_TYPE_ASYNC_ITERABLE, encodeAsyncIterable(value, path)];\n\t\t}\n\t\treturn null;\n\t}\n\tfunction encode(value, path) {\n\t\tif (value === void 0) return [[]];\n\t\tconst reg = encodeAsync(value, path);\n\t\tif (reg) return [[placeholder], [null, ...reg]];\n\t\tif (!isPlainObject(value)) return [[value]];\n\t\tconst newObj = {};\n\t\tconst asyncValues = [];\n\t\tfor (const [key, item] of Object.entries(value)) {\n\t\t\tconst transformed = encodeAsync(item, [...path, key]);\n\t\t\tif (!transformed) {\n\t\t\t\tnewObj[key] = item;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnewObj[key] = placeholder;\n\t\t\tasyncValues.push([key, ...transformed]);\n\t\t}\n\t\treturn [[newObj], ...asyncValues];\n\t}\n\tconst newHead = {};\n\tfor (const [key, item] of Object.entries(data)) newHead[key] = encode(item, [key]);\n\tyield newHead;\n\tlet iterable = mergedIterables;\n\tif (opts.pingMs) iterable = withPing(mergedIterables, opts.pingMs);\n\tfor await (const value of iterable) yield value;\n}\n/**\n* JSON Lines stream producer\n* @see https://jsonlines.org/\n*/\nfunction jsonlStreamProducer(opts) {\n\tlet stream = readableStreamFrom(createBatchStreamProducer(opts));\n\tconst { serialize } = opts;\n\tif (serialize) stream = stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (chunk === PING_SYM) controller.enqueue(PING_SYM);\n\t\telse controller.enqueue(serialize(chunk));\n\t} }));\n\treturn stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (chunk === PING_SYM) controller.enqueue(\" \");\n\t\telse controller.enqueue(JSON.stringify(chunk) + \"\\n\");\n\t} })).pipeThrough(new TextEncoderStream());\n}\nvar AsyncError = class extends Error {\n\tconstructor(data) {\n\t\tsuper(\"Received error from server\");\n\t\tthis.data = data;\n\t}\n};\nconst nodeJsStreamToReaderEsque = (source) => {\n\treturn { getReader() {\n\t\tconst stream = new ReadableStream({ start(controller) {\n\t\t\tsource.on(\"data\", (chunk) => {\n\t\t\t\tcontroller.enqueue(chunk);\n\t\t\t});\n\t\t\tsource.on(\"end\", () => {\n\t\t\t\tcontroller.close();\n\t\t\t});\n\t\t\tsource.on(\"error\", (error) => {\n\t\t\t\tcontroller.error(error);\n\t\t\t});\n\t\t} });\n\t\treturn stream.getReader();\n\t} };\n};\nfunction createLineAccumulator(from) {\n\tconst reader = \"getReader\" in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n\tlet lineAggregate = \"\";\n\treturn new ReadableStream({\n\t\tasync pull(controller) {\n\t\t\tconst { done, value } = await reader.read();\n\t\t\tif (done) controller.close();\n\t\t\telse controller.enqueue(value);\n\t\t},\n\t\tcancel() {\n\t\t\treturn reader.cancel();\n\t\t}\n\t}).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tlineAggregate += chunk;\n\t\tconst parts = lineAggregate.split(\"\\n\");\n\t\tlineAggregate = parts.pop() ?? \"\";\n\t\tfor (const part of parts) controller.enqueue(part);\n\t} }));\n}\nfunction createConsumerStream(from) {\n\tconst stream = createLineAccumulator(from);\n\tlet sentHead = false;\n\treturn stream.pipeThrough(new TransformStream({ transform(line, controller) {\n\t\tif (!sentHead) {\n\t\t\tconst head = JSON.parse(line);\n\t\t\tcontroller.enqueue(head);\n\t\t\tsentHead = true;\n\t\t} else {\n\t\t\tconst chunk = JSON.parse(line);\n\t\t\tcontroller.enqueue(chunk);\n\t\t}\n\t} }));\n}\n/**\n* Creates a handler for managing stream controllers and their lifecycle\n*/\nfunction createStreamsManager(abortController) {\n\tconst controllerMap = /* @__PURE__ */ new Map();\n\t/**\n\t* Checks if there are no pending controllers or deferred promises\n\t*/\n\tfunction isEmpty() {\n\t\treturn Array.from(controllerMap.values()).every((c) => c.closed);\n\t}\n\t/**\n\t* Creates a stream controller\n\t*/\n\tfunction createStreamController() {\n\t\tlet originalController;\n\t\tconst stream = new ReadableStream({ start(controller) {\n\t\t\toriginalController = controller;\n\t\t} });\n\t\tconst streamController = {\n\t\t\tenqueue: (v) => originalController.enqueue(v),\n\t\t\tclose: () => {\n\t\t\t\toriginalController.close();\n\t\t\t\tclear();\n\t\t\t\tif (isEmpty()) abortController.abort();\n\t\t\t},\n\t\t\tclosed: false,\n\t\t\tgetReaderResource: () => {\n\t\t\t\tconst reader = stream.getReader();\n\t\t\t\treturn makeResource(reader, () => {\n\t\t\t\t\treader.releaseLock();\n\t\t\t\t\tstreamController.close();\n\t\t\t\t});\n\t\t\t},\n\t\t\terror: (reason) => {\n\t\t\t\toriginalController.error(reason);\n\t\t\t\tclear();\n\t\t\t}\n\t\t};\n\t\tfunction clear() {\n\t\t\tObject.assign(streamController, {\n\t\t\t\tclosed: true,\n\t\t\t\tclose: () => {},\n\t\t\t\tenqueue: () => {},\n\t\t\t\tgetReaderResource: null,\n\t\t\t\terror: () => {}\n\t\t\t});\n\t\t}\n\t\treturn streamController;\n\t}\n\t/**\n\t* Gets or creates a stream controller\n\t*/\n\tfunction getOrCreate(chunkId) {\n\t\tlet c = controllerMap.get(chunkId);\n\t\tif (!c) {\n\t\t\tc = createStreamController();\n\t\t\tcontrollerMap.set(chunkId, c);\n\t\t}\n\t\treturn c;\n\t}\n\t/**\n\t* Cancels all pending controllers and rejects deferred promises\n\t*/\n\tfunction cancelAll(reason) {\n\t\tfor (const controller of controllerMap.values()) controller.error(reason);\n\t}\n\treturn {\n\t\tgetOrCreate,\n\t\tisEmpty,\n\t\tcancelAll\n\t};\n}\n/**\n* JSON Lines stream consumer\n* @see https://jsonlines.org/\n*/\nasync function jsonlStreamConsumer(opts) {\n\tconst { deserialize = (v) => v } = opts;\n\tlet source = createConsumerStream(opts.from);\n\tif (deserialize) source = source.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tcontroller.enqueue(deserialize(chunk));\n\t} }));\n\tlet headDeferred = createDeferred();\n\tconst streamManager = createStreamsManager(opts.abortController);\n\tfunction decodeChunkDefinition(value) {\n\t\tconst [_path, type, chunkId] = value;\n\t\tconst controller = streamManager.getOrCreate(chunkId);\n\t\tswitch (type) {\n\t\t\tcase CHUNK_VALUE_TYPE_PROMISE: return (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx3 = (0, import_usingCtx$1.default)();\n\t\t\t\t\tconst reader = _usingCtx3.u(controller.getReaderResource());\n\t\t\t\t\tconst { value: value$1 } = await reader.read();\n\t\t\t\t\tconst [_chunkId, status, data] = value$1;\n\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\tcase PROMISE_STATUS_FULFILLED: return decode(data);\n\t\t\t\t\t\tcase PROMISE_STATUS_REJECTED: throw opts.formatError?.({ error: data }) ?? new AsyncError(data);\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx3.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx3.d();\n\t\t\t\t}\n\t\t\t});\n\t\t\tcase CHUNK_VALUE_TYPE_ASYNC_ITERABLE: return (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async function* () {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx4 = (0, import_usingCtx$1.default)();\n\t\t\t\t\tconst reader = _usingCtx4.u(controller.getReaderResource());\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tconst { value: value$1 } = await reader.read();\n\t\t\t\t\t\tconst [_chunkId, status, data] = value$1;\n\t\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_YIELD:\n\t\t\t\t\t\t\t\tyield decode(data);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_RETURN: return decode(data);\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_ERROR: throw opts.formatError?.({ error: data }) ?? new AsyncError(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx4.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx4.d();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tfunction decode(value) {\n\t\tconst [[data], ...asyncProps] = value;\n\t\tfor (const value$1 of asyncProps) {\n\t\t\tconst [key] = value$1;\n\t\t\tconst decoded = decodeChunkDefinition(value$1);\n\t\t\tif (key === null) return decoded;\n\t\t\tdata[key] = decoded;\n\t\t}\n\t\treturn data;\n\t}\n\tconst closeOrAbort = (reason) => {\n\t\theadDeferred?.reject(reason);\n\t\tstreamManager.cancelAll(reason);\n\t};\n\tsource.pipeTo(new WritableStream({\n\t\twrite(chunkOrHead) {\n\t\t\tif (headDeferred) {\n\t\t\t\tconst head = chunkOrHead;\n\t\t\t\tfor (const [key, value] of Object.entries(chunkOrHead)) {\n\t\t\t\t\tconst parsed = decode(value);\n\t\t\t\t\thead[key] = parsed;\n\t\t\t\t}\n\t\t\t\theadDeferred.resolve(head);\n\t\t\t\theadDeferred = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst chunk = chunkOrHead;\n\t\t\tconst [idx] = chunk;\n\t\t\tconst controller = streamManager.getOrCreate(idx);\n\t\t\tcontroller.enqueue(chunk);\n\t\t},\n\t\tclose: () => closeOrAbort(new Error(\"Stream closed\")),\n\t\tabort: closeOrAbort\n\t}), { signal: opts.abortController.signal }).catch((error) => {\n\t\topts.onError?.({ error });\n\t\tcloseOrAbort(error);\n\t});\n\treturn [await headDeferred.promise, streamManager];\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/sse.ts\nvar import_usingCtx = __toESM(require_usingCtx(), 1);\nconst PING_EVENT = \"ping\";\nconst SERIALIZED_ERROR_EVENT = \"serialized-error\";\nconst CONNECTED_EVENT = \"connected\";\nconst RETURN_EVENT = \"return\";\n/**\n*\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/\nfunction sseStreamProducer(opts) {\n\tconst { serialize = _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.identity } = opts;\n\tconst ping = {\n\t\tenabled: opts.ping?.enabled ?? false,\n\t\tintervalMs: opts.ping?.intervalMs ?? 1e3\n\t};\n\tconst client = opts.client ?? {};\n\tif (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);\n\tasync function* generator() {\n\t\tyield {\n\t\t\tevent: CONNECTED_EVENT,\n\t\t\tdata: JSON.stringify(client)\n\t\t};\n\t\tlet iterable = opts.data;\n\t\tif (opts.emitAndEndImmediately) iterable = takeWithGrace(iterable, {\n\t\t\tcount: 1,\n\t\t\tgracePeriodMs: 1\n\t\t});\n\t\tif (opts.maxDurationMs && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) iterable = withMaxDuration(iterable, { maxDurationMs: opts.maxDurationMs });\n\t\tif (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) iterable = withPing(iterable, ping.intervalMs);\n\t\tlet value;\n\t\tlet chunk;\n\t\tfor await (value of iterable) {\n\t\t\tif (value === PING_SYM) {\n\t\t\t\tyield {\n\t\t\t\t\tevent: PING_EVENT,\n\t\t\t\t\tdata: \"\"\n\t\t\t\t};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchunk = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.isTrackedEnvelope)(value) ? {\n\t\t\t\tid: value[0],\n\t\t\t\tdata: value[1]\n\t\t\t} : { data: value };\n\t\t\tchunk.data = JSON.stringify(serialize(chunk.data));\n\t\t\tyield chunk;\n\t\t\tvalue = null;\n\t\t\tchunk = null;\n\t\t}\n\t}\n\tasync function* generatorWithErrorHandling() {\n\t\ttry {\n\t\t\tyield* generator();\n\t\t\tyield {\n\t\t\t\tevent: RETURN_EVENT,\n\t\t\t\tdata: \"\"\n\t\t\t};\n\t\t} catch (cause) {\n\t\t\tif (isAbortError(cause)) return;\n\t\t\tconst error = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\t\t\tconst data = opts.formatError?.({ error }) ?? null;\n\t\t\tyield {\n\t\t\t\tevent: SERIALIZED_ERROR_EVENT,\n\t\t\t\tdata: JSON.stringify(serialize(data))\n\t\t\t};\n\t\t}\n\t}\n\tconst stream = readableStreamFrom(generatorWithErrorHandling());\n\treturn stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (\"event\" in chunk) controller.enqueue(`event: ${chunk.event}\\n`);\n\t\tif (\"data\" in chunk) controller.enqueue(`data: ${chunk.data}\\n`);\n\t\tif (\"id\" in chunk) controller.enqueue(`id: ${chunk.id}\\n`);\n\t\tif (\"comment\" in chunk) controller.enqueue(`: ${chunk.comment}\\n`);\n\t\tcontroller.enqueue(\"\\n\\n\");\n\t} })).pipeThrough(new TextEncoderStream());\n}\nasync function withTimeout(opts) {\n\ttry {\n\t\tvar _usingCtx$1 = (0, import_usingCtx.default)();\n\t\tconst timeoutPromise = _usingCtx$1.u(timerResource(opts.timeoutMs));\n\t\tconst res = await Unpromise.race([opts.promise, timeoutPromise.start()]);\n\t\tif (res === disposablePromiseTimerResult) return await opts.onTimeout();\n\t\treturn res;\n\t} catch (_) {\n\t\t_usingCtx$1.e = _;\n\t} finally {\n\t\t_usingCtx$1.d();\n\t}\n}\n/**\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/\nfunction sseStreamConsumer(opts) {\n\tconst { deserialize = (v) => v } = opts;\n\tlet clientOptions = {};\n\tconst signal = opts.signal;\n\tlet _es = null;\n\tconst createStream = () => new ReadableStream({\n\t\tasync start(controller) {\n\t\t\tconst [url, init] = await Promise.all([opts.url(), opts.init()]);\n\t\t\tconst eventSource = _es = new opts.EventSource(url, init);\n\t\t\tcontroller.enqueue({\n\t\t\t\ttype: \"connecting\",\n\t\t\t\teventSource: _es,\n\t\t\t\tevent: null\n\t\t\t});\n\t\t\teventSource.addEventListener(CONNECTED_EVENT, (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tconst options = JSON.parse(msg.data);\n\t\t\t\tclientOptions = options;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"connected\",\n\t\t\t\t\toptions,\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"serialized-error\",\n\t\t\t\t\terror: deserialize(JSON.parse(msg.data)),\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(PING_EVENT, () => {\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"ping\",\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(RETURN_EVENT, () => {\n\t\t\t\teventSource.close();\n\t\t\t\tcontroller.close();\n\t\t\t\t_es = null;\n\t\t\t});\n\t\t\teventSource.addEventListener(\"error\", (event) => {\n\t\t\t\tif (eventSource.readyState === eventSource.CLOSED) controller.error(event);\n\t\t\t\telse controller.enqueue({\n\t\t\t\t\ttype: \"connecting\",\n\t\t\t\t\teventSource,\n\t\t\t\t\tevent\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(\"message\", (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tconst chunk = deserialize(JSON.parse(msg.data));\n\t\t\t\tconst def = { data: chunk };\n\t\t\t\tif (msg.lastEventId) def.id = msg.lastEventId;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"data\",\n\t\t\t\t\tdata: def,\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\tconst onAbort = () => {\n\t\t\t\ttry {\n\t\t\t\t\teventSource.close();\n\t\t\t\t\tcontroller.close();\n\t\t\t\t} catch {}\n\t\t\t};\n\t\t\tif (signal.aborted) onAbort();\n\t\t\telse signal.addEventListener(\"abort\", onAbort);\n\t\t},\n\t\tcancel() {\n\t\t\t_es?.close();\n\t\t}\n\t});\n\tconst getStreamResource = () => {\n\t\tlet stream = createStream();\n\t\tlet reader = stream.getReader();\n\t\tasync function dispose() {\n\t\t\tawait reader.cancel();\n\t\t\t_es = null;\n\t\t}\n\t\treturn makeAsyncResource({\n\t\t\tread() {\n\t\t\t\treturn reader.read();\n\t\t\t},\n\t\t\tasync recreate() {\n\t\t\t\tawait dispose();\n\t\t\t\tstream = createStream();\n\t\t\t\treader = stream.getReader();\n\t\t\t}\n\t\t}, dispose);\n\t};\n\treturn (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async function* () {\n\t\ttry {\n\t\t\tvar _usingCtx3 = (0, import_usingCtx.default)();\n\t\t\tconst stream = _usingCtx3.a(getStreamResource());\n\t\t\twhile (true) {\n\t\t\t\tlet promise = stream.read();\n\t\t\t\tconst timeoutMs = clientOptions.reconnectAfterInactivityMs;\n\t\t\t\tif (timeoutMs) promise = withTimeout({\n\t\t\t\t\tpromise,\n\t\t\t\t\ttimeoutMs,\n\t\t\t\t\tonTimeout: async () => {\n\t\t\t\t\t\tconst res = {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"timeout\",\n\t\t\t\t\t\t\t\tms: timeoutMs,\n\t\t\t\t\t\t\t\teventSource: _es\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdone: false\n\t\t\t\t\t\t};\n\t\t\t\t\t\tawait stream.recreate();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst result = await promise;\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tyield result.value;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx3.e = _;\n\t\t} finally {\n\t\t\tawait _usingCtx3.d();\n\t\t}\n\t});\n}\nconst sseHeaders = {\n\t\"Content-Type\": \"text/event-stream\",\n\t\"Cache-Control\": \"no-cache, no-transform\",\n\t\"X-Accel-Buffering\": \"no\",\n\tConnection: \"keep-alive\"\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/resolveResponse.ts\nfunction errorToAsyncIterable(err) {\n\treturn (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async function* () {\n\t\tthrow err;\n\t});\n}\nconst TYPE_ACCEPTED_METHOD_MAP = {\n\tmutation: [\"POST\"],\n\tquery: [\"GET\"],\n\tsubscription: [\"GET\"]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n\tmutation: [\"POST\"],\n\tquery: [\"GET\", \"POST\"],\n\tsubscription: [\"GET\", \"POST\"]\n};\nfunction initResponse(initOpts) {\n\tconst { ctx, info, responseMeta, untransformedJSON, errors = [], headers } = initOpts;\n\tlet status = untransformedJSON ? (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getHTTPStatusCode)(untransformedJSON) : 200;\n\tconst eagerGeneration = !untransformedJSON;\n\tconst data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [untransformedJSON];\n\tconst meta = responseMeta?.({\n\t\tctx,\n\t\tinfo,\n\t\tpaths: info?.calls.map((call) => call.path),\n\t\tdata,\n\t\terrors,\n\t\teagerGeneration,\n\t\ttype: info?.calls.find((call) => call.procedure?._def.type)?.procedure?._def.type ?? \"unknown\"\n\t}) ?? {};\n\tif (meta.headers) {\n\t\tif (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries()) headers.append(key, value);\n\t\telse\n /**\n\t\t* @deprecated, delete in v12\n\t\t*/\n\t\tfor (const [key, value] of Object.entries(meta.headers)) if (Array.isArray(value)) for (const v of value) headers.append(key, v);\n\t\telse if (typeof value === \"string\") headers.set(key, value);\n\t}\n\tif (meta.status) status = meta.status;\n\treturn { status };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n\tconst { router, req, onError } = errorOpts.opts;\n\tconst error = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\tonError?.({\n\t\terror,\n\t\tpath: errorOpts.path,\n\t\tinput: errorOpts.input,\n\t\tctx: errorOpts.ctx,\n\t\ttype: errorOpts.type,\n\t\treq\n\t});\n\tconst untransformedJSON = { error: (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\tconfig: router._def._config,\n\t\terror,\n\t\ttype: errorOpts.type,\n\t\tpath: errorOpts.path,\n\t\tinput: errorOpts.input,\n\t\tctx: errorOpts.ctx\n\t}) };\n\tconst transformedJSON = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(router._def._config, untransformedJSON);\n\tconst body = JSON.stringify(transformedJSON);\n\treturn {\n\t\terror,\n\t\tuntransformedJSON,\n\t\tbody\n\t};\n}\n/**\n* Check if a value is a stream-like object\n* - if it's an async iterable\n* - if it's an object with async iterables or promises\n*/\nfunction isDataStream(v) {\n\tif (!(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(v)) return false;\n\tif ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(v)) return true;\n\treturn Object.values(v).some(isPromise) || Object.values(v).some(_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n\tconst { router, req } = opts;\n\tconst headers = new Headers([[\"vary\", \"trpc-accept\"]]);\n\tconst config = router._def._config;\n\tconst url = new URL(req.url);\n\tif (req.method === \"HEAD\") return new Response(null, { status: 204 });\n\tconst allowBatching = opts.allowBatching ?? opts.batching?.enabled ?? true;\n\tconst allowMethodOverride = (opts.allowMethodOverride ?? false) && req.method === \"POST\";\n\tconst infoTuple = await (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async () => {\n\t\ttry {\n\t\t\treturn [void 0, await getRequestInfo({\n\t\t\t\treq,\n\t\t\t\tpath: decodeURIComponent(opts.path),\n\t\t\t\trouter,\n\t\t\t\tsearchParams: url.searchParams,\n\t\t\t\theaders: opts.req.headers,\n\t\t\t\turl\n\t\t\t})];\n\t\t} catch (cause) {\n\t\t\treturn [(0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause), void 0];\n\t\t}\n\t});\n\tconst ctxManager = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(() => {\n\t\tlet result = void 0;\n\t\treturn {\n\t\t\tvalueOrUndefined: () => {\n\t\t\t\tif (!result) return void 0;\n\t\t\t\treturn result[1];\n\t\t\t},\n\t\t\tvalue: () => {\n\t\t\t\tconst [err, ctx] = result;\n\t\t\t\tif (err) throw err;\n\t\t\t\treturn ctx;\n\t\t\t},\n\t\t\tcreate: async (info) => {\n\t\t\t\tif (result) throw new Error(\"This should only be called once - report a bug in tRPC\");\n\t\t\t\ttry {\n\t\t\t\t\tconst ctx = await opts.createContext({ info });\n\t\t\t\t\tresult = [void 0, ctx];\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tresult = [(0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause), void 0];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\tconst methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n\t/**\n\t* @deprecated\n\t*/\n\tconst isStreamCall = req.headers.get(\"trpc-accept\") === \"application/jsonl\";\n\tconst experimentalSSE = config.sse?.enabled ?? true;\n\ttry {\n\t\tconst [infoError, info] = infoTuple;\n\t\tif (infoError) throw infoError;\n\t\tif (info.isBatchCall && !allowBatching) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"BAD_REQUEST\",\n\t\t\tmessage: `Batching is not enabled on the server`\n\t\t});\n\t\t/* istanbul ignore if -- @preserve */\n\t\tif (isStreamCall && !info.isBatchCall) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tmessage: `Streaming requests must be batched (you can do a batch of 1)`,\n\t\t\tcode: \"BAD_REQUEST\"\n\t\t});\n\t\tawait ctxManager.create(info);\n\t\tconst rpcCalls = info.calls.map(async (call) => {\n\t\t\tconst proc = call.procedure;\n\t\t\ttry {\n\t\t\t\tif (opts.error) throw opts.error;\n\t\t\t\tif (!proc) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: \"NOT_FOUND\",\n\t\t\t\t\tmessage: `No procedure found on path \"${call.path}\"`\n\t\t\t\t});\n\t\t\t\tif (!methodMapper[proc._def.type].includes(req.method)) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\t\t\tmessage: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`\n\t\t\t\t});\n\t\t\t\tif (proc._def.type === \"subscription\") {\n\t\t\t\t\t/* istanbul ignore if -- @preserve */\n\t\t\t\t\tif (info.isBatchCall) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\t\t\tmessage: `Cannot batch subscription calls`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst data = await proc({\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\tgetRawInput: call.getRawInput,\n\t\t\t\t\tctx: ctxManager.value(),\n\t\t\t\t\ttype: proc._def.type,\n\t\t\t\t\tsignal: opts.req.signal\n\t\t\t\t});\n\t\t\t\treturn [void 0, { data }];\n\t\t\t} catch (cause) {\n\t\t\t\tconst error = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\t\t\t\tconst input = call.result();\n\t\t\t\topts.onError?.({\n\t\t\t\t\terror,\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\tinput,\n\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\ttype: call.procedure?._def.type ?? \"unknown\",\n\t\t\t\t\treq: opts.req\n\t\t\t\t});\n\t\t\t\treturn [error, void 0];\n\t\t\t}\n\t\t});\n\t\tif (!info.isBatchCall) {\n\t\t\tconst [call] = info.calls;\n\t\t\tconst [error, result] = await rpcCalls[0];\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"unknown\":\n\t\t\t\tcase \"mutation\":\n\t\t\t\tcase \"query\": {\n\t\t\t\t\theaders.set(\"content-type\", \"application/json\");\n\t\t\t\t\tif (isDataStream(result?.data)) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\t\t\t\t\tmessage: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n\t\t\t\t\t});\n\t\t\t\t\tconst res = error ? { error: (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput: call.result(),\n\t\t\t\t\t\tpath: call.path,\n\t\t\t\t\t\ttype: info.type\n\t\t\t\t\t}) } : { result: { data: result.data } };\n\t\t\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\t\t\terrors: error ? [error] : [],\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tuntransformedJSON: [res]\n\t\t\t\t\t});\n\t\t\t\t\treturn new Response(JSON.stringify((0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, res)), {\n\t\t\t\t\t\tstatus: headResponse$1.status,\n\t\t\t\t\t\theaders\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcase \"subscription\": {\n\t\t\t\t\tconst iterable = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(() => {\n\t\t\t\t\t\tif (error) return errorToAsyncIterable(error);\n\t\t\t\t\t\tif (!experimentalSSE) return errorToAsyncIterable(new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\t\t\t\t\tmessage: \"Missing experimental flag \\\"sseSubscriptions\\\"\"\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (!(0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) && !(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(result.data)) return errorToAsyncIterable(new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\t\tmessage: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n\t\t\t\t\t\t\tcode: \"INTERNAL_SERVER_ERROR\"\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tconst dataAsIterable = (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : result.data;\n\t\t\t\t\t\treturn dataAsIterable;\n\t\t\t\t\t});\n\t\t\t\t\tconst stream = sseStreamProducer({\n\t\t\t\t\t\t...config.sse,\n\t\t\t\t\t\tdata: iterable,\n\t\t\t\t\t\tserialize: (v) => config.transformer.output.serialize(v),\n\t\t\t\t\t\tformatError(errorOpts) {\n\t\t\t\t\t\t\tconst error$1 = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n\t\t\t\t\t\t\tconst input = call?.result();\n\t\t\t\t\t\t\tconst path = call?.path;\n\t\t\t\t\t\t\tconst type = call?.procedure?._def.type ?? \"unknown\";\n\t\t\t\t\t\t\topts.onError?.({\n\t\t\t\t\t\t\t\terror: error$1,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\t\treq: opts.req,\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst shape = (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\t\terror: error$1,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tfor (const [key, value] of Object.entries(sseHeaders)) headers.set(key, value);\n\t\t\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\t\t\terrors: [],\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tuntransformedJSON: null\n\t\t\t\t\t});\n\t\t\t\t\treturn new Response(stream, {\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tstatus: headResponse$1.status\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (info.accept === \"application/jsonl\") {\n\t\t\theaders.set(\"content-type\", \"application/json\");\n\t\t\theaders.set(\"transfer-encoding\", \"chunked\");\n\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\tinfo,\n\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\terrors: [],\n\t\t\t\theaders,\n\t\t\t\tuntransformedJSON: null\n\t\t\t});\n\t\t\tconst stream = jsonlStreamProducer({\n\t\t\t\t...config.jsonl,\n\t\t\t\tmaxDepth: Infinity,\n\t\t\t\tdata: rpcCalls.map(async (res) => {\n\t\t\t\t\tconst [error, result] = await res;\n\t\t\t\t\tconst call = info.calls[0];\n\t\t\t\t\tif (error) return { error: (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput: call.result(),\n\t\t\t\t\t\tpath: call.path,\n\t\t\t\t\t\ttype: call.procedure?._def.type ?? \"unknown\"\n\t\t\t\t\t}) };\n\t\t\t\t\t/**\n\t\t\t\t\t* Not very pretty, but we need to wrap nested data in promises\n\t\t\t\t\t* Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n\t\t\t\t\t*/\n\t\t\t\t\tconst iterable = (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : Promise.resolve(result.data);\n\t\t\t\t\treturn { result: Promise.resolve({ data: iterable }) };\n\t\t\t\t}),\n\t\t\t\tserialize: config.transformer.output.serialize,\n\t\t\t\tonError: (cause) => {\n\t\t\t\t\topts.onError?.({\n\t\t\t\t\t\terror: (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n\t\t\t\t\t\tpath: void 0,\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\treq: opts.req,\n\t\t\t\t\t\ttype: info?.type ?? \"unknown\"\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tformatError(errorOpts) {\n\t\t\t\t\tconst call = info?.calls[errorOpts.path[0]];\n\t\t\t\t\tconst error = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n\t\t\t\t\tconst input = call?.result();\n\t\t\t\t\tconst path = call?.path;\n\t\t\t\t\tconst type = call?.procedure?._def.type ?? \"unknown\";\n\t\t\t\t\tconst shape = (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\ttype\n\t\t\t\t\t});\n\t\t\t\t\treturn shape;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn new Response(stream, {\n\t\t\t\theaders,\n\t\t\t\tstatus: headResponse$1.status\n\t\t\t});\n\t\t}\n\t\t/**\n\t\t* Non-streaming response:\n\t\t* - await all responses in parallel, blocking on the slowest one\n\t\t* - create headers with known response body\n\t\t* - return a complete HTTPResponse\n\t\t*/\n\t\theaders.set(\"content-type\", \"application/json\");\n\t\tconst results = (await Promise.all(rpcCalls)).map((res) => {\n\t\t\tconst [error, result] = res;\n\t\t\tif (error) return res;\n\t\t\tif (isDataStream(result.data)) return [new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\t\t\tmessage: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n\t\t\t}), void 0];\n\t\t\treturn res;\n\t\t});\n\t\tconst resultAsRPCResponse = results.map(([error, result], index) => {\n\t\t\tconst call = info.calls[index];\n\t\t\tif (error) return { error: (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\tconfig,\n\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\terror,\n\t\t\t\tinput: call.result(),\n\t\t\t\tpath: call.path,\n\t\t\t\ttype: call.procedure?._def.type ?? \"unknown\"\n\t\t\t}) };\n\t\t\treturn { result: { data: result.data } };\n\t\t});\n\t\tconst errors = results.map(([error]) => error).filter(Boolean);\n\t\tconst headResponse = initResponse({\n\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\tinfo,\n\t\t\tresponseMeta: opts.responseMeta,\n\t\t\tuntransformedJSON: resultAsRPCResponse,\n\t\t\terrors,\n\t\t\theaders\n\t\t});\n\t\treturn new Response(JSON.stringify((0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, resultAsRPCResponse)), {\n\t\t\tstatus: headResponse.status,\n\t\t\theaders\n\t\t});\n\t} catch (cause) {\n\t\tconst [_infoError, info] = infoTuple;\n\t\tconst ctx = ctxManager.valueOrUndefined();\n\t\tconst { error, untransformedJSON, body } = caughtErrorToData(cause, {\n\t\t\topts,\n\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\ttype: info?.type ?? \"unknown\"\n\t\t});\n\t\tconst headResponse = initResponse({\n\t\t\tctx,\n\t\t\tinfo,\n\t\t\tresponseMeta: opts.responseMeta,\n\t\t\tuntransformedJSON,\n\t\t\terrors: [error],\n\t\t\theaders\n\t\t});\n\t\treturn new Response(body, {\n\t\t\tstatus: headResponse.status,\n\t\t\theaders\n\t\t});\n\t}\n}\n\n//#endregion\n\n//# sourceMappingURL=resolveResponse-DPbYgJDD.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9yZXNvbHZlUmVzcG9uc2UtRFBiWWdKREQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdGO0FBQzBEO0FBQzlDO0FBQ1I7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0EsMklBQTJJLE9BQU87QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZEQUFRO0FBQ2Y7QUFDQSx3R0FBd0cseUNBQXlDLElBQUksSUFBSSxhQUFhLGNBQWM7QUFDcEw7QUFDQSxHQUFHO0FBQ0gsWUFBWSw0REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksNERBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFTO0FBQ2xDLGNBQWMsNERBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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O0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4Qix3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUNBQWlDLGFBQWE7QUFDOUM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUNBQWlDLGFBQWE7QUFDOUM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNK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InNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvcmVzb2x2ZVJlc3BvbnNlLURQYllnSkRELm1qcz85ZmI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEVycm9yU2hhcGUsIGdldEhUVFBTdGF0dXNDb2RlIH0gZnJvbSBcIi4vZ2V0RXJyb3JTaGFwZS1EeVlpbDRhVC5tanNcIjtcbmltcG9ydCB7IFRSUENFcnJvciwgZ2V0UHJvY2VkdXJlQXRQYXRoLCBnZXRUUlBDRXJyb3JGcm9tVW5rbm93biwgaXNUcmFja2VkRW52ZWxvcGUsIHRyYW5zZm9ybVRSUENSZXNwb25zZSB9IGZyb20gXCIuL3RyYWNrZWQtR0VXUG9MMEMubWpzXCI7XG5pbXBvcnQgeyBpZGVudGl0eSwgaXNBc3luY0l0ZXJhYmxlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcnVuIH0gZnJvbSBcIi4vdXRpbHMtQkhaSmNCUnYubWpzXCI7XG5pbXBvcnQgeyBpc09ic2VydmFibGUsIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUgfSBmcm9tIFwiLi9vYnNlcnZhYmxlLUIxb3JMSEhJLm1qc1wiO1xuXG4vLyNyZWdpb24gcm9sbGRvd246cnVudGltZVxudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuXHRpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBrZXlzID0gX19nZXRPd25Qcm9wTmFtZXMoZnJvbSksIGkgPSAwLCBuID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IG47IGkrKykge1xuXHRcdGtleSA9IGtleXNbaV07XG5cdFx0aWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdCkgX19kZWZQcm9wKHRvLCBrZXksIHtcblx0XHRcdGdldDogKChrKSA9PiBmcm9tW2tdKS5iaW5kKG51bGwsIGtleSksXG5cdFx0XHRlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZVxuXHRcdH0pO1xuXHR9XG5cdHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwge1xuXHR2YWx1ZTogbW9kLFxuXHRlbnVtZXJhYmxlOiB0cnVlXG59KSA6IHRhcmdldCwgbW9kKSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9wYXJzZUNvbm5lY3Rpb25QYXJhbXMudHNcbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21Vbmtub3duKHBhcnNlZCkge1xuXHR0cnkge1xuXHRcdGlmIChwYXJzZWQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXHRcdGlmICghaXNPYmplY3QocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb2JqZWN0XCIpO1xuXHRcdGNvbnN0IG5vblN0cmluZ1ZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHBhcnNlZCkuZmlsdGVyKChbX2tleSwgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpO1xuXHRcdGlmIChub25TdHJpbmdWYWx1ZXMubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBjb25uZWN0aW9uUGFyYW1zIHRvIGJlIHN0cmluZyB2YWx1ZXMuIEdvdCAke25vblN0cmluZ1ZhbHVlcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fTogJHt0eXBlb2YgdmFsdWV9YCkuam9pbihcIiwgXCIpfWApO1xuXHRcdHJldHVybiBwYXJzZWQ7XG5cdH0gY2F0Y2ggKGNhdXNlKSB7XG5cdFx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRjb2RlOiBcIlBBUlNFX0VSUk9SXCIsXG5cdFx0XHRtZXNzYWdlOiBcIkludmFsaWQgY29ubmVjdGlvbiBwYXJhbXMgc2hhcGVcIixcblx0XHRcdGNhdXNlXG5cdFx0fSk7XG5cdH1cbn1cbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoc3RyKSB7XG5cdGxldCBwYXJzZWQ7XG5cdHRyeSB7XG5cdFx0cGFyc2VkID0gSlNPTi5wYXJzZShzdHIpO1xuXHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJQQVJTRV9FUlJPUlwiLFxuXHRcdFx0bWVzc2FnZTogXCJOb3QgSlNPTi1wYXJzYWJsZSBxdWVyeSBwYXJhbXNcIixcblx0XHRcdGNhdXNlXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21Vbmtub3duKHBhcnNlZCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9jb250ZW50VHlwZS50c1xuLyoqXG4qIE1lbW9pemUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vIGFyZ3VtZW50c1xuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBtZW1vKGZuKSB7XG5cdGxldCBwcm9taXNlID0gbnVsbDtcblx0Y29uc3Qgc3ltID0gU3ltYm9sLmZvcihcIkB0cnBjL3NlcnZlci9odHRwL21lbW9cIik7XG5cdGxldCB2YWx1ZSA9IHN5bTtcblx0cmV0dXJuIHtcblx0XHRyZWFkOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRpZiAodmFsdWUgIT09IHN5bSkgcmV0dXJuIHZhbHVlO1xuXHRcdFx0cHJvbWlzZSA/Pz0gZm4oKS5jYXRjaCgoY2F1c2UpID0+IHtcblx0XHRcdFx0aWYgKGNhdXNlIGluc3RhbmNlb2YgVFJQQ0Vycm9yKSB0aHJvdyBjYXVzZTtcblx0XHRcdFx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVzZS5tZXNzYWdlIDogXCJJbnZhbGlkIGlucHV0XCIsXG5cdFx0XHRcdFx0Y2F1c2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcblx0XHRcdHByb21pc2UgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0sXG5cdFx0cmVzdWx0OiAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHN5bSA/IHZhbHVlIDogdm9pZCAwO1xuXHRcdH1cblx0fTtcbn1cbmNvbnN0IGpzb25Db250ZW50VHlwZUhhbmRsZXIgPSB7XG5cdGlzTWF0Y2gocmVxKSB7XG5cdFx0cmV0dXJuICEhcmVxLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpPy5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0fSxcblx0YXN5bmMgcGFyc2Uob3B0cykge1xuXHRcdGNvbnN0IHsgcmVxIH0gPSBvcHRzO1xuXHRcdGNvbnN0IGlzQmF0Y2hDYWxsID0gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwiYmF0Y2hcIikgPT09IFwiMVwiO1xuXHRcdGNvbnN0IHBhdGhzID0gaXNCYXRjaENhbGwgPyBvcHRzLnBhdGguc3BsaXQoXCIsXCIpIDogW29wdHMucGF0aF07XG5cdFx0Y29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG5cdFx0XHRsZXQgaW5wdXRzID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJlcS5tZXRob2QgPT09IFwiR0VUXCIpIHtcblx0XHRcdFx0Y29uc3QgcXVlcnlJbnB1dCA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldChcImlucHV0XCIpO1xuXHRcdFx0XHRpZiAocXVlcnlJbnB1dCkgaW5wdXRzID0gSlNPTi5wYXJzZShxdWVyeUlucHV0KTtcblx0XHRcdH0gZWxzZSBpbnB1dHMgPSBhd2FpdCByZXEuanNvbigpO1xuXHRcdFx0aWYgKGlucHV0cyA9PT0gdm9pZCAwKSByZXR1cm4ge307XG5cdFx0XHRpZiAoIWlzQmF0Y2hDYWxsKSByZXR1cm4geyAwOiBvcHRzLnJvdXRlci5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIuaW5wdXQuZGVzZXJpYWxpemUoaW5wdXRzKSB9O1xuXHRcdFx0aWYgKCFpc09iamVjdChpbnB1dHMpKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0XHRtZXNzYWdlOiBcIlxcXCJpbnB1dFxcXCIgbmVlZHMgdG8gYmUgYW4gb2JqZWN0IHdoZW4gZG9pbmcgYSBiYXRjaCBjYWxsXCJcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3QgYWNjID0ge307XG5cdFx0XHRmb3IgKGNvbnN0IGluZGV4IG9mIHBhdGhzLmtleXMoKSkge1xuXHRcdFx0XHRjb25zdCBpbnB1dCA9IGlucHV0c1tpbmRleF07XG5cdFx0XHRcdGlmIChpbnB1dCAhPT0gdm9pZCAwKSBhY2NbaW5kZXhdID0gb3B0cy5yb3V0ZXIuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyLmlucHV0LmRlc2VyaWFsaXplKGlucHV0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSk7XG5cdFx0Y29uc3QgY2FsbHMgPSBhd2FpdCBQcm9taXNlLmFsbChwYXRocy5tYXAoYXN5bmMgKHBhdGgsIGluZGV4KSA9PiB7XG5cdFx0XHRjb25zdCBwcm9jZWR1cmUgPSBhd2FpdCBnZXRQcm9jZWR1cmVBdFBhdGgob3B0cy5yb3V0ZXIsIHBhdGgpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0cHJvY2VkdXJlLFxuXHRcdFx0XHRnZXRSYXdJbnB1dDogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0cyA9IGF3YWl0IGdldElucHV0cy5yZWFkKCk7XG5cdFx0XHRcdFx0bGV0IGlucHV0ID0gaW5wdXRzW2luZGV4XTtcblx0XHRcdFx0XHRpZiAocHJvY2VkdXJlPy5fZGVmLnR5cGUgPT09IFwic3Vic2NyaXB0aW9uXCIpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxhc3RFdmVudElkID0gb3B0cy5oZWFkZXJzLmdldChcImxhc3QtZXZlbnQtaWRcIikgPz8gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwibGFzdEV2ZW50SWRcIikgPz8gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwiTGFzdC1FdmVudC1JZFwiKTtcblx0XHRcdFx0XHRcdGlmIChsYXN0RXZlbnRJZCkgaWYgKGlzT2JqZWN0KGlucHV0KSkgaW5wdXQgPSB7XG5cdFx0XHRcdFx0XHRcdC4uLmlucHV0LFxuXHRcdFx0XHRcdFx0XHRsYXN0RXZlbnRJZFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGVsc2UgaW5wdXQgPz89IHsgbGFzdEV2ZW50SWQgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXN1bHQ6ICgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0SW5wdXRzLnJlc3VsdCgpPy5baW5kZXhdO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0pKTtcblx0XHRjb25zdCB0eXBlcyA9IG5ldyBTZXQoY2FsbHMubWFwKChjYWxsKSA9PiBjYWxsLnByb2NlZHVyZT8uX2RlZi50eXBlKS5maWx0ZXIoQm9vbGVhbikpO1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cblx0XHRpZiAodHlwZXMuc2l6ZSA+IDEpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0bWVzc2FnZTogYENhbm5vdCBtaXggcHJvY2VkdXJlIHR5cGVzIGluIGNhbGw6ICR7QXJyYXkuZnJvbSh0eXBlcykuam9pbihcIiwgXCIpfWBcblx0XHR9KTtcblx0XHRjb25zdCB0eXBlID0gdHlwZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlID8/IFwidW5rbm93blwiO1xuXHRcdGNvbnN0IGNvbm5lY3Rpb25QYXJhbXNTdHIgPSBvcHRzLnNlYXJjaFBhcmFtcy5nZXQoXCJjb25uZWN0aW9uUGFyYW1zXCIpO1xuXHRcdGNvbnN0IGluZm8gPSB7XG5cdFx0XHRpc0JhdGNoQ2FsbCxcblx0XHRcdGFjY2VwdDogcmVxLmhlYWRlcnMuZ2V0KFwidHJwYy1hY2NlcHRcIiksXG5cdFx0XHRjYWxscyxcblx0XHRcdHR5cGUsXG5cdFx0XHRjb25uZWN0aW9uUGFyYW1zOiBjb25uZWN0aW9uUGFyYW1zU3RyID09PSBudWxsID8gbnVsbCA6IHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoY29ubmVjdGlvblBhcmFtc1N0ciksXG5cdFx0XHRzaWduYWw6IHJlcS5zaWduYWwsXG5cdFx0XHR1cmw6IG9wdHMudXJsXG5cdFx0fTtcblx0XHRyZXR1cm4gaW5mbztcblx0fVxufTtcbmNvbnN0IGZvcm1EYXRhQ29udGVudFR5cGVIYW5kbGVyID0ge1xuXHRpc01hdGNoKHJlcSkge1xuXHRcdHJldHVybiAhIXJlcS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKT8uc3RhcnRzV2l0aChcIm11bHRpcGFydC9mb3JtLWRhdGFcIik7XG5cdH0sXG5cdGFzeW5jIHBhcnNlKG9wdHMpIHtcblx0XHRjb25zdCB7IHJlcSB9ID0gb3B0cztcblx0XHRpZiAocmVxLm1ldGhvZCAhPT0gXCJQT1NUXCIpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0bWVzc2FnZTogXCJPbmx5IFBPU1QgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZCBmb3IgbXVsdGlwYXJ0L2Zvcm0tZGF0YSByZXF1ZXN0c1wiXG5cdFx0fSk7XG5cdFx0Y29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG5cdFx0XHRjb25zdCBmZCA9IGF3YWl0IHJlcS5mb3JtRGF0YSgpO1xuXHRcdFx0cmV0dXJuIGZkO1xuXHRcdH0pO1xuXHRcdGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgb3B0cy5wYXRoKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWNjZXB0OiBudWxsLFxuXHRcdFx0Y2FsbHM6IFt7XG5cdFx0XHRcdHBhdGg6IG9wdHMucGF0aCxcblx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGdldElucHV0cy5yZWFkLFxuXHRcdFx0XHRyZXN1bHQ6IGdldElucHV0cy5yZXN1bHQsXG5cdFx0XHRcdHByb2NlZHVyZVxuXHRcdFx0fV0sXG5cdFx0XHRpc0JhdGNoQ2FsbDogZmFsc2UsXG5cdFx0XHR0eXBlOiBcIm11dGF0aW9uXCIsXG5cdFx0XHRjb25uZWN0aW9uUGFyYW1zOiBudWxsLFxuXHRcdFx0c2lnbmFsOiByZXEuc2lnbmFsLFxuXHRcdFx0dXJsOiBvcHRzLnVybFxuXHRcdH07XG5cdH1cbn07XG5jb25zdCBvY3RldFN0cmVhbUNvbnRlbnRUeXBlSGFuZGxlciA9IHtcblx0aXNNYXRjaChyZXEpIHtcblx0XHRyZXR1cm4gISFyZXEuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG5cdH0sXG5cdGFzeW5jIHBhcnNlKG9wdHMpIHtcblx0XHRjb25zdCB7IHJlcSB9ID0gb3B0cztcblx0XHRpZiAocmVxLm1ldGhvZCAhPT0gXCJQT1NUXCIpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0bWVzc2FnZTogXCJPbmx5IFBPU1QgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZCBmb3IgYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIHJlcXVlc3RzXCJcblx0XHR9KTtcblx0XHRjb25zdCBnZXRJbnB1dHMgPSBtZW1vKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiByZXEuYm9keTtcblx0XHR9KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2FsbHM6IFt7XG5cdFx0XHRcdHBhdGg6IG9wdHMucGF0aCxcblx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGdldElucHV0cy5yZWFkLFxuXHRcdFx0XHRyZXN1bHQ6IGdldElucHV0cy5yZXN1bHQsXG5cdFx0XHRcdHByb2NlZHVyZTogYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKG9wdHMucm91dGVyLCBvcHRzLnBhdGgpXG5cdFx0XHR9XSxcblx0XHRcdGlzQmF0Y2hDYWxsOiBmYWxzZSxcblx0XHRcdGFjY2VwdDogbnVsbCxcblx0XHRcdHR5cGU6IFwibXV0YXRpb25cIixcblx0XHRcdGNvbm5lY3Rpb25QYXJhbXM6IG51bGwsXG5cdFx0XHRzaWduYWw6IHJlcS5zaWduYWwsXG5cdFx0XHR1cmw6IG9wdHMudXJsXG5cdFx0fTtcblx0fVxufTtcbmNvbnN0IGhhbmRsZXJzID0gW1xuXHRqc29uQ29udGVudFR5cGVIYW5kbGVyLFxuXHRmb3JtRGF0YUNvbnRlbnRUeXBlSGFuZGxlcixcblx0b2N0ZXRTdHJlYW1Db250ZW50VHlwZUhhbmRsZXJcbl07XG5mdW5jdGlvbiBnZXRDb250ZW50VHlwZUhhbmRsZXIocmVxKSB7XG5cdGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVycy5maW5kKChoYW5kbGVyJDEpID0+IGhhbmRsZXIkMS5pc01hdGNoKHJlcSkpO1xuXHRpZiAoaGFuZGxlcikgcmV0dXJuIGhhbmRsZXI7XG5cdGlmICghaGFuZGxlciAmJiByZXEubWV0aG9kID09PSBcIkdFVFwiKSByZXR1cm4ganNvbkNvbnRlbnRUeXBlSGFuZGxlcjtcblx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0Y29kZTogXCJVTlNVUFBPUlRFRF9NRURJQV9UWVBFXCIsXG5cdFx0bWVzc2FnZTogcmVxLmhlYWRlcnMuaGFzKFwiY29udGVudC10eXBlXCIpID8gYFVuc3VwcG9ydGVkIGNvbnRlbnQtdHlwZSBcIiR7cmVxLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpfWAgOiBcIk1pc3NpbmcgY29udGVudC10eXBlIGhlYWRlclwiXG5cdH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVxdWVzdEluZm8ob3B0cykge1xuXHRjb25zdCBoYW5kbGVyID0gZ2V0Q29udGVudFR5cGVIYW5kbGVyKG9wdHMucmVxKTtcblx0cmV0dXJuIGF3YWl0IGhhbmRsZXIucGFyc2Uob3B0cyk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9hYm9ydEVycm9yLnRzXG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyb3IpIHtcblx0cmV0dXJuIGlzT2JqZWN0KGVycm9yKSAmJiBlcnJvcltcIm5hbWVcIl0gPT09IFwiQWJvcnRFcnJvclwiO1xufVxuZnVuY3Rpb24gdGhyb3dBYm9ydEVycm9yKG1lc3NhZ2UgPSBcIkFib3J0RXJyb3JcIikge1xuXHR0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKG1lc3NhZ2UsIFwiQWJvcnRFcnJvclwiKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3ZlbmRvci91bnByb21pc2UvdW5wcm9taXNlLnRzXG4vKiogTWVtb3J5IHNhZmUgKHdlYWttYXBwZWQpIGNhY2hlIG9mIHRoZSBQcm94eVByb21pc2UgZm9yIGVhY2ggUHJvbWlzZSxcbiogd2hpY2ggaXMgcmV0YWluZWQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgb3JpZ2luYWwgUHJvbWlzZS5cbiovXG5jb25zdCBzdWJzY3JpYmFibGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuLyoqIEEgTk9PUCBmdW5jdGlvbiBhbGxvd2luZyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIGZvciBzZXR0bGVkXG4qIFN1YnNjcmliZWRQcm9taXNlcyAoc2V0dGxlZCBwcm9taXNlcyBhcmUgbm90IHN1YnNjcmliZWQgLSB0aGV5IHJlc29sdmVcbiogaW1tZWRpYXRlbHkpLiAqL1xuY29uc3QgTk9PUCA9ICgpID0+IHt9O1xuLyoqXG4qIEV2ZXJ5IGBQcm9taXNlPFQ+YCBjYW4gYmUgc2hhZG93ZWQgYnkgYSBzaW5nbGUgYFByb3h5UHJvbWlzZTxUPmAuIEl0IGlzXG4qIGNyZWF0ZWQgb25jZSwgY2FjaGVkIGFuZCByZXVzZWQgdGhyb3VnaG91dCB0aGUgbGlmZXRpbWUgb2YgdGhlIFByb21pc2UuIEdldCBhXG4qIFByb21pc2UncyBQcm94eVByb21pc2UgdXNpbmcgYFVucHJvbWlzZS5wcm94eShwcm9taXNlKWAuXG4qXG4qIFRoZSBgUHJveHlQcm9taXNlPFQ+YCBhdHRhY2hlcyBoYW5kbGVycyB0byB0aGUgb3JpZ2luYWwgYFByb21pc2U8VD5gXG4qIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYCBqdXN0IG9uY2UuIFByb21pc2VzIGRlcml2ZWQgZnJvbSBpdCB1c2UgYVxuKiBzdWJzY3JpcHRpb24tIChhbmQgdW5zdWJzY3JpcHRpb24tKSBiYXNlZCBtZWNoYW5pc20gdGhhdCBtb25pdG9ycyB0aGVzZVxuKiBoYW5kbGVycy5cbipcbiogRXZlcnkgdGltZSB5b3UgY2FsbCBgLnN1YnNjcmliZSgpYCwgYC50aGVuKClgIGAuY2F0Y2goKWAgb3IgYC5maW5hbGx5KClgIG9uIGFcbiogYFByb3h5UHJvbWlzZTxUPmAgaXQgcmV0dXJucyBhIGBTdWJzY3JpYmVkUHJvbWlzZTxUPmAgaGF2aW5nIGFuIGFkZGl0aW9uYWxcbiogYHVuc3Vic2NyaWJlKClgIG1ldGhvZC4gQ2FsbGluZyBgdW5zdWJzY3JpYmUoKWAgZGV0YWNoZXMgcmVmZXJlbmNlIGNoYWluc1xuKiBmcm9tIHRoZSBvcmlnaW5hbCwgcG90ZW50aWFsbHkgbG9uZy1saXZlZCBQcm9taXNlLCBlbGltaW5hdGluZyBtZW1vcnkgbGVha3MuXG4qXG4qIFRoaXMgYXBwcm9hY2ggY2FuIGVsaW1pbmF0ZSB0aGUgbWVtb3J5IGxlYWtzIHRoYXQgb3RoZXJ3aXNlIGNvbWUgYWJvdXQgZnJvbVxuKiByZXBlYXRlZCBgcmFjZSgpYCBvciBgYW55KClgIGNhbGxzIGludm9raW5nIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYCBtdWx0aXBsZVxuKiB0aW1lcyBvbiB0aGUgc2FtZSBsb25nLWxpdmVkIG5hdGl2ZSBQcm9taXNlIChzdWJzY3JpcHRpb25zIHdoaWNoIGNhbiBuZXZlciBiZVxuKiBjbGVhbmVkIHVwKS5cbipcbiogYFVucHJvbWlzZS5yYWNlKHByb21pc2VzKWAgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgYFByb21pc2UucmFjZWBcbiogYXZvaWRpbmcgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgbG9uZy1saXZlZCB1bnNldHRsZWQgUHJvbWlzZXMuXG4qXG4qIGBVbnByb21pc2UuYW55KHByb21pc2VzKWAgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgYFByb21pc2UuYW55YFxuKiBhdm9pZGluZyBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyBsb25nLWxpdmVkIHVuc2V0dGxlZCBQcm9taXNlcy5cbipcbiogYFVucHJvbWlzZS5yZXNvbHZlKHByb21pc2UpYCByZXR1cm5zIGFuIGVwaGVtZXJhbCBgU3Vic2NyaWJlZFByb21pc2U8VD5gIGZvclxuKiBhbnkgZ2l2ZW4gYFByb21pc2U8VD5gIGZhY2lsaXRhdGluZyBhcmJpdHJhcnkgYXN5bmMvYXdhaXQgcGF0dGVybnMuIEJlaGluZFxuKiB0aGUgc2NlbmVzLCBgcmVzb2x2ZWAgaXMgaW1wbGVtZW50ZWQgc2ltcGx5IGFzXG4qIGBVbnByb21pc2UucHJveHkocHJvbWlzZSkuc3Vic2NyaWJlKClgLiBEb24ndCBmb3JnZXQgdG8gY2FsbCBgLnVuc3Vic2NyaWJlKClgXG4qIHRvIHRpZHkgdXAhXG4qXG4qL1xudmFyIFVucHJvbWlzZSA9IGNsYXNzIFVucHJvbWlzZSB7XG5cdC8qKiBJTlNUQU5DRSBJTVBMRU1FTlRBVElPTiAqL1xuXHQvKiogVGhlIHByb21pc2Ugc2hhZG93ZWQgYnkgdGhpcyBVbnByb21pc2U8VD4gICovXG5cdHByb21pc2U7XG5cdC8qKiBQcm9taXNlcyBleHBlY3RpbmcgZXZlbnR1YWwgc2V0dGxlbWVudCAodW5sZXNzIHVuc3Vic2NyaWJlZCBmaXJzdCkuIFRoaXMgbGlzdCBpcyBkZWxldGVkXG5cdCogYWZ0ZXIgdGhlIG9yaWdpbmFsIHByb21pc2Ugc2V0dGxlcyAtIG5vIGZ1cnRoZXIgbm90aWZpY2F0aW9ucyB3aWxsIGJlIGlzc3VlZC4gKi9cblx0c3Vic2NyaWJlcnMgPSBbXTtcblx0LyoqIFRoZSBQcm9taXNlJ3Mgc2V0dGxlbWVudCAocmVjb3JkZWQgd2hlbiBpdCBmdWxmaWxzIG9yIHJlamVjdHMpLiBUaGlzIGlzIGNvbnN1bHRlZCB3aGVuXG5cdCogY2FsbGluZyAuc3Vic2NyaWJlKCkgLnRoZW4oKSAuY2F0Y2goKSAuZmluYWxseSgpIHRvIHNlZSBpZiBhbiBpbW1lZGlhdGVseS1yZXNvbHZpbmcgUHJvbWlzZVxuXHQqIGNhbiBiZSByZXR1cm5lZCwgYW5kIHRoZXJlZm9yZSBzdWJzY3JpcHRpb24gY2FuIGJlIGJ5cGFzc2VkLiAqL1xuXHRzZXR0bGVtZW50ID0gbnVsbDtcblx0Y29uc3RydWN0b3IoYXJnKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoYXJnKTtcblx0XHRlbHNlIHRoaXMucHJvbWlzZSA9IGFyZztcblx0XHRjb25zdCB0aGVuUmV0dXJuID0gdGhpcy5wcm9taXNlLnRoZW4oKHZhbHVlKSA9PiB7XG5cdFx0XHRjb25zdCB7IHN1YnNjcmliZXJzIH0gPSB0aGlzO1xuXHRcdFx0dGhpcy5zdWJzY3JpYmVycyA9IG51bGw7XG5cdFx0XHR0aGlzLnNldHRsZW1lbnQgPSB7XG5cdFx0XHRcdHN0YXR1czogXCJmdWxmaWxsZWRcIixcblx0XHRcdFx0dmFsdWVcblx0XHRcdH07XG5cdFx0XHRzdWJzY3JpYmVycz8uZm9yRWFjaCgoeyByZXNvbHZlIH0pID0+IHtcblx0XHRcdFx0cmVzb2x2ZSh2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRpZiAoXCJjYXRjaFwiIGluIHRoZW5SZXR1cm4pIHRoZW5SZXR1cm4uY2F0Y2goKHJlYXNvbikgPT4ge1xuXHRcdFx0Y29uc3QgeyBzdWJzY3JpYmVycyB9ID0gdGhpcztcblx0XHRcdHRoaXMuc3Vic2NyaWJlcnMgPSBudWxsO1xuXHRcdFx0dGhpcy5zZXR0bGVtZW50ID0ge1xuXHRcdFx0XHRzdGF0dXM6IFwicmVqZWN0ZWRcIixcblx0XHRcdFx0cmVhc29uXG5cdFx0XHR9O1xuXHRcdFx0c3Vic2NyaWJlcnM/LmZvckVhY2goKHsgcmVqZWN0IH0pID0+IHtcblx0XHRcdFx0cmVqZWN0KHJlYXNvbik7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXHQvKiogQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IG1pdGlnYXRlcyB1bmNvbnRyb2xsZWQgc3Vic2NyaXB0aW9uIHRvIGEgbG9uZy1saXZlZFxuXHQqIFByb21pc2UgdmlhIC50aGVuKCkgYW5kIC5jYXRjaCgpIC0gb3RoZXJ3aXNlIGEgc291cmNlIG9mIG1lbW9yeSBsZWFrcy5cblx0KlxuXHQqIFRoZSByZXR1cm5lZCBwcm9taXNlIGhhcyBhbiBgdW5zdWJzY3JpYmUoKWAgbWV0aG9kIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2hlblxuXHQqIHRoZSBQcm9taXNlIGlzIG5vIGxvbmdlciBiZWluZyB0cmFja2VkIGJ5IGFwcGxpY2F0aW9uIGxvZ2ljLCBhbmQgd2hpY2hcblx0KiBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm8gcmVmZXJlbmNlIGNoYWluIGZyb20gdGhlIG9yaWdpbmFsIHByb21pc2UgdG8gdGhlXG5cdCogbmV3IG9uZSwgYW5kIHRoZXJlZm9yZSBubyBtZW1vcnkgbGVhay5cblx0KlxuXHQqIElmIG9yaWdpbmFsIHByb21pc2UgaGFzIG5vdCB5ZXQgc2V0dGxlZCwgdGhpcyBhZGRzIGEgbmV3IHVuaXF1ZSBwcm9taXNlXG5cdCogdGhhdCBsaXN0ZW5zIHRvIHRoZW4vY2F0Y2ggZXZlbnRzLCBhbG9uZyB3aXRoIGFuIGB1bnN1YnNjcmliZSgpYCBtZXRob2QgdG9cblx0KiBkZXRhY2ggaXQuXG5cdCpcblx0KiBJZiBvcmlnaW5hbCBwcm9taXNlIGhhcyBzZXR0bGVkLCB0aGVuIGNyZWF0ZXMgYSBuZXcgUHJvbWlzZS5yZXNvbHZlKCkgb3Jcblx0KiBQcm9taXNlLnJlamVjdCgpIGFuZCBwcm92aWRlZCB1bnN1YnNjcmliZSBpcyBhIG5vb3AuXG5cdCpcblx0KiBJZiB5b3UgY2FsbCBgdW5zdWJzY3JpYmUoKWAgYmVmb3JlIHRoZSByZXR1cm5lZCBQcm9taXNlIGhhcyBzZXR0bGVkLCBpdFxuXHQqIHdpbGwgbmV2ZXIgc2V0dGxlLlxuXHQqL1xuXHRzdWJzY3JpYmUoKSB7XG5cdFx0bGV0IHByb21pc2U7XG5cdFx0bGV0IHVuc3Vic2NyaWJlO1xuXHRcdGNvbnN0IHsgc2V0dGxlbWVudCB9ID0gdGhpcztcblx0XHRpZiAoc2V0dGxlbWVudCA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKHRoaXMuc3Vic2NyaWJlcnMgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIlVucHJvbWlzZSBzZXR0bGVkIGJ1dCBzdGlsbCBoYXMgc3Vic2NyaWJlcnNcIik7XG5cdFx0XHRjb25zdCBzdWJzY3JpYmVyID0gd2l0aFJlc29sdmVycygpO1xuXHRcdFx0dGhpcy5zdWJzY3JpYmVycyA9IGxpc3RXaXRoTWVtYmVyKHRoaXMuc3Vic2NyaWJlcnMsIHN1YnNjcmliZXIpO1xuXHRcdFx0cHJvbWlzZSA9IHN1YnNjcmliZXIucHJvbWlzZTtcblx0XHRcdHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuXHRcdFx0XHRpZiAodGhpcy5zdWJzY3JpYmVycyAhPT0gbnVsbCkgdGhpcy5zdWJzY3JpYmVycyA9IGxpc3RXaXRob3V0TWVtYmVyKHRoaXMuc3Vic2NyaWJlcnMsIHN1YnNjcmliZXIpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgeyBzdGF0dXMgfSA9IHNldHRsZW1lbnQ7XG5cdFx0XHRpZiAoc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHNldHRsZW1lbnQudmFsdWUpO1xuXHRcdFx0ZWxzZSBwcm9taXNlID0gUHJvbWlzZS5yZWplY3Qoc2V0dGxlbWVudC5yZWFzb24pO1xuXHRcdFx0dW5zdWJzY3JpYmUgPSBOT09QO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7IHVuc3Vic2NyaWJlIH0pO1xuXHR9XG5cdC8qKiBTVEFOREFSRCBQUk9NSVNFIE1FVEhPRFMgKGJ1dCByZXR1cm5pbmcgYSBTdWJzY3JpYmVkUHJvbWlzZSkgKi9cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLnN1YnNjcmliZSgpO1xuXHRcdGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IHN1YnNjcmliZWQ7XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oc3Vic2NyaWJlZC50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSwgeyB1bnN1YnNjcmliZSB9KTtcblx0fVxuXHRjYXRjaChvbnJlamVjdGVkKSB7XG5cdFx0Y29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG5cdFx0Y29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLmNhdGNoKG9ucmVqZWN0ZWQpLCB7IHVuc3Vic2NyaWJlIH0pO1xuXHR9XG5cdGZpbmFsbHkob25maW5hbGx5KSB7XG5cdFx0Y29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG5cdFx0Y29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLmZpbmFsbHkob25maW5hbGx5KSwgeyB1bnN1YnNjcmliZSB9KTtcblx0fVxuXHQvKiogVE9TVFJJTkcgU1VQUE9SVCAqL1xuXHRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9IFwiVW5wcm9taXNlXCI7XG5cdC8qKiBVbnByb21pc2UgU1RBVElDIE1FVEhPRFMgKi9cblx0LyoqIENyZWF0ZSBvciBSZXRyaWV2ZSB0aGUgcHJveHkgVW5wcm9taXNlIChhIHJlLXVzZWQgVW5wcm9taXNlIGZvciB0aGUgVk0gbGlmZXRpbWVcblx0KiBvZiB0aGUgcHJvdmlkZWQgUHJvbWlzZSByZWZlcmVuY2UpICovXG5cdHN0YXRpYyBwcm94eShwcm9taXNlKSB7XG5cdFx0Y29uc3QgY2FjaGVkID0gVW5wcm9taXNlLmdldFN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSk7XG5cdFx0cmV0dXJuIHR5cGVvZiBjYWNoZWQgIT09IFwidW5kZWZpbmVkXCIgPyBjYWNoZWQgOiBVbnByb21pc2UuY3JlYXRlU3Vic2NyaWJhYmxlUHJvbWlzZShwcm9taXNlKTtcblx0fVxuXHQvKiogQ3JlYXRlIGFuZCBzdG9yZSBhbiBVbnByb21pc2Uga2V5ZWQgYnkgYW4gb3JpZ2luYWwgUHJvbWlzZS4gKi9cblx0c3RhdGljIGNyZWF0ZVN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSkge1xuXHRcdGNvbnN0IGNyZWF0ZWQgPSBuZXcgVW5wcm9taXNlKHByb21pc2UpO1xuXHRcdHN1YnNjcmliYWJsZUNhY2hlLnNldChwcm9taXNlLCBjcmVhdGVkKTtcblx0XHRzdWJzY3JpYmFibGVDYWNoZS5zZXQoY3JlYXRlZCwgY3JlYXRlZCk7XG5cdFx0cmV0dXJuIGNyZWF0ZWQ7XG5cdH1cblx0LyoqIFJldHJpZXZlIGEgcHJldmlvdXNseS1jcmVhdGVkIFVucHJvbWlzZSBrZXllZCBieSBhbiBvcmlnaW5hbCBQcm9taXNlLiAqL1xuXHRzdGF0aWMgZ2V0U3Vic2NyaWJhYmxlUHJvbWlzZShwcm9taXNlKSB7XG5cdFx0cmV0dXJuIHN1YnNjcmliYWJsZUNhY2hlLmdldChwcm9taXNlKTtcblx0fVxuXHQvKiogUHJvbWlzZSBTVEFUSUMgTUVUSE9EUyAqL1xuXHQvKiogTG9va3VwIHRoZSBVbnByb21pc2UgZm9yIHRoaXMgcHJvbWlzZSwgYW5kIGRlcml2ZSBhIFN1YnNjcmliZWRQcm9taXNlIGZyb21cblx0KiBpdCAodGhhdCBjYW4gYmUgbGF0ZXIgdW5zdWJzY3JpYmVkIHRvIGVsaW1pbmF0ZSBNZW1vcnkgbGVha3MpICovXG5cdHN0YXRpYyByZXNvbHZlKHZhbHVlKSB7XG5cdFx0Y29uc3QgcHJvbWlzZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcInRoZW5cIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuXHRcdHJldHVybiBVbnByb21pc2UucHJveHkocHJvbWlzZSkuc3Vic2NyaWJlKCk7XG5cdH1cblx0c3RhdGljIGFzeW5jIGFueSh2YWx1ZXMpIHtcblx0XHRjb25zdCB2YWx1ZXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFsuLi52YWx1ZXNdO1xuXHRcdGNvbnN0IHN1YnNjcmliZWRQcm9taXNlcyA9IHZhbHVlc0FycmF5Lm1hcChVbnByb21pc2UucmVzb2x2ZSk7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBhd2FpdCBQcm9taXNlLmFueShzdWJzY3JpYmVkUHJvbWlzZXMpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzdWJzY3JpYmVkUHJvbWlzZXMuZm9yRWFjaCgoeyB1bnN1YnNjcmliZSB9KSA9PiB7XG5cdFx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0c3RhdGljIGFzeW5jIHJhY2UodmFsdWVzKSB7XG5cdFx0Y29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbLi4udmFsdWVzXTtcblx0XHRjb25zdCBzdWJzY3JpYmVkUHJvbWlzZXMgPSB2YWx1ZXNBcnJheS5tYXAoVW5wcm9taXNlLnJlc29sdmUpO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKHN1YnNjcmliZWRQcm9taXNlcyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHN1YnNjcmliZWRQcm9taXNlcy5mb3JFYWNoKCh7IHVuc3Vic2NyaWJlIH0pID0+IHtcblx0XHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHQvKiogQ3JlYXRlIGEgcmFjZSBvZiBTdWJzY3JpYmVkUHJvbWlzZXMgdGhhdCB3aWxsIGZ1bGZpbCB0byBhIHNpbmdsZSB3aW5uaW5nXG5cdCogUHJvbWlzZSAoaW4gYSAxLVR1cGxlKS4gRWxpbWluYXRlcyBtZW1vcnkgbGVha3MgZnJvbSBsb25nLWxpdmVkIHByb21pc2VzXG5cdCogYWNjdW11bGF0aW5nIC50aGVuKCkgYW5kIC5jYXRjaCgpIHN1YnNjcmliZXJzLiBBbGxvd3Mgc2ltcGxlIGxvZ2ljIHRvXG5cdCogY29uc3VtZSB0aGUgcmVzdWx0LCBsaWtlLi4uXG5cdCogYGBgdHNcblx0KiBjb25zdCBbIHdpbm5lciBdID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoWyBwcm9taXNlQSwgcHJvbWlzZUIgXSk7XG5cdCogaWYod2lubmVyID09PSBwcm9taXNlQil7XG5cdCogICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlQjtcblx0KiAgIC8vIGRvIHRoZSB0aGluZ1xuXHQqIH1cblx0KiBgYGBcblx0KiAqL1xuXHRzdGF0aWMgYXN5bmMgcmFjZVJlZmVyZW5jZXMocHJvbWlzZXMpIHtcblx0XHRjb25zdCBzZWxmUHJvbWlzZXMgPSBwcm9taXNlcy5tYXAocmVzb2x2ZVNlbGZUdXBsZSk7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2Uoc2VsZlByb21pc2VzKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0Zm9yIChjb25zdCBwcm9taXNlIG9mIHNlbGZQcm9taXNlcykgcHJvbWlzZS51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0fVxufTtcbi8qKiBQcm9taXNlcyBhIDEtdHVwbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgcHJvbWlzZSB3aGVuIGl0IHJlc29sdmVzLiBBbGxvd3NcbiogYXdhaXRpbmcgdGhlIGV2ZW50dWFsIFByb21pc2UgKioqcmVmZXJlbmNlKioqIChlYXN5IHRvIGRlc3RydWN0dXJlIGFuZFxuKiBleGFjdGx5IGNvbXBhcmUgd2l0aCA9PT0pLiBBdm9pZHMgcmVzb2x2aW5nIHRvIHRoZSBQcm9taXNlICoqKnZhbHVlKioqICh3aGljaFxuKiBtYXkgYmUgYW1iaWd1b3VzIGFuZCB0aGVyZWZvcmUgaGFyZCB0byBpZGVudGlmeSBhcyB0aGUgd2lubmVyIG9mIGEgcmFjZSkuXG4qIFlvdSBjYW4gY2FsbCB1bnN1YnNjcmliZSBvbiB0aGUgUHJvbWlzZSB0byBtaXRpZ2F0ZSBtZW1vcnkgbGVha3MuXG4qICovXG5mdW5jdGlvbiByZXNvbHZlU2VsZlR1cGxlKHByb21pc2UpIHtcblx0cmV0dXJuIFVucHJvbWlzZS5wcm94eShwcm9taXNlKS50aGVuKCgpID0+IFtwcm9taXNlXSk7XG59XG4vKiogVkVORE9SRUQgKEZ1dHVyZSkgUFJPTUlTRSBVVElMSVRJRVMgKi9cbi8qKiBSZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS13aXRoLXJlc29sdmVycyAqL1xuZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcblx0bGV0IHJlc29sdmU7XG5cdGxldCByZWplY3Q7XG5cdGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcblx0XHRyZXNvbHZlID0gX3Jlc29sdmU7XG5cdFx0cmVqZWN0ID0gX3JlamVjdDtcblx0fSk7XG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZSxcblx0XHRyZXNvbHZlLFxuXHRcdHJlamVjdFxuXHR9O1xufVxuLyoqIElNTVVUQUJMRSBMSVNUIE9QRVJBVElPTlMgKi9cbmZ1bmN0aW9uIGxpc3RXaXRoTWVtYmVyKGFyciwgbWVtYmVyKSB7XG5cdHJldHVybiBbLi4uYXJyLCBtZW1iZXJdO1xufVxuZnVuY3Rpb24gbGlzdFdpdGhvdXRJbmRleChhcnIsIGluZGV4KSB7XG5cdHJldHVybiBbLi4uYXJyLnNsaWNlKDAsIGluZGV4KSwgLi4uYXJyLnNsaWNlKGluZGV4ICsgMSldO1xufVxuZnVuY3Rpb24gbGlzdFdpdGhvdXRNZW1iZXIoYXJyLCBtZW1iZXIpIHtcblx0Y29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihtZW1iZXIpO1xuXHRpZiAoaW5kZXggIT09IC0xKSByZXR1cm4gbGlzdFdpdGhvdXRJbmRleChhcnIsIGluZGV4KTtcblx0cmV0dXJuIGFycjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdXRpbHMvZGlzcG9zYWJsZS50c1xuU3ltYm9sLmRpc3Bvc2UgPz89IFN5bWJvbCgpO1xuU3ltYm9sLmFzeW5jRGlzcG9zZSA/Pz0gU3ltYm9sKCk7XG4vKipcbiogVGFrZXMgYSB2YWx1ZSBhbmQgYSBkaXNwb3NlIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG9iamVjdCB0aGF0IGltcGxlbWVudHMgdGhlIERpc3Bvc2FibGUgaW50ZXJmYWNlLlxuKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIHRoZSBvcmlnaW5hbCB2YWx1ZSBhdWdtZW50ZWQgd2l0aCBhIFN5bWJvbC5kaXNwb3NlIG1ldGhvZC5cbiogQHBhcmFtIHRoaW5nIFRoZSB2YWx1ZSB0byBtYWtlIGRpc3Bvc2FibGVcbiogQHBhcmFtIGRpc3Bvc2UgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRpc3Bvc2luZyB0aGUgcmVzb3VyY2VcbiogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmRpc3Bvc2UgbWV0aG9kIGFkZGVkXG4qL1xuZnVuY3Rpb24gbWFrZVJlc291cmNlKHRoaW5nLCBkaXNwb3NlKSB7XG5cdGNvbnN0IGl0ID0gdGhpbmc7XG5cdGNvbnN0IGV4aXN0aW5nID0gaXRbU3ltYm9sLmRpc3Bvc2VdO1xuXHRpdFtTeW1ib2wuZGlzcG9zZV0gPSAoKSA9PiB7XG5cdFx0ZGlzcG9zZSgpO1xuXHRcdGV4aXN0aW5nPy4oKTtcblx0fTtcblx0cmV0dXJuIGl0O1xufVxuLyoqXG4qIFRha2VzIGEgdmFsdWUgYW5kIGFuIGFzeW5jIGRpc3Bvc2UgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgQXN5bmNEaXNwb3NhYmxlIGludGVyZmFjZS5cbiogVGhlIHJldHVybmVkIG9iamVjdCBpcyB0aGUgb3JpZ2luYWwgdmFsdWUgYXVnbWVudGVkIHdpdGggYSBTeW1ib2wuYXN5bmNEaXNwb3NlIG1ldGhvZC5cbiogQHBhcmFtIHRoaW5nIFRoZSB2YWx1ZSB0byBtYWtlIGFzeW5jIGRpc3Bvc2FibGVcbiogQHBhcmFtIGRpc3Bvc2UgQXN5bmMgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRpc3Bvc2luZyB0aGUgcmVzb3VyY2VcbiogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmFzeW5jRGlzcG9zZSBtZXRob2QgYWRkZWRcbiovXG5mdW5jdGlvbiBtYWtlQXN5bmNSZXNvdXJjZSh0aGluZywgZGlzcG9zZSkge1xuXHRjb25zdCBpdCA9IHRoaW5nO1xuXHRjb25zdCBleGlzdGluZyA9IGl0W1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuXHRpdFtTeW1ib2wuYXN5bmNEaXNwb3NlXSA9IGFzeW5jICgpID0+IHtcblx0XHRhd2FpdCBkaXNwb3NlKCk7XG5cdFx0YXdhaXQgZXhpc3Rpbmc/LigpO1xuXHR9O1xuXHRyZXR1cm4gaXQ7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL3RpbWVyUmVzb3VyY2UudHNcbmNvbnN0IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIHRpbWVyUmVzb3VyY2UobXMpIHtcblx0bGV0IHRpbWVyID0gbnVsbDtcblx0cmV0dXJuIG1ha2VSZXNvdXJjZSh7IHN0YXJ0KCkge1xuXHRcdGlmICh0aW1lcikgdGhyb3cgbmV3IEVycm9yKFwiVGltZXIgYWxyZWFkeSBzdGFydGVkXCIpO1xuXHRcdGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCksIG1zKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fSB9LCAoKSA9PiB7XG5cdFx0aWYgKHRpbWVyKSBjbGVhclRpbWVvdXQodGltZXIpO1xuXHR9KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdXNpbmdDdHguanNcbnZhciByZXF1aXJlX3VzaW5nQ3R4ID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdXNpbmdDdHguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcblx0ZnVuY3Rpb24gX3VzaW5nQ3R4KCkge1xuXHRcdHZhciByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbihyJDEsIGUkMSkge1xuXHRcdFx0dmFyIG4kMSA9IEVycm9yKCk7XG5cdFx0XHRyZXR1cm4gbiQxLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBuJDEuZXJyb3IgPSByJDEsIG4kMS5zdXBwcmVzc2VkID0gZSQxLCBuJDE7XG5cdFx0fSwgZSA9IHt9LCBuID0gW107XG5cdFx0ZnVuY3Rpb24gdXNpbmcociQxLCBlJDEpIHtcblx0XHRcdGlmIChudWxsICE9IGUkMSkge1xuXHRcdFx0XHRpZiAoT2JqZWN0KGUkMSkgIT09IGUkMSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVzaW5nIGRlY2xhcmF0aW9ucyBjYW4gb25seSBiZSB1c2VkIHdpdGggb2JqZWN0cywgZnVuY3Rpb25zLCBudWxsLCBvciB1bmRlZmluZWQuXCIpO1xuXHRcdFx0XHRpZiAociQxKSB2YXIgbyA9IGUkMVtTeW1ib2wuYXN5bmNEaXNwb3NlIHx8IFN5bWJvbFtcImZvclwiXShcIlN5bWJvbC5hc3luY0Rpc3Bvc2VcIildO1xuXHRcdFx0XHRpZiAodm9pZCAwID09PSBvICYmIChvID0gZSQxW1N5bWJvbC5kaXNwb3NlIHx8IFN5bWJvbFtcImZvclwiXShcIlN5bWJvbC5kaXNwb3NlXCIpXSwgciQxKSkgdmFyIHQgPSBvO1xuXHRcdFx0XHRpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBkaXNwb3NhYmxlLlwiKTtcblx0XHRcdFx0dCAmJiAobyA9IGZ1bmN0aW9uIG8kMSgpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dC5jYWxsKGUkMSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAociQyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QociQyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pLCBuLnB1c2goe1xuXHRcdFx0XHRcdHY6IGUkMSxcblx0XHRcdFx0XHRkOiBvLFxuXHRcdFx0XHRcdGE6IHIkMVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSByJDEgJiYgbi5wdXNoKHtcblx0XHRcdFx0ZDogZSQxLFxuXHRcdFx0XHRhOiByJDFcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGUkMTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGUsXG5cdFx0XHR1OiB1c2luZy5iaW5kKG51bGwsICExKSxcblx0XHRcdGE6IHVzaW5nLmJpbmQobnVsbCwgITApLFxuXHRcdFx0ZDogZnVuY3Rpb24gZCgpIHtcblx0XHRcdFx0dmFyIG8sIHQgPSB0aGlzLmUsIHMgPSAwO1xuXHRcdFx0XHRmdW5jdGlvbiBuZXh0KCkge1xuXHRcdFx0XHRcdGZvciAoOyBvID0gbi5wb3AoKTspIHRyeSB7XG5cdFx0XHRcdFx0XHRpZiAoIW8uYSAmJiAxID09PSBzKSByZXR1cm4gcyA9IDAsIG4ucHVzaChvKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihuZXh0KTtcblx0XHRcdFx0XHRcdGlmIChvLmQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHIkMSA9IG8uZC5jYWxsKG8udik7XG5cdFx0XHRcdFx0XHRcdGlmIChvLmEpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyJDEpLnRoZW4obmV4dCwgZXJyKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBzIHw9IDE7XG5cdFx0XHRcdFx0fSBjYXRjaCAociQyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyKHIkMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgxID09PSBzKSByZXR1cm4gdCAhPT0gZSA/IFByb21pc2UucmVqZWN0KHQpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdFx0aWYgKHQgIT09IGUpIHRocm93IHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gZXJyKG4kMSkge1xuXHRcdFx0XHRcdHJldHVybiB0ID0gdCAhPT0gZSA/IG5ldyByKG4kMSwgdCkgOiBuJDEsIG5leHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbmV4dCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBfdXNpbmdDdHgsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2FzeW5jSXRlcmFibGUudHNcbnZhciBpbXBvcnRfdXNpbmdDdHgkNCA9IF9fdG9FU00ocmVxdWlyZV91c2luZ0N0eCgpLCAxKTtcbmZ1bmN0aW9uIGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUpIHtcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblx0aWYgKGl0ZXJhdG9yW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKSByZXR1cm4gaXRlcmF0b3I7XG5cdHJldHVybiBtYWtlQXN5bmNSZXNvdXJjZShpdGVyYXRvciwgYXN5bmMgKCkgPT4ge1xuXHRcdGF3YWl0IGl0ZXJhdG9yLnJldHVybj8uKCk7XG5cdH0pO1xufVxuLyoqXG4qIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvbiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IGF1dG9tYXRpY2FsbHkgYWJvcnRzIGFmdGVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4qL1xuYXN5bmMgZnVuY3Rpb24qIHdpdGhNYXhEdXJhdGlvbihpdGVyYWJsZSwgb3B0cykge1xuXHR0cnkge1xuXHRcdHZhciBfdXNpbmdDdHgkMSA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkNC5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4JDEuYShpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKSk7XG5cdFx0Y29uc3QgdGltZXIgPSBfdXNpbmdDdHgkMS51KHRpbWVyUmVzb3VyY2Uob3B0cy5tYXhEdXJhdGlvbk1zKSk7XG5cdFx0Y29uc3QgdGltZXJQcm9taXNlID0gdGltZXIuc3RhcnQoKTtcblx0XHRsZXQgcmVzdWx0O1xuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRyZXN1bHQgPSBhd2FpdCBVbnByb21pc2UucmFjZShbaXRlcmF0b3IubmV4dCgpLCB0aW1lclByb21pc2VdKTtcblx0XHRcdGlmIChyZXN1bHQgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHRocm93QWJvcnRFcnJvcigpO1xuXHRcdFx0aWYgKHJlc3VsdC5kb25lKSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0cmVzdWx0ID0gbnVsbDtcblx0XHR9XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0fSBmaW5hbGx5IHtcblx0XHRhd2FpdCBfdXNpbmdDdHgkMS5kKCk7XG5cdH1cbn1cbi8qKlxuKiBEZXJpdmVzIGEgbmV3IHtAbGluayBBc3luY0dlbmVyYXRvcn0gYmFzZWQgb2Yge0BsaW5rIGl0ZXJhYmxlfSwgdGhhdCB5aWVsZHMgaXRzIGZpcnN0XG4qIHtAbGluayBjb3VudH0gdmFsdWVzLiBUaGVuLCBhIGdyYWNlIHBlcmlvZCBvZiB7QGxpbmsgZ3JhY2VQZXJpb2RNc30gaXMgc3RhcnRlZCBpbiB3aGljaCBmdXJ0aGVyXG4qIHZhbHVlcyBtYXkgc3RpbGwgY29tZSB0aHJvdWdoLiBBZnRlciB0aGlzIHBlcmlvZCwgdGhlIGdlbmVyYXRvciBhYm9ydHMuXG4qL1xuYXN5bmMgZnVuY3Rpb24qIHRha2VXaXRoR3JhY2UoaXRlcmFibGUsIG9wdHMpIHtcblx0dHJ5IHtcblx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkNC5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4My5hKGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUpKTtcblx0XHRsZXQgcmVzdWx0O1xuXHRcdGNvbnN0IHRpbWVyID0gX3VzaW5nQ3R4My51KHRpbWVyUmVzb3VyY2Uob3B0cy5ncmFjZVBlcmlvZE1zKSk7XG5cdFx0bGV0IGNvdW50ID0gb3B0cy5jb3VudDtcblx0XHRsZXQgdGltZXJQcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge30pO1xuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRyZXN1bHQgPSBhd2FpdCBVbnByb21pc2UucmFjZShbaXRlcmF0b3IubmV4dCgpLCB0aW1lclByb21pc2VdKTtcblx0XHRcdGlmIChyZXN1bHQgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHRocm93QWJvcnRFcnJvcigpO1xuXHRcdFx0aWYgKHJlc3VsdC5kb25lKSByZXR1cm4gcmVzdWx0LnZhbHVlO1xuXHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0aWYgKC0tY291bnQgPT09IDApIHRpbWVyUHJvbWlzZSA9IHRpbWVyLnN0YXJ0KCk7XG5cdFx0XHRyZXN1bHQgPSBudWxsO1xuXHRcdH1cblx0fSBjYXRjaCAoXykge1xuXHRcdF91c2luZ0N0eDMuZSA9IF87XG5cdH0gZmluYWxseSB7XG5cdFx0YXdhaXQgX3VzaW5nQ3R4My5kKCk7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdXRpbHMvY3JlYXRlRGVmZXJyZWQudHNcbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkKCkge1xuXHRsZXQgcmVzb2x2ZTtcblx0bGV0IHJlamVjdDtcblx0Y29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdHJlc29sdmUgPSByZXM7XG5cdFx0cmVqZWN0ID0gcmVqO1xuXHR9KTtcblx0cmV0dXJuIHtcblx0XHRwcm9taXNlLFxuXHRcdHJlc29sdmUsXG5cdFx0cmVqZWN0XG5cdH07XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL21lcmdlQXN5bmNJdGVyYWJsZXMudHNcbnZhciBpbXBvcnRfdXNpbmdDdHgkMyA9IF9fdG9FU00ocmVxdWlyZV91c2luZ0N0eCgpLCAxKTtcbmZ1bmN0aW9uIGNyZWF0ZU1hbmFnZWRJdGVyYXRvcihpdGVyYWJsZSwgb25SZXN1bHQpIHtcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblx0bGV0IHN0YXRlID0gXCJpZGxlXCI7XG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0c3RhdGUgPSBcImRvbmVcIjtcblx0XHRvblJlc3VsdCA9ICgpID0+IHt9O1xuXHR9XG5cdGZ1bmN0aW9uIHB1bGwoKSB7XG5cdFx0aWYgKHN0YXRlICE9PSBcImlkbGVcIikgcmV0dXJuO1xuXHRcdHN0YXRlID0gXCJwZW5kaW5nXCI7XG5cdFx0Y29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRuZXh0LnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0aWYgKHJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdHN0YXRlID0gXCJkb25lXCI7XG5cdFx0XHRcdG9uUmVzdWx0KHtcblx0XHRcdFx0XHRzdGF0dXM6IFwicmV0dXJuXCIsXG5cdFx0XHRcdFx0dmFsdWU6IHJlc3VsdC52YWx1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzdGF0ZSA9IFwiaWRsZVwiO1xuXHRcdFx0b25SZXN1bHQoe1xuXHRcdFx0XHRzdGF0dXM6IFwieWllbGRcIixcblx0XHRcdFx0dmFsdWU6IHJlc3VsdC52YWx1ZVxuXHRcdFx0fSk7XG5cdFx0fSkuY2F0Y2goKGNhdXNlKSA9PiB7XG5cdFx0XHRvblJlc3VsdCh7XG5cdFx0XHRcdHN0YXR1czogXCJlcnJvclwiLFxuXHRcdFx0XHRlcnJvcjogY2F1c2Vcblx0XHRcdH0pO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0cHVsbCxcblx0XHRkZXN0cm95OiBhc3luYyAoKSA9PiB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRhd2FpdCBpdGVyYXRvci5yZXR1cm4/LigpO1xuXHRcdH1cblx0fTtcbn1cbi8qKlxuKiBDcmVhdGVzIGEgbmV3IGFzeW5jIGl0ZXJhYmxlIHRoYXQgbWVyZ2VzIG11bHRpcGxlIGFzeW5jIGl0ZXJhYmxlcyBpbnRvIGEgc2luZ2xlIHN0cmVhbS5cbiogVmFsdWVzIGZyb20gdGhlIGlucHV0IGl0ZXJhYmxlcyBhcmUgeWllbGRlZCBpbiB0aGUgb3JkZXIgdGhleSByZXNvbHZlLCBzaW1pbGFyIHRvIFByb21pc2UucmFjZSgpLlxuKlxuKiBOZXcgaXRlcmFibGVzIGNhbiBiZSBhZGRlZCBkeW5hbWljYWxseSB1c2luZyB0aGUgcmV0dXJuZWQge0BsaW5rIE1lcmdlZEFzeW5jSXRlcmFibGVzLmFkZH0gbWV0aG9kLCBldmVuIGFmdGVyIGl0ZXJhdGlvbiBoYXMgc3RhcnRlZC5cbipcbiogSWYgYW55IG9mIHRoZSBpbnB1dCBpdGVyYWJsZXMgdGhyb3dzIGFuIGVycm9yLCB0aGF0IGVycm9yIHdpbGwgYmUgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBtZXJnZWQgc3RyZWFtLlxuKiBPdGhlciBpdGVyYWJsZXMgd2lsbCBub3QgY29udGludWUgdG8gYmUgcHJvY2Vzc2VkLlxuKlxuKiBAdGVtcGxhdGUgVFlpZWxkIFRoZSB0eXBlIG9mIHZhbHVlcyB5aWVsZGVkIGJ5IHRoZSBpbnB1dCBpdGVyYWJsZXNcbiovXG5mdW5jdGlvbiBtZXJnZUFzeW5jSXRlcmFibGVzKCkge1xuXHRsZXQgc3RhdGUgPSBcImlkbGVcIjtcblx0bGV0IGZsdXNoU2lnbmFsID0gY3JlYXRlRGVmZXJyZWQoKTtcblx0LyoqXG5cdCogdXNlZCB3aGlsZSB7QGxpbmsgc3RhdGV9IGlzIGBpZGxlYFxuXHQqL1xuXHRjb25zdCBpdGVyYWJsZXMgPSBbXTtcblx0LyoqXG5cdCogdXNlZCB3aGlsZSB7QGxpbmsgc3RhdGV9IGlzIGBwZW5kaW5nYFxuXHQqL1xuXHRjb25zdCBpdGVyYXRvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuXHRjb25zdCBidWZmZXIgPSBbXTtcblx0ZnVuY3Rpb24gaW5pdEl0ZXJhYmxlKGl0ZXJhYmxlKSB7XG5cdFx0aWYgKHN0YXRlICE9PSBcInBlbmRpbmdcIikgcmV0dXJuO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gY3JlYXRlTWFuYWdlZEl0ZXJhdG9yKGl0ZXJhYmxlLCAocmVzdWx0KSA9PiB7XG5cdFx0XHRpZiAoc3RhdGUgIT09IFwicGVuZGluZ1wiKSByZXR1cm47XG5cdFx0XHRzd2l0Y2ggKHJlc3VsdC5zdGF0dXMpIHtcblx0XHRcdFx0Y2FzZSBcInlpZWxkXCI6XG5cdFx0XHRcdFx0YnVmZmVyLnB1c2goW2l0ZXJhdG9yLCByZXN1bHRdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJldHVyblwiOlxuXHRcdFx0XHRcdGl0ZXJhdG9ycy5kZWxldGUoaXRlcmF0b3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZXJyb3JcIjpcblx0XHRcdFx0XHRidWZmZXIucHVzaChbaXRlcmF0b3IsIHJlc3VsdF0pO1xuXHRcdFx0XHRcdGl0ZXJhdG9ycy5kZWxldGUoaXRlcmF0b3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Zmx1c2hTaWduYWwucmVzb2x2ZSgpO1xuXHRcdH0pO1xuXHRcdGl0ZXJhdG9ycy5hZGQoaXRlcmF0b3IpO1xuXHRcdGl0ZXJhdG9yLnB1bGwoKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGFkZChpdGVyYWJsZSkge1xuXHRcdFx0c3dpdGNoIChzdGF0ZSkge1xuXHRcdFx0XHRjYXNlIFwiaWRsZVwiOlxuXHRcdFx0XHRcdGl0ZXJhYmxlcy5wdXNoKGl0ZXJhYmxlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInBlbmRpbmdcIjpcblx0XHRcdFx0XHRpbml0SXRlcmFibGUoaXRlcmFibGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZG9uZVwiOiBicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eCQzLmRlZmF1bHQpKCk7XG5cdFx0XHRcdGlmIChzdGF0ZSAhPT0gXCJpZGxlXCIpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpdGVyYXRlIHR3aWNlXCIpO1xuXHRcdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiO1xuXHRcdFx0XHRjb25zdCBfZmluYWxseSA9IF91c2luZ0N0eCQxLmEobWFrZUFzeW5jUmVzb3VyY2Uoe30sIGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRzdGF0ZSA9IFwiZG9uZVwiO1xuXHRcdFx0XHRcdGNvbnN0IGVycm9ycyA9IFtdO1xuXHRcdFx0XHRcdGF3YWl0IFByb21pc2UuYWxsKEFycmF5LmZyb20oaXRlcmF0b3JzLnZhbHVlcygpKS5tYXAoYXN5bmMgKGl0KSA9PiB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCBpdC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRcdFx0XHRlcnJvcnMucHVzaChjYXVzZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdGJ1ZmZlci5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdGl0ZXJhdG9ycy5jbGVhcigpO1xuXHRcdFx0XHRcdGZsdXNoU2lnbmFsLnJlc29sdmUoKTtcblx0XHRcdFx0XHRpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpO1xuXHRcdFx0XHR9KSk7XG5cdFx0XHRcdHdoaWxlIChpdGVyYWJsZXMubGVuZ3RoID4gMCkgaW5pdEl0ZXJhYmxlKGl0ZXJhYmxlcy5zaGlmdCgpKTtcblx0XHRcdFx0d2hpbGUgKGl0ZXJhdG9ycy5zaXplID4gMCkge1xuXHRcdFx0XHRcdGF3YWl0IGZsdXNoU2lnbmFsLnByb21pc2U7XG5cdFx0XHRcdFx0d2hpbGUgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBbaXRlcmF0b3IsIHJlc3VsdF0gPSBidWZmZXIuc2hpZnQoKTtcblx0XHRcdFx0XHRcdHN3aXRjaCAocmVzdWx0LnN0YXR1cykge1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwieWllbGRcIjpcblx0XHRcdFx0XHRcdFx0XHR5aWVsZCByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0aXRlcmF0b3IucHVsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwiZXJyb3JcIjogdGhyb3cgcmVzdWx0LmVycm9yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmbHVzaFNpZ25hbCA9IGNyZWF0ZURlZmVycmVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0X3VzaW5nQ3R4JDEuZSA9IF87XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRhd2FpdCBfdXNpbmdDdHgkMS5kKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20udHNcbi8qKlxuKiBDcmVhdGVzIGEgUmVhZGFibGVTdHJlYW0gZnJvbSBhbiBBc3luY0l0ZXJhYmxlLlxuKlxuKiBAcGFyYW0gaXRlcmFibGUgLSBUaGUgc291cmNlIEFzeW5jSXRlcmFibGUgdG8gc3RyZWFtIGZyb21cbiogQHJldHVybnMgQSBSZWFkYWJsZVN0cmVhbSB0aGF0IHlpZWxkcyB2YWx1ZXMgZnJvbSB0aGUgQXN5bmNJdGVyYWJsZVxuKi9cbmZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtRnJvbShpdGVyYWJsZSkge1xuXHRjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuXHRyZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRhc3luYyBjYW5jZWwoKSB7XG5cdFx0XHRhd2FpdCBpdGVyYXRvci5yZXR1cm4/LigpO1xuXHRcdH0sXG5cdFx0YXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy93aXRoUGluZy50c1xudmFyIGltcG9ydF91c2luZ0N0eCQyID0gX190b0VTTShyZXF1aXJlX3VzaW5nQ3R4KCksIDEpO1xuY29uc3QgUElOR19TWU0gPSBTeW1ib2woXCJwaW5nXCIpO1xuLyoqXG4qIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvZiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IHlpZWxkcyB7QGxpbmsgUElOR19TWU19XG4qIHdoZW5ldmVyIG5vIHZhbHVlIGhhcyBiZWVuIHlpZWxkZWQgZm9yIHtAbGluayBwaW5nSW50ZXJ2YWxNc30uXG4qL1xuYXN5bmMgZnVuY3Rpb24qIHdpdGhQaW5nKGl0ZXJhYmxlLCBwaW5nSW50ZXJ2YWxNcykge1xuXHR0cnkge1xuXHRcdHZhciBfdXNpbmdDdHgkMSA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMi5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4JDEuYShpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKSk7XG5cdFx0bGV0IHJlc3VsdDtcblx0XHRsZXQgbmV4dFByb21pc2UgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0d2hpbGUgKHRydWUpIHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMi5kZWZhdWx0KSgpO1xuXHRcdFx0Y29uc3QgcGluZ1Byb21pc2UgPSBfdXNpbmdDdHgzLnUodGltZXJSZXNvdXJjZShwaW5nSW50ZXJ2YWxNcykpO1xuXHRcdFx0cmVzdWx0ID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW25leHRQcm9taXNlLCBwaW5nUHJvbWlzZS5zdGFydCgpXSk7XG5cdFx0XHRpZiAocmVzdWx0ID09PSBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0KSB7XG5cdFx0XHRcdHlpZWxkIFBJTkdfU1lNO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChyZXN1bHQuZG9uZSkgcmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdG5leHRQcm9taXNlID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0cmVzdWx0ID0gbnVsbDtcblx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRfdXNpbmdDdHgzLmUgPSBfO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRfdXNpbmdDdHgzLmQoKTtcblx0XHR9XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0fSBmaW5hbGx5IHtcblx0XHRhd2FpdCBfdXNpbmdDdHgkMS5kKCk7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vanNvbmwudHNcbnZhciBpbXBvcnRfdXNpbmdDdHgkMSA9IF9fdG9FU00ocmVxdWlyZV91c2luZ0N0eCgpLCAxKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5jb25zdCBDSFVOS19WQUxVRV9UWVBFX1BST01JU0UgPSAwO1xuY29uc3QgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRSA9IDE7XG5jb25zdCBQUk9NSVNFX1NUQVRVU19GVUxGSUxMRUQgPSAwO1xuY29uc3QgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQgPSAxO1xuY29uc3QgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1JFVFVSTiA9IDA7XG5jb25zdCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQgPSAxO1xuY29uc3QgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SID0gMjtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBpc0Z1bmN0aW9uKHZhbHVlKSkgJiYgdHlwZW9mIHZhbHVlPy5bXCJ0aGVuXCJdID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlPy5bXCJjYXRjaFwiXSA9PT0gXCJmdW5jdGlvblwiO1xufVxudmFyIE1heERlcHRoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IocGF0aCkge1xuXHRcdHN1cGVyKFwiTWF4IGRlcHRoIHJlYWNoZWQgYXQgcGF0aDogXCIgKyBwYXRoLmpvaW4oXCIuXCIpKTtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHR9XG59O1xuYXN5bmMgZnVuY3Rpb24qIGNyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIob3B0cykge1xuXHRjb25zdCB7IGRhdGEgfSA9IG9wdHM7XG5cdGxldCBjb3VudGVyID0gMDtcblx0Y29uc3QgcGxhY2Vob2xkZXIgPSAwO1xuXHRjb25zdCBtZXJnZWRJdGVyYWJsZXMgPSBtZXJnZUFzeW5jSXRlcmFibGVzKCk7XG5cdGZ1bmN0aW9uIHJlZ2lzdGVyQXN5bmMoY2FsbGJhY2spIHtcblx0XHRjb25zdCBpZHggPSBjb3VudGVyKys7XG5cdFx0Y29uc3QgaXRlcmFibGUkMSA9IGNhbGxiYWNrKGlkeCk7XG5cdFx0bWVyZ2VkSXRlcmFibGVzLmFkZChpdGVyYWJsZSQxKTtcblx0XHRyZXR1cm4gaWR4O1xuXHR9XG5cdGZ1bmN0aW9uIGVuY29kZVByb21pc2UocHJvbWlzZSwgcGF0aCkge1xuXHRcdHJldHVybiByZWdpc3RlckFzeW5jKGFzeW5jIGZ1bmN0aW9uKiAoaWR4KSB7XG5cdFx0XHRjb25zdCBlcnJvciA9IGNoZWNrTWF4RGVwdGgocGF0aCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0cHJvbWlzZS5jYXRjaCgoY2F1c2UpID0+IHtcblx0XHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgbmV4dCA9IGF3YWl0IHByb21pc2U7XG5cdFx0XHRcdHlpZWxkIFtcblx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0UFJPTUlTRV9TVEFUVVNfRlVMRklMTEVELFxuXHRcdFx0XHRcdGVuY29kZShuZXh0LCBwYXRoKVxuXHRcdFx0XHRdO1xuXHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0b3B0cy5vbkVycm9yPy4oe1xuXHRcdFx0XHRcdGVycm9yOiBjYXVzZSxcblx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFBST01JU0VfU1RBVFVTX1JFSkVDVEVELFxuXHRcdFx0XHRcdG9wdHMuZm9ybWF0RXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRmdW5jdGlvbiBlbmNvZGVBc3luY0l0ZXJhYmxlKGl0ZXJhYmxlJDEsIHBhdGgpIHtcblx0XHRyZXR1cm4gcmVnaXN0ZXJBc3luYyhhc3luYyBmdW5jdGlvbiogKGlkeCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eCQxLmRlZmF1bHQpKCk7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gY2hlY2tNYXhEZXB0aChwYXRoKTtcblx0XHRcdFx0aWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdFx0Y29uc3QgaXRlcmF0b3IgPSBfdXNpbmdDdHgkMS5hKGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUkMSkpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXh0ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0XHRcdFx0aWYgKG5leHQuZG9uZSkge1xuXHRcdFx0XHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0XHRcdEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk4sXG5cdFx0XHRcdFx0XHRcdFx0ZW5jb2RlKG5leHQudmFsdWUsIHBhdGgpXG5cdFx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0eWllbGQgW1xuXHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdEFTWU5DX0lURVJBQkxFX1NUQVRVU19ZSUVMRCxcblx0XHRcdFx0XHRcdFx0ZW5jb2RlKG5leHQudmFsdWUsIHBhdGgpXG5cdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0eWllbGQgW1xuXHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0QVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SLFxuXHRcdFx0XHRcdFx0b3B0cy5mb3JtYXRFcnJvcj8uKHtcblx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNhdXNlLFxuXHRcdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0X3VzaW5nQ3R4JDEuZSA9IF87XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRhd2FpdCBfdXNpbmdDdHgkMS5kKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0ZnVuY3Rpb24gY2hlY2tNYXhEZXB0aChwYXRoKSB7XG5cdFx0aWYgKG9wdHMubWF4RGVwdGggJiYgcGF0aC5sZW5ndGggPiBvcHRzLm1heERlcHRoKSByZXR1cm4gbmV3IE1heERlcHRoRXJyb3IocGF0aCk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gZW5jb2RlQXN5bmModmFsdWUsIHBhdGgpIHtcblx0XHRpZiAoaXNQcm9taXNlKHZhbHVlKSkgcmV0dXJuIFtDSFVOS19WQUxVRV9UWVBFX1BST01JU0UsIGVuY29kZVByb21pc2UodmFsdWUsIHBhdGgpXTtcblx0XHRpZiAoaXNBc3luY0l0ZXJhYmxlKHZhbHVlKSkge1xuXHRcdFx0aWYgKG9wdHMubWF4RGVwdGggJiYgcGF0aC5sZW5ndGggPj0gb3B0cy5tYXhEZXB0aCkgdGhyb3cgbmV3IEVycm9yKFwiTWF4IGRlcHRoIHJlYWNoZWRcIik7XG5cdFx0XHRyZXR1cm4gW0NIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEUsIGVuY29kZUFzeW5jSXRlcmFibGUodmFsdWUsIHBhdGgpXTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBwYXRoKSB7XG5cdFx0aWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiBbW11dO1xuXHRcdGNvbnN0IHJlZyA9IGVuY29kZUFzeW5jKHZhbHVlLCBwYXRoKTtcblx0XHRpZiAocmVnKSByZXR1cm4gW1twbGFjZWhvbGRlcl0sIFtudWxsLCAuLi5yZWddXTtcblx0XHRpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSByZXR1cm4gW1t2YWx1ZV1dO1xuXHRcdGNvbnN0IG5ld09iaiA9IHt9O1xuXHRcdGNvbnN0IGFzeW5jVmFsdWVzID0gW107XG5cdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcblx0XHRcdGNvbnN0IHRyYW5zZm9ybWVkID0gZW5jb2RlQXN5bmMoaXRlbSwgWy4uLnBhdGgsIGtleV0pO1xuXHRcdFx0aWYgKCF0cmFuc2Zvcm1lZCkge1xuXHRcdFx0XHRuZXdPYmpba2V5XSA9IGl0ZW07XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0bmV3T2JqW2tleV0gPSBwbGFjZWhvbGRlcjtcblx0XHRcdGFzeW5jVmFsdWVzLnB1c2goW2tleSwgLi4udHJhbnNmb3JtZWRdKTtcblx0XHR9XG5cdFx0cmV0dXJuIFtbbmV3T2JqXSwgLi4uYXN5bmNWYWx1ZXNdO1xuXHR9XG5cdGNvbnN0IG5ld0hlYWQgPSB7fTtcblx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkgbmV3SGVhZFtrZXldID0gZW5jb2RlKGl0ZW0sIFtrZXldKTtcblx0eWllbGQgbmV3SGVhZDtcblx0bGV0IGl0ZXJhYmxlID0gbWVyZ2VkSXRlcmFibGVzO1xuXHRpZiAob3B0cy5waW5nTXMpIGl0ZXJhYmxlID0gd2l0aFBpbmcobWVyZ2VkSXRlcmFibGVzLCBvcHRzLnBpbmdNcyk7XG5cdGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHlpZWxkIHZhbHVlO1xufVxuLyoqXG4qIEpTT04gTGluZXMgc3RyZWFtIHByb2R1Y2VyXG4qIEBzZWUgaHR0cHM6Ly9qc29ubGluZXMub3JnL1xuKi9cbmZ1bmN0aW9uIGpzb25sU3RyZWFtUHJvZHVjZXIob3B0cykge1xuXHRsZXQgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGNyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIob3B0cykpO1xuXHRjb25zdCB7IHNlcmlhbGl6ZSB9ID0gb3B0cztcblx0aWYgKHNlcmlhbGl6ZSkgc3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRpZiAoY2h1bmsgPT09IFBJTkdfU1lNKSBjb250cm9sbGVyLmVucXVldWUoUElOR19TWU0pO1xuXHRcdGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHNlcmlhbGl6ZShjaHVuaykpO1xuXHR9IH0pKTtcblx0cmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHsgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG5cdFx0aWYgKGNodW5rID09PSBQSU5HX1NZTSkgY29udHJvbGxlci5lbnF1ZXVlKFwiIFwiKTtcblx0XHRlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZShKU09OLnN0cmluZ2lmeShjaHVuaykgKyBcIlxcblwiKTtcblx0fSB9KSkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xufVxudmFyIEFzeW5jRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoZGF0YSkge1xuXHRcdHN1cGVyKFwiUmVjZWl2ZWQgZXJyb3IgZnJvbSBzZXJ2ZXJcIik7XG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0fVxufTtcbmNvbnN0IG5vZGVKc1N0cmVhbVRvUmVhZGVyRXNxdWUgPSAoc291cmNlKSA9PiB7XG5cdHJldHVybiB7IGdldFJlYWRlcigpIHtcblx0XHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRzb3VyY2Uub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuXHRcdFx0fSk7XG5cdFx0XHRzb3VyY2Uub24oXCJlbmRcIiwgKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHR9KTtcblx0XHRcdHNvdXJjZS5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVycm9yKGVycm9yKTtcblx0XHRcdH0pO1xuXHRcdH0gfSk7XG5cdFx0cmV0dXJuIHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0fSB9O1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmVBY2N1bXVsYXRvcihmcm9tKSB7XG5cdGNvbnN0IHJlYWRlciA9IFwiZ2V0UmVhZGVyXCIgaW4gZnJvbSA/IGZyb20uZ2V0UmVhZGVyKCkgOiBub2RlSnNTdHJlYW1Ub1JlYWRlckVzcXVlKGZyb20pLmdldFJlYWRlcigpO1xuXHRsZXQgbGluZUFnZ3JlZ2F0ZSA9IFwiXCI7XG5cdHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuXHRcdGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuXHRcdFx0Y29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblx0XHRcdGlmIChkb25lKSBjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG5cdFx0fSxcblx0XHRjYW5jZWwoKSB7XG5cdFx0XHRyZXR1cm4gcmVhZGVyLmNhbmNlbCgpO1xuXHRcdH1cblx0fSkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRsaW5lQWdncmVnYXRlICs9IGNodW5rO1xuXHRcdGNvbnN0IHBhcnRzID0gbGluZUFnZ3JlZ2F0ZS5zcGxpdChcIlxcblwiKTtcblx0XHRsaW5lQWdncmVnYXRlID0gcGFydHMucG9wKCkgPz8gXCJcIjtcblx0XHRmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcblx0fSB9KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb25zdW1lclN0cmVhbShmcm9tKSB7XG5cdGNvbnN0IHN0cmVhbSA9IGNyZWF0ZUxpbmVBY2N1bXVsYXRvcihmcm9tKTtcblx0bGV0IHNlbnRIZWFkID0gZmFsc2U7XG5cdHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh7IHRyYW5zZm9ybShsaW5lLCBjb250cm9sbGVyKSB7XG5cdFx0aWYgKCFzZW50SGVhZCkge1xuXHRcdFx0Y29uc3QgaGVhZCA9IEpTT04ucGFyc2UobGluZSk7XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUoaGVhZCk7XG5cdFx0XHRzZW50SGVhZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGNodW5rID0gSlNPTi5wYXJzZShsaW5lKTtcblx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG5cdFx0fVxuXHR9IH0pKTtcbn1cbi8qKlxuKiBDcmVhdGVzIGEgaGFuZGxlciBmb3IgbWFuYWdpbmcgc3RyZWFtIGNvbnRyb2xsZXJzIGFuZCB0aGVpciBsaWZlY3ljbGVcbiovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1zTWFuYWdlcihhYm9ydENvbnRyb2xsZXIpIHtcblx0Y29uc3QgY29udHJvbGxlck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5cdC8qKlxuXHQqIENoZWNrcyBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBjb250cm9sbGVycyBvciBkZWZlcnJlZCBwcm9taXNlc1xuXHQqL1xuXHRmdW5jdGlvbiBpc0VtcHR5KCkge1xuXHRcdHJldHVybiBBcnJheS5mcm9tKGNvbnRyb2xsZXJNYXAudmFsdWVzKCkpLmV2ZXJ5KChjKSA9PiBjLmNsb3NlZCk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIHN0cmVhbSBjb250cm9sbGVyXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbUNvbnRyb2xsZXIoKSB7XG5cdFx0bGV0IG9yaWdpbmFsQ29udHJvbGxlcjtcblx0XHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRvcmlnaW5hbENvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdH0gfSk7XG5cdFx0Y29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHtcblx0XHRcdGVucXVldWU6ICh2KSA9PiBvcmlnaW5hbENvbnRyb2xsZXIuZW5xdWV1ZSh2KSxcblx0XHRcdGNsb3NlOiAoKSA9PiB7XG5cdFx0XHRcdG9yaWdpbmFsQ29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRjbGVhcigpO1xuXHRcdFx0XHRpZiAoaXNFbXB0eSgpKSBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcblx0XHRcdH0sXG5cdFx0XHRjbG9zZWQ6IGZhbHNlLFxuXHRcdFx0Z2V0UmVhZGVyUmVzb3VyY2U6ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuXHRcdFx0XHRyZXR1cm4gbWFrZVJlc291cmNlKHJlYWRlciwgKCkgPT4ge1xuXHRcdFx0XHRcdHJlYWRlci5yZWxlYXNlTG9jaygpO1xuXHRcdFx0XHRcdHN0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IChyZWFzb24pID0+IHtcblx0XHRcdFx0b3JpZ2luYWxDb250cm9sbGVyLmVycm9yKHJlYXNvbik7XG5cdFx0XHRcdGNsZWFyKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRmdW5jdGlvbiBjbGVhcigpIHtcblx0XHRcdE9iamVjdC5hc3NpZ24oc3RyZWFtQ29udHJvbGxlciwge1xuXHRcdFx0XHRjbG9zZWQ6IHRydWUsXG5cdFx0XHRcdGNsb3NlOiAoKSA9PiB7fSxcblx0XHRcdFx0ZW5xdWV1ZTogKCkgPT4ge30sXG5cdFx0XHRcdGdldFJlYWRlclJlc291cmNlOiBudWxsLFxuXHRcdFx0XHRlcnJvcjogKCkgPT4ge31cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyZWFtQ29udHJvbGxlcjtcblx0fVxuXHQvKipcblx0KiBHZXRzIG9yIGNyZWF0ZXMgYSBzdHJlYW0gY29udHJvbGxlclxuXHQqL1xuXHRmdW5jdGlvbiBnZXRPckNyZWF0ZShjaHVua0lkKSB7XG5cdFx0bGV0IGMgPSBjb250cm9sbGVyTWFwLmdldChjaHVua0lkKTtcblx0XHRpZiAoIWMpIHtcblx0XHRcdGMgPSBjcmVhdGVTdHJlYW1Db250cm9sbGVyKCk7XG5cdFx0XHRjb250cm9sbGVyTWFwLnNldChjaHVua0lkLCBjKTtcblx0XHR9XG5cdFx0cmV0dXJuIGM7XG5cdH1cblx0LyoqXG5cdCogQ2FuY2VscyBhbGwgcGVuZGluZyBjb250cm9sbGVycyBhbmQgcmVqZWN0cyBkZWZlcnJlZCBwcm9taXNlc1xuXHQqL1xuXHRmdW5jdGlvbiBjYW5jZWxBbGwocmVhc29uKSB7XG5cdFx0Zm9yIChjb25zdCBjb250cm9sbGVyIG9mIGNvbnRyb2xsZXJNYXAudmFsdWVzKCkpIGNvbnRyb2xsZXIuZXJyb3IocmVhc29uKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGdldE9yQ3JlYXRlLFxuXHRcdGlzRW1wdHksXG5cdFx0Y2FuY2VsQWxsXG5cdH07XG59XG4vKipcbiogSlNPTiBMaW5lcyBzdHJlYW0gY29uc3VtZXJcbiogQHNlZSBodHRwczovL2pzb25saW5lcy5vcmcvXG4qL1xuYXN5bmMgZnVuY3Rpb24ganNvbmxTdHJlYW1Db25zdW1lcihvcHRzKSB7XG5cdGNvbnN0IHsgZGVzZXJpYWxpemUgPSAodikgPT4gdiB9ID0gb3B0cztcblx0bGV0IHNvdXJjZSA9IGNyZWF0ZUNvbnN1bWVyU3RyZWFtKG9wdHMuZnJvbSk7XG5cdGlmIChkZXNlcmlhbGl6ZSkgc291cmNlID0gc291cmNlLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRjb250cm9sbGVyLmVucXVldWUoZGVzZXJpYWxpemUoY2h1bmspKTtcblx0fSB9KSk7XG5cdGxldCBoZWFkRGVmZXJyZWQgPSBjcmVhdGVEZWZlcnJlZCgpO1xuXHRjb25zdCBzdHJlYW1NYW5hZ2VyID0gY3JlYXRlU3RyZWFtc01hbmFnZXIob3B0cy5hYm9ydENvbnRyb2xsZXIpO1xuXHRmdW5jdGlvbiBkZWNvZGVDaHVua0RlZmluaXRpb24odmFsdWUpIHtcblx0XHRjb25zdCBbX3BhdGgsIHR5cGUsIGNodW5rSWRdID0gdmFsdWU7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IHN0cmVhbU1hbmFnZXIuZ2V0T3JDcmVhdGUoY2h1bmtJZCk7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIENIVU5LX1ZBTFVFX1RZUEVfUFJPTUlTRTogcmV0dXJuIHJ1bihhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIF91c2luZ0N0eDMgPSAoMCwgaW1wb3J0X3VzaW5nQ3R4JDEuZGVmYXVsdCkoKTtcblx0XHRcdFx0XHRjb25zdCByZWFkZXIgPSBfdXNpbmdDdHgzLnUoY29udHJvbGxlci5nZXRSZWFkZXJSZXNvdXJjZSgpKTtcblx0XHRcdFx0XHRjb25zdCB7IHZhbHVlOiB2YWx1ZSQxIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXHRcdFx0XHRcdGNvbnN0IFtfY2h1bmtJZCwgc3RhdHVzLCBkYXRhXSA9IHZhbHVlJDE7XG5cdFx0XHRcdFx0c3dpdGNoIChzdGF0dXMpIHtcblx0XHRcdFx0XHRcdGNhc2UgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEOiByZXR1cm4gZGVjb2RlKGRhdGEpO1xuXHRcdFx0XHRcdFx0Y2FzZSBQUk9NSVNFX1NUQVRVU19SRUpFQ1RFRDogdGhyb3cgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGRhdGEgfSkgPz8gbmV3IEFzeW5jRXJyb3IoZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRcdFx0X3VzaW5nQ3R4My5lID0gXztcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRfdXNpbmdDdHgzLmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRjYXNlIENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEU6IHJldHVybiBydW4oYXN5bmMgZnVuY3Rpb24qICgpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgX3VzaW5nQ3R4NCA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMS5kZWZhdWx0KSgpO1xuXHRcdFx0XHRcdGNvbnN0IHJlYWRlciA9IF91c2luZ0N0eDQudShjb250cm9sbGVyLmdldFJlYWRlclJlc291cmNlKCkpO1xuXHRcdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB7IHZhbHVlOiB2YWx1ZSQxIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXHRcdFx0XHRcdFx0Y29uc3QgW19jaHVua0lkLCBzdGF0dXMsIGRhdGFdID0gdmFsdWUkMTtcblx0XHRcdFx0XHRcdHN3aXRjaCAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1lJRUxEOlxuXHRcdFx0XHRcdFx0XHRcdHlpZWxkIGRlY29kZShkYXRhKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOOiByZXR1cm4gZGVjb2RlKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRjYXNlIEFTWU5DX0lURVJBQkxFX1NUQVRVU19FUlJPUjogdGhyb3cgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGRhdGEgfSkgPz8gbmV3IEFzeW5jRXJyb3IoZGF0YSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRcdFx0X3VzaW5nQ3R4NC5lID0gXztcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRfdXNpbmdDdHg0LmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGRlY29kZSh2YWx1ZSkge1xuXHRcdGNvbnN0IFtbZGF0YV0sIC4uLmFzeW5jUHJvcHNdID0gdmFsdWU7XG5cdFx0Zm9yIChjb25zdCB2YWx1ZSQxIG9mIGFzeW5jUHJvcHMpIHtcblx0XHRcdGNvbnN0IFtrZXldID0gdmFsdWUkMTtcblx0XHRcdGNvbnN0IGRlY29kZWQgPSBkZWNvZGVDaHVua0RlZmluaXRpb24odmFsdWUkMSk7XG5cdFx0XHRpZiAoa2V5ID09PSBudWxsKSByZXR1cm4gZGVjb2RlZDtcblx0XHRcdGRhdGFba2V5XSA9IGRlY29kZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGNvbnN0IGNsb3NlT3JBYm9ydCA9IChyZWFzb24pID0+IHtcblx0XHRoZWFkRGVmZXJyZWQ/LnJlamVjdChyZWFzb24pO1xuXHRcdHN0cmVhbU1hbmFnZXIuY2FuY2VsQWxsKHJlYXNvbik7XG5cdH07XG5cdHNvdXJjZS5waXBlVG8obmV3IFdyaXRhYmxlU3RyZWFtKHtcblx0XHR3cml0ZShjaHVua09ySGVhZCkge1xuXHRcdFx0aWYgKGhlYWREZWZlcnJlZCkge1xuXHRcdFx0XHRjb25zdCBoZWFkID0gY2h1bmtPckhlYWQ7XG5cdFx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNodW5rT3JIZWFkKSkge1xuXHRcdFx0XHRcdGNvbnN0IHBhcnNlZCA9IGRlY29kZSh2YWx1ZSk7XG5cdFx0XHRcdFx0aGVhZFtrZXldID0gcGFyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhlYWREZWZlcnJlZC5yZXNvbHZlKGhlYWQpO1xuXHRcdFx0XHRoZWFkRGVmZXJyZWQgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjaHVuayA9IGNodW5rT3JIZWFkO1xuXHRcdFx0Y29uc3QgW2lkeF0gPSBjaHVuaztcblx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW1NYW5hZ2VyLmdldE9yQ3JlYXRlKGlkeCk7XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuXHRcdH0sXG5cdFx0Y2xvc2U6ICgpID0+IGNsb3NlT3JBYm9ydChuZXcgRXJyb3IoXCJTdHJlYW0gY2xvc2VkXCIpKSxcblx0XHRhYm9ydDogY2xvc2VPckFib3J0XG5cdH0pLCB7IHNpZ25hbDogb3B0cy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdG9wdHMub25FcnJvcj8uKHsgZXJyb3IgfSk7XG5cdFx0Y2xvc2VPckFib3J0KGVycm9yKTtcblx0fSk7XG5cdHJldHVybiBbYXdhaXQgaGVhZERlZmVycmVkLnByb21pc2UsIHN0cmVhbU1hbmFnZXJdO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS9zc2UudHNcbnZhciBpbXBvcnRfdXNpbmdDdHggPSBfX3RvRVNNKHJlcXVpcmVfdXNpbmdDdHgoKSwgMSk7XG5jb25zdCBQSU5HX0VWRU5UID0gXCJwaW5nXCI7XG5jb25zdCBTRVJJQUxJWkVEX0VSUk9SX0VWRU5UID0gXCJzZXJpYWxpemVkLWVycm9yXCI7XG5jb25zdCBDT05ORUNURURfRVZFTlQgPSBcImNvbm5lY3RlZFwiO1xuY29uc3QgUkVUVVJOX0VWRU5UID0gXCJyZXR1cm5cIjtcbi8qKlxuKlxuKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sXG4qL1xuZnVuY3Rpb24gc3NlU3RyZWFtUHJvZHVjZXIob3B0cykge1xuXHRjb25zdCB7IHNlcmlhbGl6ZSA9IGlkZW50aXR5IH0gPSBvcHRzO1xuXHRjb25zdCBwaW5nID0ge1xuXHRcdGVuYWJsZWQ6IG9wdHMucGluZz8uZW5hYmxlZCA/PyBmYWxzZSxcblx0XHRpbnRlcnZhbE1zOiBvcHRzLnBpbmc/LmludGVydmFsTXMgPz8gMWUzXG5cdH07XG5cdGNvbnN0IGNsaWVudCA9IG9wdHMuY2xpZW50ID8/IHt9O1xuXHRpZiAocGluZy5lbmFibGVkICYmIGNsaWVudC5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcyAmJiBwaW5nLmludGVydmFsTXMgPiBjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXMpIHRocm93IG5ldyBFcnJvcihgUGluZyBpbnRlcnZhbCBtdXN0IGJlIGxlc3MgdGhhbiBjbGllbnQgcmVjb25uZWN0IGludGVydmFsIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVjb25uZWN0aW9uIC0gcGluZy5pbnRlcnZhbE1zOiAke3BpbmcuaW50ZXJ2YWxNc30gY2xpZW50LnJlY29ubmVjdEFmdGVySW5hY3Rpdml0eU1zOiAke2NsaWVudC5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNc31gKTtcblx0YXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcblx0XHR5aWVsZCB7XG5cdFx0XHRldmVudDogQ09OTkVDVEVEX0VWRU5ULFxuXHRcdFx0ZGF0YTogSlNPTi5zdHJpbmdpZnkoY2xpZW50KVxuXHRcdH07XG5cdFx0bGV0IGl0ZXJhYmxlID0gb3B0cy5kYXRhO1xuXHRcdGlmIChvcHRzLmVtaXRBbmRFbmRJbW1lZGlhdGVseSkgaXRlcmFibGUgPSB0YWtlV2l0aEdyYWNlKGl0ZXJhYmxlLCB7XG5cdFx0XHRjb3VudDogMSxcblx0XHRcdGdyYWNlUGVyaW9kTXM6IDFcblx0XHR9KTtcblx0XHRpZiAob3B0cy5tYXhEdXJhdGlvbk1zICYmIG9wdHMubWF4RHVyYXRpb25NcyA+IDAgJiYgb3B0cy5tYXhEdXJhdGlvbk1zICE9PSBJbmZpbml0eSkgaXRlcmFibGUgPSB3aXRoTWF4RHVyYXRpb24oaXRlcmFibGUsIHsgbWF4RHVyYXRpb25Nczogb3B0cy5tYXhEdXJhdGlvbk1zIH0pO1xuXHRcdGlmIChwaW5nLmVuYWJsZWQgJiYgcGluZy5pbnRlcnZhbE1zICE9PSBJbmZpbml0eSAmJiBwaW5nLmludGVydmFsTXMgPiAwKSBpdGVyYWJsZSA9IHdpdGhQaW5nKGl0ZXJhYmxlLCBwaW5nLmludGVydmFsTXMpO1xuXHRcdGxldCB2YWx1ZTtcblx0XHRsZXQgY2h1bms7XG5cdFx0Zm9yIGF3YWl0ICh2YWx1ZSBvZiBpdGVyYWJsZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSBQSU5HX1NZTSkge1xuXHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0ZXZlbnQ6IFBJTkdfRVZFTlQsXG5cdFx0XHRcdFx0ZGF0YTogXCJcIlxuXHRcdFx0XHR9O1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGNodW5rID0gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpID8ge1xuXHRcdFx0XHRpZDogdmFsdWVbMF0sXG5cdFx0XHRcdGRhdGE6IHZhbHVlWzFdXG5cdFx0XHR9IDogeyBkYXRhOiB2YWx1ZSB9O1xuXHRcdFx0Y2h1bmsuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZShjaHVuay5kYXRhKSk7XG5cdFx0XHR5aWVsZCBjaHVuaztcblx0XHRcdHZhbHVlID0gbnVsbDtcblx0XHRcdGNodW5rID0gbnVsbDtcblx0XHR9XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkge1xuXHRcdHRyeSB7XG5cdFx0XHR5aWVsZCogZ2VuZXJhdG9yKCk7XG5cdFx0XHR5aWVsZCB7XG5cdFx0XHRcdGV2ZW50OiBSRVRVUk5fRVZFTlQsXG5cdFx0XHRcdGRhdGE6IFwiXCJcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdGlmIChpc0Fib3J0RXJyb3IoY2F1c2UpKSByZXR1cm47XG5cdFx0XHRjb25zdCBlcnJvciA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKTtcblx0XHRcdGNvbnN0IGRhdGEgPSBvcHRzLmZvcm1hdEVycm9yPy4oeyBlcnJvciB9KSA/PyBudWxsO1xuXHRcdFx0eWllbGQge1xuXHRcdFx0XHRldmVudDogU0VSSUFMSVpFRF9FUlJPUl9FVkVOVCxcblx0XHRcdFx0ZGF0YTogSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplKGRhdGEpKVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0Y29uc3Qgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkpO1xuXHRyZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRpZiAoXCJldmVudFwiIGluIGNodW5rKSBjb250cm9sbGVyLmVucXVldWUoYGV2ZW50OiAke2NodW5rLmV2ZW50fVxcbmApO1xuXHRcdGlmIChcImRhdGFcIiBpbiBjaHVuaykgY29udHJvbGxlci5lbnF1ZXVlKGBkYXRhOiAke2NodW5rLmRhdGF9XFxuYCk7XG5cdFx0aWYgKFwiaWRcIiBpbiBjaHVuaykgY29udHJvbGxlci5lbnF1ZXVlKGBpZDogJHtjaHVuay5pZH1cXG5gKTtcblx0XHRpZiAoXCJjb21tZW50XCIgaW4gY2h1bmspIGNvbnRyb2xsZXIuZW5xdWV1ZShgOiAke2NodW5rLmNvbW1lbnR9XFxuYCk7XG5cdFx0Y29udHJvbGxlci5lbnF1ZXVlKFwiXFxuXFxuXCIpO1xuXHR9IH0pKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChvcHRzKSB7XG5cdHRyeSB7XG5cdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eC5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IHRpbWVvdXRQcm9taXNlID0gX3VzaW5nQ3R4JDEudSh0aW1lclJlc291cmNlKG9wdHMudGltZW91dE1zKSk7XG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW29wdHMucHJvbWlzZSwgdGltZW91dFByb21pc2Uuc3RhcnQoKV0pO1xuXHRcdGlmIChyZXMgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHJldHVybiBhd2FpdCBvcHRzLm9uVGltZW91dCgpO1xuXHRcdHJldHVybiByZXM7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0fSBmaW5hbGx5IHtcblx0XHRfdXNpbmdDdHgkMS5kKCk7XG5cdH1cbn1cbi8qKlxuKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sXG4qL1xuZnVuY3Rpb24gc3NlU3RyZWFtQ29uc3VtZXIob3B0cykge1xuXHRjb25zdCB7IGRlc2VyaWFsaXplID0gKHYpID0+IHYgfSA9IG9wdHM7XG5cdGxldCBjbGllbnRPcHRpb25zID0ge307XG5cdGNvbnN0IHNpZ25hbCA9IG9wdHMuc2lnbmFsO1xuXHRsZXQgX2VzID0gbnVsbDtcblx0Y29uc3QgY3JlYXRlU3RyZWFtID0gKCkgPT4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRjb25zdCBbdXJsLCBpbml0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtvcHRzLnVybCgpLCBvcHRzLmluaXQoKV0pO1xuXHRcdFx0Y29uc3QgZXZlbnRTb3VyY2UgPSBfZXMgPSBuZXcgb3B0cy5FdmVudFNvdXJjZSh1cmwsIGluaXQpO1xuXHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0dHlwZTogXCJjb25uZWN0aW5nXCIsXG5cdFx0XHRcdGV2ZW50U291cmNlOiBfZXMsXG5cdFx0XHRcdGV2ZW50OiBudWxsXG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoQ09OTkVDVEVEX0VWRU5ULCAoX21zZykgPT4ge1xuXHRcdFx0XHRjb25zdCBtc2cgPSBfbXNnO1xuXHRcdFx0XHRjb25zdCBvcHRpb25zID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG5cdFx0XHRcdGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwiY29ubmVjdGVkXCIsXG5cdFx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0XHRldmVudFNvdXJjZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0ZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihTRVJJQUxJWkVEX0VSUk9SX0VWRU5ULCAoX21zZykgPT4ge1xuXHRcdFx0XHRjb25zdCBtc2cgPSBfbXNnO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwic2VyaWFsaXplZC1lcnJvclwiLFxuXHRcdFx0XHRcdGVycm9yOiBkZXNlcmlhbGl6ZShKU09OLnBhcnNlKG1zZy5kYXRhKSksXG5cdFx0XHRcdFx0ZXZlbnRTb3VyY2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoUElOR19FVkVOVCwgKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwicGluZ1wiLFxuXHRcdFx0XHRcdGV2ZW50U291cmNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFJFVFVSTl9FVkVOVCwgKCkgPT4ge1xuXHRcdFx0XHRldmVudFNvdXJjZS5jbG9zZSgpO1xuXHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdF9lcyA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0aWYgKGV2ZW50U291cmNlLnJlYWR5U3RhdGUgPT09IGV2ZW50U291cmNlLkNMT1NFRCkgY29udHJvbGxlci5lcnJvcihldmVudCk7XG5cdFx0XHRcdGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0XHR0eXBlOiBcImNvbm5lY3RpbmdcIixcblx0XHRcdFx0XHRldmVudFNvdXJjZSxcblx0XHRcdFx0XHRldmVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0ZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKF9tc2cpID0+IHtcblx0XHRcdFx0Y29uc3QgbXNnID0gX21zZztcblx0XHRcdFx0Y29uc3QgY2h1bmsgPSBkZXNlcmlhbGl6ZShKU09OLnBhcnNlKG1zZy5kYXRhKSk7XG5cdFx0XHRcdGNvbnN0IGRlZiA9IHsgZGF0YTogY2h1bmsgfTtcblx0XHRcdFx0aWYgKG1zZy5sYXN0RXZlbnRJZCkgZGVmLmlkID0gbXNnLmxhc3RFdmVudElkO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwiZGF0YVwiLFxuXHRcdFx0XHRcdGRhdGE6IGRlZixcblx0XHRcdFx0XHRldmVudFNvdXJjZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3Qgb25BYm9ydCA9ICgpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRldmVudFNvdXJjZS5jbG9zZSgpO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fSBjYXRjaCB7fVxuXHRcdFx0fTtcblx0XHRcdGlmIChzaWduYWwuYWJvcnRlZCkgb25BYm9ydCgpO1xuXHRcdFx0ZWxzZSBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuXHRcdH0sXG5cdFx0Y2FuY2VsKCkge1xuXHRcdFx0X2VzPy5jbG9zZSgpO1xuXHRcdH1cblx0fSk7XG5cdGNvbnN0IGdldFN0cmVhbVJlc291cmNlID0gKCkgPT4ge1xuXHRcdGxldCBzdHJlYW0gPSBjcmVhdGVTdHJlYW0oKTtcblx0XHRsZXQgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuXHRcdGFzeW5jIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG5cdFx0XHRfZXMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFrZUFzeW5jUmVzb3VyY2Uoe1xuXHRcdFx0cmVhZCgpIHtcblx0XHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkKCk7XG5cdFx0XHR9LFxuXHRcdFx0YXN5bmMgcmVjcmVhdGUoKSB7XG5cdFx0XHRcdGF3YWl0IGRpc3Bvc2UoKTtcblx0XHRcdFx0c3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG5cdFx0XHRcdHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0XHRcdH1cblx0XHR9LCBkaXNwb3NlKTtcblx0fTtcblx0cmV0dXJuIHJ1bihhc3luYyBmdW5jdGlvbiogKCkge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHguZGVmYXVsdCkoKTtcblx0XHRcdGNvbnN0IHN0cmVhbSA9IF91c2luZ0N0eDMuYShnZXRTdHJlYW1SZXNvdXJjZSgpKTtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdGxldCBwcm9taXNlID0gc3RyZWFtLnJlYWQoKTtcblx0XHRcdFx0Y29uc3QgdGltZW91dE1zID0gY2xpZW50T3B0aW9ucy5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcztcblx0XHRcdFx0aWYgKHRpbWVvdXRNcykgcHJvbWlzZSA9IHdpdGhUaW1lb3V0KHtcblx0XHRcdFx0XHRwcm9taXNlLFxuXHRcdFx0XHRcdHRpbWVvdXRNcyxcblx0XHRcdFx0XHRvblRpbWVvdXQ6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlcyA9IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInRpbWVvdXRcIixcblx0XHRcdFx0XHRcdFx0XHRtczogdGltZW91dE1zLFxuXHRcdFx0XHRcdFx0XHRcdGV2ZW50U291cmNlOiBfZXNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG9uZTogZmFsc2Vcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRhd2FpdCBzdHJlYW0ucmVjcmVhdGUoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcblx0XHRcdFx0aWYgKHJlc3VsdC5kb25lKSByZXR1cm4gcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHR5aWVsZCByZXN1bHQudmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0X3VzaW5nQ3R4My5lID0gXztcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0YXdhaXQgX3VzaW5nQ3R4My5kKCk7XG5cdFx0fVxuXHR9KTtcbn1cbmNvbnN0IHNzZUhlYWRlcnMgPSB7XG5cdFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcblx0XCJDYWNoZS1Db250cm9sXCI6IFwibm8tY2FjaGUsIG5vLXRyYW5zZm9ybVwiLFxuXHRcIlgtQWNjZWwtQnVmZmVyaW5nXCI6IFwibm9cIixcblx0Q29ubmVjdGlvbjogXCJrZWVwLWFsaXZlXCJcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9yZXNvbHZlUmVzcG9uc2UudHNcbmZ1bmN0aW9uIGVycm9yVG9Bc3luY0l0ZXJhYmxlKGVycikge1xuXHRyZXR1cm4gcnVuKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG5cdFx0dGhyb3cgZXJyO1xuXHR9KTtcbn1cbmNvbnN0IFRZUEVfQUNDRVBURURfTUVUSE9EX01BUCA9IHtcblx0bXV0YXRpb246IFtcIlBPU1RcIl0sXG5cdHF1ZXJ5OiBbXCJHRVRcIl0sXG5cdHN1YnNjcmlwdGlvbjogW1wiR0VUXCJdXG59O1xuY29uc3QgVFlQRV9BQ0NFUFRFRF9NRVRIT0RfTUFQX1dJVEhfTUVUSE9EX09WRVJSSURFID0ge1xuXHRtdXRhdGlvbjogW1wiUE9TVFwiXSxcblx0cXVlcnk6IFtcIkdFVFwiLCBcIlBPU1RcIl0sXG5cdHN1YnNjcmlwdGlvbjogW1wiR0VUXCIsIFwiUE9TVFwiXVxufTtcbmZ1bmN0aW9uIGluaXRSZXNwb25zZShpbml0T3B0cykge1xuXHRjb25zdCB7IGN0eCwgaW5mbywgcmVzcG9uc2VNZXRhLCB1bnRyYW5zZm9ybWVkSlNPTiwgZXJyb3JzID0gW10sIGhlYWRlcnMgfSA9IGluaXRPcHRzO1xuXHRsZXQgc3RhdHVzID0gdW50cmFuc2Zvcm1lZEpTT04gPyBnZXRIVFRQU3RhdHVzQ29kZSh1bnRyYW5zZm9ybWVkSlNPTikgOiAyMDA7XG5cdGNvbnN0IGVhZ2VyR2VuZXJhdGlvbiA9ICF1bnRyYW5zZm9ybWVkSlNPTjtcblx0Y29uc3QgZGF0YSA9IGVhZ2VyR2VuZXJhdGlvbiA/IFtdIDogQXJyYXkuaXNBcnJheSh1bnRyYW5zZm9ybWVkSlNPTikgPyB1bnRyYW5zZm9ybWVkSlNPTiA6IFt1bnRyYW5zZm9ybWVkSlNPTl07XG5cdGNvbnN0IG1ldGEgPSByZXNwb25zZU1ldGE/Lih7XG5cdFx0Y3R4LFxuXHRcdGluZm8sXG5cdFx0cGF0aHM6IGluZm8/LmNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5wYXRoKSxcblx0XHRkYXRhLFxuXHRcdGVycm9ycyxcblx0XHRlYWdlckdlbmVyYXRpb24sXG5cdFx0dHlwZTogaW5mbz8uY2FsbHMuZmluZCgoY2FsbCkgPT4gY2FsbC5wcm9jZWR1cmU/Ll9kZWYudHlwZSk/LnByb2NlZHVyZT8uX2RlZi50eXBlID8/IFwidW5rbm93blwiXG5cdH0pID8/IHt9O1xuXHRpZiAobWV0YS5oZWFkZXJzKSB7XG5cdFx0aWYgKG1ldGEuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1ldGEuaGVhZGVycy5lbnRyaWVzKCkpIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuXHRcdGVsc2VcbiAvKipcblx0XHQqIEBkZXByZWNhdGVkLCBkZWxldGUgaW4gdjEyXG5cdFx0Ki9cblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhLmhlYWRlcnMpKSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkgaGVhZGVycy5hcHBlbmQoa2V5LCB2KTtcblx0XHRlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuXHR9XG5cdGlmIChtZXRhLnN0YXR1cykgc3RhdHVzID0gbWV0YS5zdGF0dXM7XG5cdHJldHVybiB7IHN0YXR1cyB9O1xufVxuZnVuY3Rpb24gY2F1Z2h0RXJyb3JUb0RhdGEoY2F1c2UsIGVycm9yT3B0cykge1xuXHRjb25zdCB7IHJvdXRlciwgcmVxLCBvbkVycm9yIH0gPSBlcnJvck9wdHMub3B0cztcblx0Y29uc3QgZXJyb3IgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSk7XG5cdG9uRXJyb3I/Lih7XG5cdFx0ZXJyb3IsXG5cdFx0cGF0aDogZXJyb3JPcHRzLnBhdGgsXG5cdFx0aW5wdXQ6IGVycm9yT3B0cy5pbnB1dCxcblx0XHRjdHg6IGVycm9yT3B0cy5jdHgsXG5cdFx0dHlwZTogZXJyb3JPcHRzLnR5cGUsXG5cdFx0cmVxXG5cdH0pO1xuXHRjb25zdCB1bnRyYW5zZm9ybWVkSlNPTiA9IHsgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuXHRcdGNvbmZpZzogcm91dGVyLl9kZWYuX2NvbmZpZyxcblx0XHRlcnJvcixcblx0XHR0eXBlOiBlcnJvck9wdHMudHlwZSxcblx0XHRwYXRoOiBlcnJvck9wdHMucGF0aCxcblx0XHRpbnB1dDogZXJyb3JPcHRzLmlucHV0LFxuXHRcdGN0eDogZXJyb3JPcHRzLmN0eFxuXHR9KSB9O1xuXHRjb25zdCB0cmFuc2Zvcm1lZEpTT04gPSB0cmFuc2Zvcm1UUlBDUmVzcG9uc2Uocm91dGVyLl9kZWYuX2NvbmZpZywgdW50cmFuc2Zvcm1lZEpTT04pO1xuXHRjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtZWRKU09OKTtcblx0cmV0dXJuIHtcblx0XHRlcnJvcixcblx0XHR1bnRyYW5zZm9ybWVkSlNPTixcblx0XHRib2R5XG5cdH07XG59XG4vKipcbiogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHN0cmVhbS1saWtlIG9iamVjdFxuKiAtIGlmIGl0J3MgYW4gYXN5bmMgaXRlcmFibGVcbiogLSBpZiBpdCdzIGFuIG9iamVjdCB3aXRoIGFzeW5jIGl0ZXJhYmxlcyBvciBwcm9taXNlc1xuKi9cbmZ1bmN0aW9uIGlzRGF0YVN0cmVhbSh2KSB7XG5cdGlmICghaXNPYmplY3QodikpIHJldHVybiBmYWxzZTtcblx0aWYgKGlzQXN5bmNJdGVyYWJsZSh2KSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBPYmplY3QudmFsdWVzKHYpLnNvbWUoaXNQcm9taXNlKSB8fCBPYmplY3QudmFsdWVzKHYpLnNvbWUoaXNBc3luY0l0ZXJhYmxlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVSZXNwb25zZShvcHRzKSB7XG5cdGNvbnN0IHsgcm91dGVyLCByZXEgfSA9IG9wdHM7XG5cdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhbW1widmFyeVwiLCBcInRycGMtYWNjZXB0XCJdXSk7XG5cdGNvbnN0IGNvbmZpZyA9IHJvdXRlci5fZGVmLl9jb25maWc7XG5cdGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG5cdGlmIChyZXEubWV0aG9kID09PSBcIkhFQURcIikgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogMjA0IH0pO1xuXHRjb25zdCBhbGxvd0JhdGNoaW5nID0gb3B0cy5hbGxvd0JhdGNoaW5nID8/IG9wdHMuYmF0Y2hpbmc/LmVuYWJsZWQgPz8gdHJ1ZTtcblx0Y29uc3QgYWxsb3dNZXRob2RPdmVycmlkZSA9IChvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUgPz8gZmFsc2UpICYmIHJlcS5tZXRob2QgPT09IFwiUE9TVFwiO1xuXHRjb25zdCBpbmZvVHVwbGUgPSBhd2FpdCBydW4oYXN5bmMgKCkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gW3ZvaWQgMCwgYXdhaXQgZ2V0UmVxdWVzdEluZm8oe1xuXHRcdFx0XHRyZXEsXG5cdFx0XHRcdHBhdGg6IGRlY29kZVVSSUNvbXBvbmVudChvcHRzLnBhdGgpLFxuXHRcdFx0XHRyb3V0ZXIsXG5cdFx0XHRcdHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcblx0XHRcdFx0aGVhZGVyczogb3B0cy5yZXEuaGVhZGVycyxcblx0XHRcdFx0dXJsXG5cdFx0XHR9KV07XG5cdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdHJldHVybiBbZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLCB2b2lkIDBdO1xuXHRcdH1cblx0fSk7XG5cdGNvbnN0IGN0eE1hbmFnZXIgPSBydW4oKCkgPT4ge1xuXHRcdGxldCByZXN1bHQgPSB2b2lkIDA7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZhbHVlT3JVbmRlZmluZWQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKCFyZXN1bHQpIHJldHVybiB2b2lkIDA7XG5cdFx0XHRcdHJldHVybiByZXN1bHRbMV07XG5cdFx0XHR9LFxuXHRcdFx0dmFsdWU6ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgW2VyciwgY3R4XSA9IHJlc3VsdDtcblx0XHRcdFx0aWYgKGVycikgdGhyb3cgZXJyO1xuXHRcdFx0XHRyZXR1cm4gY3R4O1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZTogYXN5bmMgKGluZm8pID0+IHtcblx0XHRcdFx0aWYgKHJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSAtIHJlcG9ydCBhIGJ1ZyBpbiB0UlBDXCIpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IGN0eCA9IGF3YWl0IG9wdHMuY3JlYXRlQ29udGV4dCh7IGluZm8gfSk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gW3ZvaWQgMCwgY3R4XTtcblx0XHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBbZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLCB2b2lkIDBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cdGNvbnN0IG1ldGhvZE1hcHBlciA9IGFsbG93TWV0aG9kT3ZlcnJpZGUgPyBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVBfV0lUSF9NRVRIT0RfT1ZFUlJJREUgOiBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVA7XG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCovXG5cdGNvbnN0IGlzU3RyZWFtQ2FsbCA9IHJlcS5oZWFkZXJzLmdldChcInRycGMtYWNjZXB0XCIpID09PSBcImFwcGxpY2F0aW9uL2pzb25sXCI7XG5cdGNvbnN0IGV4cGVyaW1lbnRhbFNTRSA9IGNvbmZpZy5zc2U/LmVuYWJsZWQgPz8gdHJ1ZTtcblx0dHJ5IHtcblx0XHRjb25zdCBbaW5mb0Vycm9yLCBpbmZvXSA9IGluZm9UdXBsZTtcblx0XHRpZiAoaW5mb0Vycm9yKSB0aHJvdyBpbmZvRXJyb3I7XG5cdFx0aWYgKGluZm8uaXNCYXRjaENhbGwgJiYgIWFsbG93QmF0Y2hpbmcpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0bWVzc2FnZTogYEJhdGNoaW5nIGlzIG5vdCBlbmFibGVkIG9uIHRoZSBzZXJ2ZXJgXG5cdFx0fSk7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuXHRcdGlmIChpc1N0cmVhbUNhbGwgJiYgIWluZm8uaXNCYXRjaENhbGwpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0bWVzc2FnZTogYFN0cmVhbWluZyByZXF1ZXN0cyBtdXN0IGJlIGJhdGNoZWQgKHlvdSBjYW4gZG8gYSBiYXRjaCBvZiAxKWAsXG5cdFx0XHRjb2RlOiBcIkJBRF9SRVFVRVNUXCJcblx0XHR9KTtcblx0XHRhd2FpdCBjdHhNYW5hZ2VyLmNyZWF0ZShpbmZvKTtcblx0XHRjb25zdCBycGNDYWxscyA9IGluZm8uY2FsbHMubWFwKGFzeW5jIChjYWxsKSA9PiB7XG5cdFx0XHRjb25zdCBwcm9jID0gY2FsbC5wcm9jZWR1cmU7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAob3B0cy5lcnJvcikgdGhyb3cgb3B0cy5lcnJvcjtcblx0XHRcdFx0aWYgKCFwcm9jKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRjb2RlOiBcIk5PVF9GT1VORFwiLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGBObyBwcm9jZWR1cmUgZm91bmQgb24gcGF0aCBcIiR7Y2FsbC5wYXRofVwiYFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKCFtZXRob2RNYXBwZXJbcHJvYy5fZGVmLnR5cGVdLmluY2x1ZGVzKHJlcS5tZXRob2QpKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRjb2RlOiBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCIsXG5cdFx0XHRcdFx0bWVzc2FnZTogYFVuc3VwcG9ydGVkICR7cmVxLm1ldGhvZH0tcmVxdWVzdCB0byAke3Byb2MuX2RlZi50eXBlfSBwcm9jZWR1cmUgYXQgcGF0aCBcIiR7Y2FsbC5wYXRofVwiYFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHByb2MuX2RlZi50eXBlID09PSBcInN1YnNjcmlwdGlvblwiKSB7XG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuXHRcdFx0XHRcdGlmIChpbmZvLmlzQmF0Y2hDYWxsKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IGBDYW5ub3QgYmF0Y2ggc3Vic2NyaXB0aW9uIGNhbGxzYFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCBwcm9jKHtcblx0XHRcdFx0XHRwYXRoOiBjYWxsLnBhdGgsXG5cdFx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGNhbGwuZ2V0UmF3SW5wdXQsXG5cdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlKCksXG5cdFx0XHRcdFx0dHlwZTogcHJvYy5fZGVmLnR5cGUsXG5cdFx0XHRcdFx0c2lnbmFsOiBvcHRzLnJlcS5zaWduYWxcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBbdm9pZCAwLCB7IGRhdGEgfV07XG5cdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRjb25zdCBlcnJvciA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKTtcblx0XHRcdFx0Y29uc3QgaW5wdXQgPSBjYWxsLnJlc3VsdCgpO1xuXHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdFx0cGF0aDogY2FsbC5wYXRoLFxuXHRcdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0dHlwZTogY2FsbC5wcm9jZWR1cmU/Ll9kZWYudHlwZSA/PyBcInVua25vd25cIixcblx0XHRcdFx0XHRyZXE6IG9wdHMucmVxXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gW2Vycm9yLCB2b2lkIDBdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmICghaW5mby5pc0JhdGNoQ2FsbCkge1xuXHRcdFx0Y29uc3QgW2NhbGxdID0gaW5mby5jYWxscztcblx0XHRcdGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGF3YWl0IHJwY0NhbGxzWzBdO1xuXHRcdFx0c3dpdGNoIChpbmZvLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcInVua25vd25cIjpcblx0XHRcdFx0Y2FzZSBcIm11dGF0aW9uXCI6XG5cdFx0XHRcdGNhc2UgXCJxdWVyeVwiOiB7XG5cdFx0XHRcdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdFx0XHRcdGlmIChpc0RhdGFTdHJlYW0ocmVzdWx0Py5kYXRhKSkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0XHRjb2RlOiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IFwiQ2Fubm90IHVzZSBzdHJlYW0tbGlrZSByZXNwb25zZSBpbiBub24tc3RyZWFtaW5nIHJlcXVlc3QgLSB1c2UgaHR0cEJhdGNoU3RyZWFtTGlua1wiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y29uc3QgcmVzID0gZXJyb3IgPyB7IGVycm9yOiBnZXRFcnJvclNoYXBlKHtcblx0XHRcdFx0XHRcdGNvbmZpZyxcblx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRlcnJvcixcblx0XHRcdFx0XHRcdGlucHV0OiBjYWxsLnJlc3VsdCgpLFxuXHRcdFx0XHRcdFx0cGF0aDogY2FsbC5wYXRoLFxuXHRcdFx0XHRcdFx0dHlwZTogaW5mby50eXBlXG5cdFx0XHRcdFx0fSkgfSA6IHsgcmVzdWx0OiB7IGRhdGE6IHJlc3VsdC5kYXRhIH0gfTtcblx0XHRcdFx0XHRjb25zdCBoZWFkUmVzcG9uc2UkMSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0aW5mbyxcblx0XHRcdFx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHRcdFx0XHRlcnJvcnM6IGVycm9yID8gW2Vycm9yXSA6IFtdLFxuXHRcdFx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0XHRcdHVudHJhbnNmb3JtZWRKU09OOiBbcmVzXVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKGNvbmZpZywgcmVzKSksIHtcblx0XHRcdFx0XHRcdHN0YXR1czogaGVhZFJlc3BvbnNlJDEuc3RhdHVzLFxuXHRcdFx0XHRcdFx0aGVhZGVyc1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgXCJzdWJzY3JpcHRpb25cIjoge1xuXHRcdFx0XHRcdGNvbnN0IGl0ZXJhYmxlID0gcnVuKCgpID0+IHtcblx0XHRcdFx0XHRcdGlmIChlcnJvcikgcmV0dXJuIGVycm9yVG9Bc3luY0l0ZXJhYmxlKGVycm9yKTtcblx0XHRcdFx0XHRcdGlmICghZXhwZXJpbWVudGFsU1NFKSByZXR1cm4gZXJyb3JUb0FzeW5jSXRlcmFibGUobmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0XHRcdGNvZGU6IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIixcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogXCJNaXNzaW5nIGV4cGVyaW1lbnRhbCBmbGFnIFxcXCJzc2VTdWJzY3JpcHRpb25zXFxcIlwiXG5cdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHRpZiAoIWlzT2JzZXJ2YWJsZShyZXN1bHQuZGF0YSkgJiYgIWlzQXN5bmNJdGVyYWJsZShyZXN1bHQuZGF0YSkpIHJldHVybiBlcnJvclRvQXN5bmNJdGVyYWJsZShuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogYFN1YnNjcmlwdGlvbiAke2NhbGwucGF0aH0gZGlkIG5vdCByZXR1cm4gYW4gb2JzZXJ2YWJsZSBvciBhIEFzeW5jR2VuZXJhdG9yYCxcblx0XHRcdFx0XHRcdFx0Y29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIlxuXHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGF0YUFzSXRlcmFibGUgPSBpc09ic2VydmFibGUocmVzdWx0LmRhdGEpID8gb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZShyZXN1bHQuZGF0YSwgb3B0cy5yZXEuc2lnbmFsKSA6IHJlc3VsdC5kYXRhO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGFBc0l0ZXJhYmxlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNvbnN0IHN0cmVhbSA9IHNzZVN0cmVhbVByb2R1Y2VyKHtcblx0XHRcdFx0XHRcdC4uLmNvbmZpZy5zc2UsXG5cdFx0XHRcdFx0XHRkYXRhOiBpdGVyYWJsZSxcblx0XHRcdFx0XHRcdHNlcmlhbGl6ZTogKHYpID0+IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKHYpLFxuXHRcdFx0XHRcdFx0Zm9ybWF0RXJyb3IoZXJyb3JPcHRzKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVycm9yJDEgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihlcnJvck9wdHMuZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBpbnB1dCA9IGNhbGw/LnJlc3VsdCgpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBwYXRoID0gY2FsbD8ucGF0aDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgdHlwZSA9IGNhbGw/LnByb2NlZHVyZT8uX2RlZi50eXBlID8/IFwidW5rbm93blwiO1xuXHRcdFx0XHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yJDEsXG5cdFx0XHRcdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHRcdFx0XHRpbnB1dCxcblx0XHRcdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0XHRcdHJlcTogb3B0cy5yZXEsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBnZXRFcnJvclNoYXBlKHtcblx0XHRcdFx0XHRcdFx0XHRjb25maWcsXG5cdFx0XHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IkMSxcblx0XHRcdFx0XHRcdFx0XHRpbnB1dCxcblx0XHRcdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGVcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzaGFwZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzc2VIZWFkZXJzKSkgaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0Y29uc3QgaGVhZFJlc3BvbnNlJDEgPSBpbml0UmVzcG9uc2Uoe1xuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGluZm8sXG5cdFx0XHRcdFx0XHRyZXNwb25zZU1ldGE6IG9wdHMucmVzcG9uc2VNZXRhLFxuXHRcdFx0XHRcdFx0ZXJyb3JzOiBbXSxcblx0XHRcdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdFx0XHR1bnRyYW5zZm9ybWVkSlNPTjogbnVsbFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2UkMS5zdGF0dXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaW5mby5hY2NlcHQgPT09IFwiYXBwbGljYXRpb24vanNvbmxcIikge1xuXHRcdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdFx0aGVhZGVycy5zZXQoXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLCBcImNodW5rZWRcIik7XG5cdFx0XHRjb25zdCBoZWFkUmVzcG9uc2UkMSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdGluZm8sXG5cdFx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHRcdGVycm9yczogW10sXG5cdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdHVudHJhbnNmb3JtZWRKU09OOiBudWxsXG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IHN0cmVhbSA9IGpzb25sU3RyZWFtUHJvZHVjZXIoe1xuXHRcdFx0XHQuLi5jb25maWcuanNvbmwsXG5cdFx0XHRcdG1heERlcHRoOiBJbmZpbml0eSxcblx0XHRcdFx0ZGF0YTogcnBjQ2FsbHMubWFwKGFzeW5jIChyZXMpID0+IHtcblx0XHRcdFx0XHRjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBhd2FpdCByZXM7XG5cdFx0XHRcdFx0Y29uc3QgY2FsbCA9IGluZm8uY2FsbHNbMF07XG5cdFx0XHRcdFx0aWYgKGVycm9yKSByZXR1cm4geyBlcnJvcjogZ2V0RXJyb3JTaGFwZSh7XG5cdFx0XHRcdFx0XHRjb25maWcsXG5cdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdFx0XHRpbnB1dDogY2FsbC5yZXN1bHQoKSxcblx0XHRcdFx0XHRcdHBhdGg6IGNhbGwucGF0aCxcblx0XHRcdFx0XHRcdHR5cGU6IGNhbGwucHJvY2VkdXJlPy5fZGVmLnR5cGUgPz8gXCJ1bmtub3duXCJcblx0XHRcdFx0XHR9KSB9O1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCogTm90IHZlcnkgcHJldHR5LCBidXQgd2UgbmVlZCB0byB3cmFwIG5lc3RlZCBkYXRhIGluIHByb21pc2VzXG5cdFx0XHRcdFx0KiBPdXIgc3RyZWFtIHByb2R1Y2VyIHdpbGwgb25seSByZXNvbHZlIHRvcC1sZXZlbCBhc3luYyB2YWx1ZXMgb3IgYXN5bmMgdmFsdWVzIHRoYXQgYXJlIGRpcmVjdGx5IG5lc3RlZCBpbiBhbm90aGVyIGFzeW5jIHZhbHVlXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRjb25zdCBpdGVyYWJsZSA9IGlzT2JzZXJ2YWJsZShyZXN1bHQuZGF0YSkgPyBvYnNlcnZhYmxlVG9Bc3luY0l0ZXJhYmxlKHJlc3VsdC5kYXRhLCBvcHRzLnJlcS5zaWduYWwpIDogUHJvbWlzZS5yZXNvbHZlKHJlc3VsdC5kYXRhKTtcblx0XHRcdFx0XHRyZXR1cm4geyByZXN1bHQ6IFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IGl0ZXJhYmxlIH0pIH07XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRzZXJpYWxpemU6IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplLFxuXHRcdFx0XHRvbkVycm9yOiAoY2F1c2UpID0+IHtcblx0XHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuXHRcdFx0XHRcdFx0cGF0aDogdm9pZCAwLFxuXHRcdFx0XHRcdFx0aW5wdXQ6IHZvaWQgMCxcblx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRyZXE6IG9wdHMucmVxLFxuXHRcdFx0XHRcdFx0dHlwZTogaW5mbz8udHlwZSA/PyBcInVua25vd25cIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmb3JtYXRFcnJvcihlcnJvck9wdHMpIHtcblx0XHRcdFx0XHRjb25zdCBjYWxsID0gaW5mbz8uY2FsbHNbZXJyb3JPcHRzLnBhdGhbMF1dO1xuXHRcdFx0XHRcdGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oZXJyb3JPcHRzLmVycm9yKTtcblx0XHRcdFx0XHRjb25zdCBpbnB1dCA9IGNhbGw/LnJlc3VsdCgpO1xuXHRcdFx0XHRcdGNvbnN0IHBhdGggPSBjYWxsPy5wYXRoO1xuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBjYWxsPy5wcm9jZWR1cmU/Ll9kZWYudHlwZSA/PyBcInVua25vd25cIjtcblx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRcdFx0Y29uZmlnLFxuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdFx0aW5wdXQsXG5cdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0dHlwZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBzaGFwZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuXHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRzdGF0dXM6IGhlYWRSZXNwb25zZSQxLnN0YXR1c1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCogTm9uLXN0cmVhbWluZyByZXNwb25zZTpcblx0XHQqIC0gYXdhaXQgYWxsIHJlc3BvbnNlcyBpbiBwYXJhbGxlbCwgYmxvY2tpbmcgb24gdGhlIHNsb3dlc3Qgb25lXG5cdFx0KiAtIGNyZWF0ZSBoZWFkZXJzIHdpdGgga25vd24gcmVzcG9uc2UgYm9keVxuXHRcdCogLSByZXR1cm4gYSBjb21wbGV0ZSBIVFRQUmVzcG9uc2Vcblx0XHQqL1xuXHRcdGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0XHRjb25zdCByZXN1bHRzID0gKGF3YWl0IFByb21pc2UuYWxsKHJwY0NhbGxzKSkubWFwKChyZXMpID0+IHtcblx0XHRcdGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IHJlcztcblx0XHRcdGlmIChlcnJvcikgcmV0dXJuIHJlcztcblx0XHRcdGlmIChpc0RhdGFTdHJlYW0ocmVzdWx0LmRhdGEpKSByZXR1cm4gW25ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0XHRjb2RlOiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0XHRcdFx0bWVzc2FnZTogXCJDYW5ub3QgdXNlIHN0cmVhbS1saWtlIHJlc3BvbnNlIGluIG5vbi1zdHJlYW1pbmcgcmVxdWVzdCAtIHVzZSBodHRwQmF0Y2hTdHJlYW1MaW5rXCJcblx0XHRcdH0pLCB2b2lkIDBdO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9KTtcblx0XHRjb25zdCByZXN1bHRBc1JQQ1Jlc3BvbnNlID0gcmVzdWx0cy5tYXAoKFtlcnJvciwgcmVzdWx0XSwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IGNhbGwgPSBpbmZvLmNhbGxzW2luZGV4XTtcblx0XHRcdGlmIChlcnJvcikgcmV0dXJuIHsgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRjb25maWcsXG5cdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRpbnB1dDogY2FsbC5yZXN1bHQoKSxcblx0XHRcdFx0cGF0aDogY2FsbC5wYXRoLFxuXHRcdFx0XHR0eXBlOiBjYWxsLnByb2NlZHVyZT8uX2RlZi50eXBlID8/IFwidW5rbm93blwiXG5cdFx0XHR9KSB9O1xuXHRcdFx0cmV0dXJuIHsgcmVzdWx0OiB7IGRhdGE6IHJlc3VsdC5kYXRhIH0gfTtcblx0XHR9KTtcblx0XHRjb25zdCBlcnJvcnMgPSByZXN1bHRzLm1hcCgoW2Vycm9yXSkgPT4gZXJyb3IpLmZpbHRlcihCb29sZWFuKTtcblx0XHRjb25zdCBoZWFkUmVzcG9uc2UgPSBpbml0UmVzcG9uc2Uoe1xuXHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdGluZm8sXG5cdFx0XHRyZXNwb25zZU1ldGE6IG9wdHMucmVzcG9uc2VNZXRhLFxuXHRcdFx0dW50cmFuc2Zvcm1lZEpTT046IHJlc3VsdEFzUlBDUmVzcG9uc2UsXG5cdFx0XHRlcnJvcnMsXG5cdFx0XHRoZWFkZXJzXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1UUlBDUmVzcG9uc2UoY29uZmlnLCByZXN1bHRBc1JQQ1Jlc3BvbnNlKSksIHtcblx0XHRcdHN0YXR1czogaGVhZFJlc3BvbnNlLnN0YXR1cyxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRjb25zdCBbX2luZm9FcnJvciwgaW5mb10gPSBpbmZvVHVwbGU7XG5cdFx0Y29uc3QgY3R4ID0gY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCk7XG5cdFx0Y29uc3QgeyBlcnJvciwgdW50cmFuc2Zvcm1lZEpTT04sIGJvZHkgfSA9IGNhdWdodEVycm9yVG9EYXRhKGNhdXNlLCB7XG5cdFx0XHRvcHRzLFxuXHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdHR5cGU6IGluZm8/LnR5cGUgPz8gXCJ1bmtub3duXCJcblx0XHR9KTtcblx0XHRjb25zdCBoZWFkUmVzcG9uc2UgPSBpbml0UmVzcG9uc2Uoe1xuXHRcdFx0Y3R4LFxuXHRcdFx0aW5mbyxcblx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHR1bnRyYW5zZm9ybWVkSlNPTixcblx0XHRcdGVycm9yczogW2Vycm9yXSxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcblx0XHRcdHN0YXR1czogaGVhZFJlc3BvbnNlLnN0YXR1cyxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0fVxufVxuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IFVucHJvbWlzZSwgX19jb21tb25KUywgX190b0VTTSwgY3JlYXRlRGVmZXJyZWQsIGdldFJlcXVlc3RJbmZvLCBpc0Fib3J0RXJyb3IsIGlzUHJvbWlzZSwgaXRlcmF0b3JSZXNvdXJjZSwganNvbmxTdHJlYW1Db25zdW1lciwganNvbmxTdHJlYW1Qcm9kdWNlciwgbWFrZUFzeW5jUmVzb3VyY2UsIG1ha2VSZXNvdXJjZSwgcGFyc2VDb25uZWN0aW9uUGFyYW1zRnJvbVN0cmluZywgcGFyc2VDb25uZWN0aW9uUGFyYW1zRnJvbVVua25vd24sIHJlcXVpcmVfdXNpbmdDdHgsIHJlc29sdmVSZXNwb25zZSwgc3NlSGVhZGVycywgc3NlU3RyZWFtQ29uc3VtZXIsIHNzZVN0cmVhbVByb2R1Y2VyLCB0YWtlV2l0aEdyYWNlLCB0aHJvd0Fib3J0RXJyb3IsIHdpdGhNYXhEdXJhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZVJlc3BvbnNlLURQYllnSkRELm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-DPbYgJDD.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPCError: () => (/* binding */ TRPCError),\n/* harmony export */   callProcedure: () => (/* binding */ callProcedure),\n/* harmony export */   createCallerFactory: () => (/* binding */ createCallerFactory),\n/* harmony export */   createRouterFactory: () => (/* binding */ createRouterFactory),\n/* harmony export */   defaultFormatter: () => (/* binding */ defaultFormatter),\n/* harmony export */   defaultTransformer: () => (/* binding */ defaultTransformer),\n/* harmony export */   getCauseFromUnknown: () => (/* binding */ getCauseFromUnknown),\n/* harmony export */   getDataTransformer: () => (/* binding */ getDataTransformer),\n/* harmony export */   getProcedureAtPath: () => (/* binding */ getProcedureAtPath),\n/* harmony export */   getTRPCErrorFromUnknown: () => (/* binding */ getTRPCErrorFromUnknown),\n/* harmony export */   isTrackedEnvelope: () => (/* binding */ isTrackedEnvelope),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   mergeRouters: () => (/* binding */ mergeRouters),\n/* harmony export */   sse: () => (/* binding */ sse),\n/* harmony export */   tracked: () => (/* binding */ tracked),\n/* harmony export */   transformResult: () => (/* binding */ transformResult),\n/* harmony export */   transformTRPCResponse: () => (/* binding */ transformTRPCResponse)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getErrorShape-DyYil4aT.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs\");\n/* harmony import */ var _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-BHZJcBRv.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\");\n\n\n\n//#region src/unstable-core-do-not-import/error/formatter.ts\nconst defaultFormatter = ({ shape }) => {\n\treturn shape;\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/error/TRPCError.ts\nvar UnknownCauseError = class extends Error {};\nfunction getCauseFromUnknown(cause) {\n\tif (cause instanceof Error) return cause;\n\tconst type = typeof cause;\n\tif (type === \"undefined\" || type === \"function\" || cause === null) return void 0;\n\tif (type !== \"object\") return new Error(String(cause));\n\tif ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(cause)) return Object.assign(new UnknownCauseError(), cause);\n\treturn void 0;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n\tif (cause instanceof TRPCError) return cause;\n\tif (cause instanceof Error && cause.name === \"TRPCError\") return cause;\n\tconst trpcError = new TRPCError({\n\t\tcode: \"INTERNAL_SERVER_ERROR\",\n\t\tcause\n\t});\n\tif (cause instanceof Error && cause.stack) trpcError.stack = cause.stack;\n\treturn trpcError;\n}\nvar TRPCError = class extends Error {\n\tcause;\n\tcode;\n\tconstructor(opts) {\n\t\tconst cause = getCauseFromUnknown(opts.cause);\n\t\tconst message = opts.message ?? cause?.message ?? opts.code;\n\t\tsuper(message, { cause });\n\t\tthis.code = opts.code;\n\t\tthis.name = \"TRPCError\";\n\t\tthis.cause ??= cause;\n\t}\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/transformer.ts\n/**\n* @internal\n*/\nfunction getDataTransformer(transformer) {\n\tif (\"input\" in transformer) return transformer;\n\treturn {\n\t\tinput: transformer,\n\t\toutput: transformer\n\t};\n}\n/**\n* @internal\n*/\nconst defaultTransformer = {\n\tinput: {\n\t\tserialize: (obj) => obj,\n\t\tdeserialize: (obj) => obj\n\t},\n\toutput: {\n\t\tserialize: (obj) => obj,\n\t\tdeserialize: (obj) => obj\n\t}\n};\nfunction transformTRPCResponseItem(config, item) {\n\tif (\"error\" in item) return {\n\t\t...item,\n\t\terror: config.transformer.output.serialize(item.error)\n\t};\n\tif (\"data\" in item.result) return {\n\t\t...item,\n\t\tresult: {\n\t\t\t...item.result,\n\t\t\tdata: config.transformer.output.serialize(item.result.data)\n\t\t}\n\t};\n\treturn item;\n}\n/**\n* Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n**/\nfunction transformTRPCResponse(config, itemOrItems) {\n\treturn Array.isArray(itemOrItems) ? itemOrItems.map((item) => transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n/** @internal */\nfunction transformResultInner(response, transformer) {\n\tif (\"error\" in response) {\n\t\tconst error = transformer.deserialize(response.error);\n\t\treturn {\n\t\t\tok: false,\n\t\t\terror: {\n\t\t\t\t...response,\n\t\t\t\terror\n\t\t\t}\n\t\t};\n\t}\n\tconst result = {\n\t\t...response.result,\n\t\t...(!response.result.type || response.result.type === \"data\") && {\n\t\t\ttype: \"data\",\n\t\t\tdata: transformer.deserialize(response.result.data)\n\t\t}\n\t};\n\treturn {\n\t\tok: true,\n\t\tresult\n\t};\n}\nvar TransformResultError = class extends Error {\n\tconstructor() {\n\t\tsuper(\"Unable to transform response from server\");\n\t}\n};\n/**\n* Transforms and validates that the result is a valid TRPCResponse\n* @internal\n*/\nfunction transformResult(response, transformer) {\n\tlet result;\n\ttry {\n\t\tresult = transformResultInner(response, transformer);\n\t} catch {\n\t\tthrow new TransformResultError();\n\t}\n\tif (!result.ok && (!(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(result.error.error) || typeof result.error.error[\"code\"] !== \"number\")) throw new TransformResultError();\n\tif (result.ok && !(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(result.result)) throw new TransformResultError();\n\treturn result;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/router.ts\nconst lazySymbol = Symbol(\"lazy\");\nfunction once(fn) {\n\tconst uncalled = Symbol();\n\tlet result = uncalled;\n\treturn () => {\n\t\tif (result === uncalled) result = fn();\n\t\treturn result;\n\t};\n}\n/**\n* Lazy load a router\n* @see https://trpc.io/docs/server/merging-routers#lazy-load\n*/\nfunction lazy(importRouter) {\n\tasync function resolve() {\n\t\tconst mod = await importRouter();\n\t\tif (isRouter(mod)) return mod;\n\t\tconst routers = Object.values(mod);\n\t\tif (routers.length !== 1 || !isRouter(routers[0])) throw new Error(\"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\");\n\t\treturn routers[0];\n\t}\n\tresolve[lazySymbol] = true;\n\treturn resolve;\n}\nfunction isLazy(input) {\n\treturn typeof input === \"function\" && lazySymbol in input;\n}\nfunction isRouter(value) {\n\treturn (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value[\"_def\"]) && \"router\" in value[\"_def\"];\n}\nconst emptyRouter = {\n\t_ctx: null,\n\t_errorShape: null,\n\t_meta: null,\n\tqueries: {},\n\tmutations: {},\n\tsubscriptions: {},\n\terrorFormatter: defaultFormatter,\n\ttransformer: defaultTransformer\n};\n/**\n* Reserved words that can't be used as router or procedure names\n*/\nconst reservedWords = [\n\t\"then\",\n\t\"call\",\n\t\"apply\"\n];\n/**\n* @internal\n*/\nfunction createRouterFactory(config) {\n\tfunction createRouterInner(input) {\n\t\tconst reservedWordsUsed = new Set(Object.keys(input).filter((v) => reservedWords.includes(v)));\n\t\tif (reservedWordsUsed.size > 0) throw new Error(\"Reserved words used in `router({})` call: \" + Array.from(reservedWordsUsed).join(\", \"));\n\t\tconst procedures = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.omitPrototype)({});\n\t\tconst lazy$1 = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.omitPrototype)({});\n\t\tfunction createLazyLoader(opts) {\n\t\t\treturn {\n\t\t\t\tref: opts.ref,\n\t\t\t\tload: once(async () => {\n\t\t\t\t\tconst router$1 = await opts.ref();\n\t\t\t\t\tconst lazyPath = [...opts.path, opts.key];\n\t\t\t\t\tconst lazyKey = lazyPath.join(\".\");\n\t\t\t\t\topts.aggregate[opts.key] = step(router$1._def.record, lazyPath);\n\t\t\t\t\tdelete lazy$1[lazyKey];\n\t\t\t\t\tfor (const [nestedKey, nestedItem] of Object.entries(router$1._def.lazy)) {\n\t\t\t\t\t\tconst nestedRouterKey = [...lazyPath, nestedKey].join(\".\");\n\t\t\t\t\t\tlazy$1[nestedRouterKey] = createLazyLoader({\n\t\t\t\t\t\t\tref: nestedItem.ref,\n\t\t\t\t\t\t\tpath: lazyPath,\n\t\t\t\t\t\t\tkey: nestedKey,\n\t\t\t\t\t\t\taggregate: opts.aggregate[opts.key]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t};\n\t\t}\n\t\tfunction step(from, path = []) {\n\t\t\tconst aggregate = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.omitPrototype)({});\n\t\t\tfor (const [key, item] of Object.entries(from ?? {})) {\n\t\t\t\tif (isLazy(item)) {\n\t\t\t\t\tlazy$1[[...path, key].join(\".\")] = createLazyLoader({\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tref: item,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\taggregate\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isRouter(item)) {\n\t\t\t\t\taggregate[key] = step(item._def.record, [...path, key]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!isProcedure(item)) {\n\t\t\t\t\taggregate[key] = step(item, [...path, key]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst newPath = [...path, key].join(\".\");\n\t\t\t\tif (procedures[newPath]) throw new Error(`Duplicate key: ${newPath}`);\n\t\t\t\tprocedures[newPath] = item;\n\t\t\t\taggregate[key] = item;\n\t\t\t}\n\t\t\treturn aggregate;\n\t\t}\n\t\tconst record = step(input);\n\t\tconst _def = {\n\t\t\t_config: config,\n\t\t\trouter: true,\n\t\t\tprocedures,\n\t\t\tlazy: lazy$1,\n\t\t\t...emptyRouter,\n\t\t\trecord\n\t\t};\n\t\tconst router = {\n\t\t\t...record,\n\t\t\t_def,\n\t\t\tcreateCaller: createCallerFactory()({ _def })\n\t\t};\n\t\treturn router;\n\t}\n\treturn createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n\treturn typeof procedureOrRouter === \"function\";\n}\n/**\n* @internal\n*/\nasync function getProcedureAtPath(router, path) {\n\tconst { _def } = router;\n\tlet procedure = _def.procedures[path];\n\twhile (!procedure) {\n\t\tconst key = Object.keys(_def.lazy).find((key$1) => path.startsWith(key$1));\n\t\tif (!key) return null;\n\t\tconst lazyRouter = _def.lazy[key];\n\t\tawait lazyRouter.load();\n\t\tprocedure = _def.procedures[path];\n\t}\n\treturn procedure;\n}\n/**\n* @internal\n*/\nasync function callProcedure(opts) {\n\tconst { type, path } = opts;\n\tconst proc = await getProcedureAtPath(opts.router, path);\n\tif (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) throw new TRPCError({\n\t\tcode: \"NOT_FOUND\",\n\t\tmessage: `No \"${type}\"-procedure on path \"${path}\"`\n\t});\n\t/* istanbul ignore if -- @preserve */\n\tif (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === \"subscription\") throw new TRPCError({\n\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\tmessage: `Method override is not supported for subscriptions`\n\t});\n\treturn proc(opts);\n}\nfunction createCallerFactory() {\n\treturn function createCallerInner(router) {\n\t\tconst { _def } = router;\n\t\treturn function createCaller(ctxOrCallback, opts) {\n\t\t\treturn (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_1__.createRecursiveProxy)(async ({ path, args }) => {\n\t\t\t\tconst fullPath = path.join(\".\");\n\t\t\t\tif (path.length === 1 && path[0] === \"_def\") return _def;\n\t\t\t\tconst procedure = await getProcedureAtPath(router, fullPath);\n\t\t\t\tlet ctx = void 0;\n\t\t\t\ttry {\n\t\t\t\t\tif (!procedure) throw new TRPCError({\n\t\t\t\t\t\tcode: \"NOT_FOUND\",\n\t\t\t\t\t\tmessage: `No procedure found on path \"${path}\"`\n\t\t\t\t\t});\n\t\t\t\t\tctx = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n\t\t\t\t\treturn await procedure({\n\t\t\t\t\t\tpath: fullPath,\n\t\t\t\t\t\tgetRawInput: async () => args[0],\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\ttype: procedure._def.type,\n\t\t\t\t\t\tsignal: opts?.signal\n\t\t\t\t\t});\n\t\t\t\t} catch (cause) {\n\t\t\t\t\topts?.onError?.({\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\terror: getTRPCErrorFromUnknown(cause),\n\t\t\t\t\t\tinput: args[0],\n\t\t\t\t\t\tpath: fullPath,\n\t\t\t\t\t\ttype: procedure?._def.type ?? \"unknown\"\n\t\t\t\t\t});\n\t\t\t\t\tthrow cause;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n}\nfunction mergeRouters(...routerList) {\n\tconst record = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.mergeWithoutOverrides)({}, ...routerList.map((r) => r._def.record));\n\tconst errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {\n\t\tif (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n\t\t\tif (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) throw new Error(\"You seem to have several error formatters\");\n\t\t\treturn nextRouter._def._config.errorFormatter;\n\t\t}\n\t\treturn currentErrorFormatter;\n\t}, defaultFormatter);\n\tconst transformer = routerList.reduce((prev, current) => {\n\t\tif (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n\t\t\tif (prev !== defaultTransformer && prev !== current._def._config.transformer) throw new Error(\"You seem to have several transformers\");\n\t\t\treturn current._def._config.transformer;\n\t\t}\n\t\treturn prev;\n\t}, defaultTransformer);\n\tconst router = createRouterFactory({\n\t\terrorFormatter,\n\t\ttransformer,\n\t\tisDev: routerList.every((r) => r._def._config.isDev),\n\t\tallowOutsideOfServer: routerList.every((r) => r._def._config.allowOutsideOfServer),\n\t\tisServer: routerList.every((r) => r._def._config.isServer),\n\t\t$types: routerList[0]?._def._config.$types\n\t})(record);\n\treturn router;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/tracked.ts\nconst trackedSymbol = Symbol();\n/**\n* Produce a typed server-sent event message\n* @deprecated use `tracked(id, data)` instead\n*/\nfunction sse(event) {\n\treturn tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n\treturn Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n* Automatically track an event so that it can be resumed from a given id if the connection is lost\n*/\nfunction tracked(id, data) {\n\tif (id === \"\") throw new Error(\"`id` must not be an empty string as empty string is the same as not setting the id at all\");\n\treturn [\n\t\tid,\n\t\tdata,\n\t\ttrackedSymbol\n\t];\n}\n\n//#endregion\n\n//# sourceMappingURL=tracked-GEWPoL0C.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC90cmFja2VkLUdFV1BvTDBDLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQzhCOztBQUVsRztBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkRBQVE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLDZEQUFRO0FBQzdCLG1CQUFtQiw2REFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQVEsV0FBVyw2REFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRixxQkFBcUIsa0VBQWEsR0FBRztBQUNyQyxpQkFBaUIsa0VBQWEsR0FBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0VBQWEsR0FBRztBQUNyQyxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsUUFBUTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssdUJBQXVCLEtBQUs7QUFDbkQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsVUFBVSxpRkFBb0IsVUFBVSxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsTUFBTTtBQUNOLFdBQVcsK0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwRUFBcUIsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3VTO0FBQ3ZTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC90cmFja2VkLUdFV1BvTDBDLm1qcz9jOTY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlY3Vyc2l2ZVByb3h5IH0gZnJvbSBcIi4vZ2V0RXJyb3JTaGFwZS1EeVlpbDRhVC5tanNcIjtcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBtZXJnZVdpdGhvdXRPdmVycmlkZXMsIG9taXRQcm90b3R5cGUgfSBmcm9tIFwiLi91dGlscy1CSFpKY0JSdi5tanNcIjtcblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvZXJyb3IvZm9ybWF0dGVyLnRzXG5jb25zdCBkZWZhdWx0Rm9ybWF0dGVyID0gKHsgc2hhcGUgfSkgPT4ge1xuXHRyZXR1cm4gc2hhcGU7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2Vycm9yL1RSUENFcnJvci50c1xudmFyIFVua25vd25DYXVzZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7fTtcbmZ1bmN0aW9uIGdldENhdXNlRnJvbVVua25vd24oY2F1c2UpIHtcblx0aWYgKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBjYXVzZTtcblx0Y29uc3QgdHlwZSA9IHR5cGVvZiBjYXVzZTtcblx0aWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGNhdXNlID09PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuXHRpZiAodHlwZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcoY2F1c2UpKTtcblx0aWYgKGlzT2JqZWN0KGNhdXNlKSkgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFVua25vd25DYXVzZUVycm9yKCksIGNhdXNlKTtcblx0cmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKSB7XG5cdGlmIChjYXVzZSBpbnN0YW5jZW9mIFRSUENFcnJvcikgcmV0dXJuIGNhdXNlO1xuXHRpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5uYW1lID09PSBcIlRSUENFcnJvclwiKSByZXR1cm4gY2F1c2U7XG5cdGNvbnN0IHRycGNFcnJvciA9IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG5cdFx0Y2F1c2Vcblx0fSk7XG5cdGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yICYmIGNhdXNlLnN0YWNrKSB0cnBjRXJyb3Iuc3RhY2sgPSBjYXVzZS5zdGFjaztcblx0cmV0dXJuIHRycGNFcnJvcjtcbn1cbnZhciBUUlBDRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y2F1c2U7XG5cdGNvZGU7XG5cdGNvbnN0cnVjdG9yKG9wdHMpIHtcblx0XHRjb25zdCBjYXVzZSA9IGdldENhdXNlRnJvbVVua25vd24ob3B0cy5jYXVzZSk7XG5cdFx0Y29uc3QgbWVzc2FnZSA9IG9wdHMubWVzc2FnZSA/PyBjYXVzZT8ubWVzc2FnZSA/PyBvcHRzLmNvZGU7XG5cdFx0c3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcblx0XHR0aGlzLmNvZGUgPSBvcHRzLmNvZGU7XG5cdFx0dGhpcy5uYW1lID0gXCJUUlBDRXJyb3JcIjtcblx0XHR0aGlzLmNhdXNlID8/PSBjYXVzZTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC90cmFuc2Zvcm1lci50c1xuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGdldERhdGFUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lcikge1xuXHRpZiAoXCJpbnB1dFwiIGluIHRyYW5zZm9ybWVyKSByZXR1cm4gdHJhbnNmb3JtZXI7XG5cdHJldHVybiB7XG5cdFx0aW5wdXQ6IHRyYW5zZm9ybWVyLFxuXHRcdG91dHB1dDogdHJhbnNmb3JtZXJcblx0fTtcbn1cbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5jb25zdCBkZWZhdWx0VHJhbnNmb3JtZXIgPSB7XG5cdGlucHV0OiB7XG5cdFx0c2VyaWFsaXplOiAob2JqKSA9PiBvYmosXG5cdFx0ZGVzZXJpYWxpemU6IChvYmopID0+IG9ialxuXHR9LFxuXHRvdXRwdXQ6IHtcblx0XHRzZXJpYWxpemU6IChvYmopID0+IG9iaixcblx0XHRkZXNlcmlhbGl6ZTogKG9iaikgPT4gb2JqXG5cdH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbSkge1xuXHRpZiAoXCJlcnJvclwiIGluIGl0ZW0pIHJldHVybiB7XG5cdFx0Li4uaXRlbSxcblx0XHRlcnJvcjogY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoaXRlbS5lcnJvcilcblx0fTtcblx0aWYgKFwiZGF0YVwiIGluIGl0ZW0ucmVzdWx0KSByZXR1cm4ge1xuXHRcdC4uLml0ZW0sXG5cdFx0cmVzdWx0OiB7XG5cdFx0XHQuLi5pdGVtLnJlc3VsdCxcblx0XHRcdGRhdGE6IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKGl0ZW0ucmVzdWx0LmRhdGEpXG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gaXRlbTtcbn1cbi8qKlxuKiBUYWtlcyBhIHVuc2VyaWFsaXplZCBgVFJQQ1Jlc3BvbnNlYCBhbmQgc2VyaWFsaXplcyBpdCB3aXRoIHRoZSByb3V0ZXIncyB0cmFuc2Zvcm1lcnNcbioqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKGNvbmZpZywgaXRlbU9ySXRlbXMpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbU9ySXRlbXMpID8gaXRlbU9ySXRlbXMubWFwKChpdGVtKSA9PiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbSkpIDogdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlSXRlbShjb25maWcsIGl0ZW1Pckl0ZW1zKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCB0cmFuc2Zvcm1lcikge1xuXHRpZiAoXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSB0cmFuc2Zvcm1lci5kZXNlcmlhbGl6ZShyZXNwb25zZS5lcnJvcik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG9rOiBmYWxzZSxcblx0XHRcdGVycm9yOiB7XG5cdFx0XHRcdC4uLnJlc3BvbnNlLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdC4uLnJlc3BvbnNlLnJlc3VsdCxcblx0XHQuLi4oIXJlc3BvbnNlLnJlc3VsdC50eXBlIHx8IHJlc3BvbnNlLnJlc3VsdC50eXBlID09PSBcImRhdGFcIikgJiYge1xuXHRcdFx0dHlwZTogXCJkYXRhXCIsXG5cdFx0XHRkYXRhOiB0cmFuc2Zvcm1lci5kZXNlcmlhbGl6ZShyZXNwb25zZS5yZXN1bHQuZGF0YSlcblx0XHR9XG5cdH07XG5cdHJldHVybiB7XG5cdFx0b2s6IHRydWUsXG5cdFx0cmVzdWx0XG5cdH07XG59XG52YXIgVHJhbnNmb3JtUmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoXCJVbmFibGUgdG8gdHJhbnNmb3JtIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuXHR9XG59O1xuLyoqXG4qIFRyYW5zZm9ybXMgYW5kIHZhbGlkYXRlcyB0aGF0IHRoZSByZXN1bHQgaXMgYSB2YWxpZCBUUlBDUmVzcG9uc2VcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gdHJhbnNmb3JtUmVzdWx0KHJlc3BvbnNlLCB0cmFuc2Zvcm1lcikge1xuXHRsZXQgcmVzdWx0O1xuXHR0cnkge1xuXHRcdHJlc3VsdCA9IHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCB0cmFuc2Zvcm1lcik7XG5cdH0gY2F0Y2gge1xuXHRcdHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuXHR9XG5cdGlmICghcmVzdWx0Lm9rICYmICghaXNPYmplY3QocmVzdWx0LmVycm9yLmVycm9yKSB8fCB0eXBlb2YgcmVzdWx0LmVycm9yLmVycm9yW1wiY29kZVwiXSAhPT0gXCJudW1iZXJcIikpIHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuXHRpZiAocmVzdWx0Lm9rICYmICFpc09iamVjdChyZXN1bHQucmVzdWx0KSkgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcm91dGVyLnRzXG5jb25zdCBsYXp5U3ltYm9sID0gU3ltYm9sKFwibGF6eVwiKTtcbmZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0Y29uc3QgdW5jYWxsZWQgPSBTeW1ib2woKTtcblx0bGV0IHJlc3VsdCA9IHVuY2FsbGVkO1xuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChyZXN1bHQgPT09IHVuY2FsbGVkKSByZXN1bHQgPSBmbigpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59XG4vKipcbiogTGF6eSBsb2FkIGEgcm91dGVyXG4qIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3Mvc2VydmVyL21lcmdpbmctcm91dGVycyNsYXp5LWxvYWRcbiovXG5mdW5jdGlvbiBsYXp5KGltcG9ydFJvdXRlcikge1xuXHRhc3luYyBmdW5jdGlvbiByZXNvbHZlKCkge1xuXHRcdGNvbnN0IG1vZCA9IGF3YWl0IGltcG9ydFJvdXRlcigpO1xuXHRcdGlmIChpc1JvdXRlcihtb2QpKSByZXR1cm4gbW9kO1xuXHRcdGNvbnN0IHJvdXRlcnMgPSBPYmplY3QudmFsdWVzKG1vZCk7XG5cdFx0aWYgKHJvdXRlcnMubGVuZ3RoICE9PSAxIHx8ICFpc1JvdXRlcihyb3V0ZXJzWzBdKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3V0ZXIgbW9kdWxlIC0gZWl0aGVyIGRlZmluZSBleGFjdGx5IDEgZXhwb3J0IG9yIHJldHVybiB0aGUgcm91dGVyIGRpcmVjdGx5LlxcbkV4YW1wbGU6IGBsYXp5KCgpID0+IGltcG9ydCgnLi9zbG93LmpzJykudGhlbigobSkgPT4gbS5zbG93Um91dGVyKSlgXCIpO1xuXHRcdHJldHVybiByb3V0ZXJzWzBdO1xuXHR9XG5cdHJlc29sdmVbbGF6eVN5bWJvbF0gPSB0cnVlO1xuXHRyZXR1cm4gcmVzb2x2ZTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShpbnB1dCkge1xuXHRyZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcImZ1bmN0aW9uXCIgJiYgbGF6eVN5bWJvbCBpbiBpbnB1dDtcbn1cbmZ1bmN0aW9uIGlzUm91dGVyKHZhbHVlKSB7XG5cdHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgaXNPYmplY3QodmFsdWVbXCJfZGVmXCJdKSAmJiBcInJvdXRlclwiIGluIHZhbHVlW1wiX2RlZlwiXTtcbn1cbmNvbnN0IGVtcHR5Um91dGVyID0ge1xuXHRfY3R4OiBudWxsLFxuXHRfZXJyb3JTaGFwZTogbnVsbCxcblx0X21ldGE6IG51bGwsXG5cdHF1ZXJpZXM6IHt9LFxuXHRtdXRhdGlvbnM6IHt9LFxuXHRzdWJzY3JpcHRpb25zOiB7fSxcblx0ZXJyb3JGb3JtYXR0ZXI6IGRlZmF1bHRGb3JtYXR0ZXIsXG5cdHRyYW5zZm9ybWVyOiBkZWZhdWx0VHJhbnNmb3JtZXJcbn07XG4vKipcbiogUmVzZXJ2ZWQgd29yZHMgdGhhdCBjYW4ndCBiZSB1c2VkIGFzIHJvdXRlciBvciBwcm9jZWR1cmUgbmFtZXNcbiovXG5jb25zdCByZXNlcnZlZFdvcmRzID0gW1xuXHRcInRoZW5cIixcblx0XCJjYWxsXCIsXG5cdFwiYXBwbHlcIlxuXTtcbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJGYWN0b3J5KGNvbmZpZykge1xuXHRmdW5jdGlvbiBjcmVhdGVSb3V0ZXJJbm5lcihpbnB1dCkge1xuXHRcdGNvbnN0IHJlc2VydmVkV29yZHNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhpbnB1dCkuZmlsdGVyKCh2KSA9PiByZXNlcnZlZFdvcmRzLmluY2x1ZGVzKHYpKSk7XG5cdFx0aWYgKHJlc2VydmVkV29yZHNVc2VkLnNpemUgPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNlcnZlZCB3b3JkcyB1c2VkIGluIGByb3V0ZXIoe30pYCBjYWxsOiBcIiArIEFycmF5LmZyb20ocmVzZXJ2ZWRXb3Jkc1VzZWQpLmpvaW4oXCIsIFwiKSk7XG5cdFx0Y29uc3QgcHJvY2VkdXJlcyA9IG9taXRQcm90b3R5cGUoe30pO1xuXHRcdGNvbnN0IGxhenkkMSA9IG9taXRQcm90b3R5cGUoe30pO1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUxhenlMb2FkZXIob3B0cykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cmVmOiBvcHRzLnJlZixcblx0XHRcdFx0bG9hZDogb25jZShhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgcm91dGVyJDEgPSBhd2FpdCBvcHRzLnJlZigpO1xuXHRcdFx0XHRcdGNvbnN0IGxhenlQYXRoID0gWy4uLm9wdHMucGF0aCwgb3B0cy5rZXldO1xuXHRcdFx0XHRcdGNvbnN0IGxhenlLZXkgPSBsYXp5UGF0aC5qb2luKFwiLlwiKTtcblx0XHRcdFx0XHRvcHRzLmFnZ3JlZ2F0ZVtvcHRzLmtleV0gPSBzdGVwKHJvdXRlciQxLl9kZWYucmVjb3JkLCBsYXp5UGF0aCk7XG5cdFx0XHRcdFx0ZGVsZXRlIGxhenkkMVtsYXp5S2V5XTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtuZXN0ZWRLZXksIG5lc3RlZEl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKHJvdXRlciQxLl9kZWYubGF6eSkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZFJvdXRlcktleSA9IFsuLi5sYXp5UGF0aCwgbmVzdGVkS2V5XS5qb2luKFwiLlwiKTtcblx0XHRcdFx0XHRcdGxhenkkMVtuZXN0ZWRSb3V0ZXJLZXldID0gY3JlYXRlTGF6eUxvYWRlcih7XG5cdFx0XHRcdFx0XHRcdHJlZjogbmVzdGVkSXRlbS5yZWYsXG5cdFx0XHRcdFx0XHRcdHBhdGg6IGxhenlQYXRoLFxuXHRcdFx0XHRcdFx0XHRrZXk6IG5lc3RlZEtleSxcblx0XHRcdFx0XHRcdFx0YWdncmVnYXRlOiBvcHRzLmFnZ3JlZ2F0ZVtvcHRzLmtleV1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHN0ZXAoZnJvbSwgcGF0aCA9IFtdKSB7XG5cdFx0XHRjb25zdCBhZ2dyZWdhdGUgPSBvbWl0UHJvdG90eXBlKHt9KTtcblx0XHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXMoZnJvbSA/PyB7fSkpIHtcblx0XHRcdFx0aWYgKGlzTGF6eShpdGVtKSkge1xuXHRcdFx0XHRcdGxhenkkMVtbLi4ucGF0aCwga2V5XS5qb2luKFwiLlwiKV0gPSBjcmVhdGVMYXp5TG9hZGVyKHtcblx0XHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0XHRyZWY6IGl0ZW0sXG5cdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRhZ2dyZWdhdGVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNSb3V0ZXIoaXRlbSkpIHtcblx0XHRcdFx0XHRhZ2dyZWdhdGVba2V5XSA9IHN0ZXAoaXRlbS5fZGVmLnJlY29yZCwgWy4uLnBhdGgsIGtleV0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNQcm9jZWR1cmUoaXRlbSkpIHtcblx0XHRcdFx0XHRhZ2dyZWdhdGVba2V5XSA9IHN0ZXAoaXRlbSwgWy4uLnBhdGgsIGtleV0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IG5ld1BhdGggPSBbLi4ucGF0aCwga2V5XS5qb2luKFwiLlwiKTtcblx0XHRcdFx0aWYgKHByb2NlZHVyZXNbbmV3UGF0aF0pIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGtleTogJHtuZXdQYXRofWApO1xuXHRcdFx0XHRwcm9jZWR1cmVzW25ld1BhdGhdID0gaXRlbTtcblx0XHRcdFx0YWdncmVnYXRlW2tleV0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFnZ3JlZ2F0ZTtcblx0XHR9XG5cdFx0Y29uc3QgcmVjb3JkID0gc3RlcChpbnB1dCk7XG5cdFx0Y29uc3QgX2RlZiA9IHtcblx0XHRcdF9jb25maWc6IGNvbmZpZyxcblx0XHRcdHJvdXRlcjogdHJ1ZSxcblx0XHRcdHByb2NlZHVyZXMsXG5cdFx0XHRsYXp5OiBsYXp5JDEsXG5cdFx0XHQuLi5lbXB0eVJvdXRlcixcblx0XHRcdHJlY29yZFxuXHRcdH07XG5cdFx0Y29uc3Qgcm91dGVyID0ge1xuXHRcdFx0Li4ucmVjb3JkLFxuXHRcdFx0X2RlZixcblx0XHRcdGNyZWF0ZUNhbGxlcjogY3JlYXRlQ2FsbGVyRmFjdG9yeSgpKHsgX2RlZiB9KVxuXHRcdH07XG5cdFx0cmV0dXJuIHJvdXRlcjtcblx0fVxuXHRyZXR1cm4gY3JlYXRlUm91dGVySW5uZXI7XG59XG5mdW5jdGlvbiBpc1Byb2NlZHVyZShwcm9jZWR1cmVPclJvdXRlcikge1xuXHRyZXR1cm4gdHlwZW9mIHByb2NlZHVyZU9yUm91dGVyID09PSBcImZ1bmN0aW9uXCI7XG59XG4vKipcbiogQGludGVybmFsXG4qL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvY2VkdXJlQXRQYXRoKHJvdXRlciwgcGF0aCkge1xuXHRjb25zdCB7IF9kZWYgfSA9IHJvdXRlcjtcblx0bGV0IHByb2NlZHVyZSA9IF9kZWYucHJvY2VkdXJlc1twYXRoXTtcblx0d2hpbGUgKCFwcm9jZWR1cmUpIHtcblx0XHRjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhfZGVmLmxhenkpLmZpbmQoKGtleSQxKSA9PiBwYXRoLnN0YXJ0c1dpdGgoa2V5JDEpKTtcblx0XHRpZiAoIWtleSkgcmV0dXJuIG51bGw7XG5cdFx0Y29uc3QgbGF6eVJvdXRlciA9IF9kZWYubGF6eVtrZXldO1xuXHRcdGF3YWl0IGxhenlSb3V0ZXIubG9hZCgpO1xuXHRcdHByb2NlZHVyZSA9IF9kZWYucHJvY2VkdXJlc1twYXRoXTtcblx0fVxuXHRyZXR1cm4gcHJvY2VkdXJlO1xufVxuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmFzeW5jIGZ1bmN0aW9uIGNhbGxQcm9jZWR1cmUob3B0cykge1xuXHRjb25zdCB7IHR5cGUsIHBhdGggfSA9IG9wdHM7XG5cdGNvbnN0IHByb2MgPSBhd2FpdCBnZXRQcm9jZWR1cmVBdFBhdGgob3B0cy5yb3V0ZXIsIHBhdGgpO1xuXHRpZiAoIXByb2MgfHwgIWlzUHJvY2VkdXJlKHByb2MpIHx8IHByb2MuX2RlZi50eXBlICE9PSB0eXBlICYmICFvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdGNvZGU6IFwiTk9UX0ZPVU5EXCIsXG5cdFx0bWVzc2FnZTogYE5vIFwiJHt0eXBlfVwiLXByb2NlZHVyZSBvbiBwYXRoIFwiJHtwYXRofVwiYFxuXHR9KTtcblx0LyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuXHRpZiAocHJvYy5fZGVmLnR5cGUgIT09IHR5cGUgJiYgb3B0cy5hbGxvd01ldGhvZE92ZXJyaWRlICYmIHByb2MuX2RlZi50eXBlID09PSBcInN1YnNjcmlwdGlvblwiKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRjb2RlOiBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCIsXG5cdFx0bWVzc2FnZTogYE1ldGhvZCBvdmVycmlkZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdWJzY3JpcHRpb25zYFxuXHR9KTtcblx0cmV0dXJuIHByb2Mob3B0cyk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsZXJGYWN0b3J5KCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ2FsbGVySW5uZXIocm91dGVyKSB7XG5cdFx0Y29uc3QgeyBfZGVmIH0gPSByb3V0ZXI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNhbGxlcihjdHhPckNhbGxiYWNrLCBvcHRzKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUmVjdXJzaXZlUHJveHkoYXN5bmMgKHsgcGF0aCwgYXJncyB9KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKFwiLlwiKTtcblx0XHRcdFx0aWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHBhdGhbMF0gPT09IFwiX2RlZlwiKSByZXR1cm4gX2RlZjtcblx0XHRcdFx0Y29uc3QgcHJvY2VkdXJlID0gYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKHJvdXRlciwgZnVsbFBhdGgpO1xuXHRcdFx0XHRsZXQgY3R4ID0gdm9pZCAwO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghcHJvY2VkdXJlKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdGNvZGU6IFwiTk9UX0ZPVU5EXCIsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBgTm8gcHJvY2VkdXJlIGZvdW5kIG9uIHBhdGggXCIke3BhdGh9XCJgXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y3R4ID0gaXNGdW5jdGlvbihjdHhPckNhbGxiYWNrKSA/IGF3YWl0IFByb21pc2UucmVzb2x2ZShjdHhPckNhbGxiYWNrKCkpIDogY3R4T3JDYWxsYmFjaztcblx0XHRcdFx0XHRyZXR1cm4gYXdhaXQgcHJvY2VkdXJlKHtcblx0XHRcdFx0XHRcdHBhdGg6IGZ1bGxQYXRoLFxuXHRcdFx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGFzeW5jICgpID0+IGFyZ3NbMF0sXG5cdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHR0eXBlOiBwcm9jZWR1cmUuX2RlZi50eXBlLFxuXHRcdFx0XHRcdFx0c2lnbmFsOiBvcHRzPy5zaWduYWxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0XHRvcHRzPy5vbkVycm9yPy4oe1xuXHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKSxcblx0XHRcdFx0XHRcdGlucHV0OiBhcmdzWzBdLFxuXHRcdFx0XHRcdFx0cGF0aDogZnVsbFBhdGgsXG5cdFx0XHRcdFx0XHR0eXBlOiBwcm9jZWR1cmU/Ll9kZWYudHlwZSA/PyBcInVua25vd25cIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRocm93IGNhdXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9O1xufVxuZnVuY3Rpb24gbWVyZ2VSb3V0ZXJzKC4uLnJvdXRlckxpc3QpIHtcblx0Y29uc3QgcmVjb3JkID0gbWVyZ2VXaXRob3V0T3ZlcnJpZGVzKHt9LCAuLi5yb3V0ZXJMaXN0Lm1hcCgocikgPT4gci5fZGVmLnJlY29yZCkpO1xuXHRjb25zdCBlcnJvckZvcm1hdHRlciA9IHJvdXRlckxpc3QucmVkdWNlKChjdXJyZW50RXJyb3JGb3JtYXR0ZXIsIG5leHRSb3V0ZXIpID0+IHtcblx0XHRpZiAobmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIgJiYgbmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIgIT09IGRlZmF1bHRGb3JtYXR0ZXIpIHtcblx0XHRcdGlmIChjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IGRlZmF1bHRGb3JtYXR0ZXIgJiYgY3VycmVudEVycm9yRm9ybWF0dGVyICE9PSBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlcikgdGhyb3cgbmV3IEVycm9yKFwiWW91IHNlZW0gdG8gaGF2ZSBzZXZlcmFsIGVycm9yIGZvcm1hdHRlcnNcIik7XG5cdFx0XHRyZXR1cm4gbmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXI7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJyZW50RXJyb3JGb3JtYXR0ZXI7XG5cdH0sIGRlZmF1bHRGb3JtYXR0ZXIpO1xuXHRjb25zdCB0cmFuc2Zvcm1lciA9IHJvdXRlckxpc3QucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG5cdFx0aWYgKGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyICYmIGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyICE9PSBkZWZhdWx0VHJhbnNmb3JtZXIpIHtcblx0XHRcdGlmIChwcmV2ICE9PSBkZWZhdWx0VHJhbnNmb3JtZXIgJiYgcHJldiAhPT0gY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIpIHRocm93IG5ldyBFcnJvcihcIllvdSBzZWVtIHRvIGhhdmUgc2V2ZXJhbCB0cmFuc2Zvcm1lcnNcIik7XG5cdFx0XHRyZXR1cm4gY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXI7XG5cdFx0fVxuXHRcdHJldHVybiBwcmV2O1xuXHR9LCBkZWZhdWx0VHJhbnNmb3JtZXIpO1xuXHRjb25zdCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXJGYWN0b3J5KHtcblx0XHRlcnJvckZvcm1hdHRlcixcblx0XHR0cmFuc2Zvcm1lcixcblx0XHRpc0Rldjogcm91dGVyTGlzdC5ldmVyeSgocikgPT4gci5fZGVmLl9jb25maWcuaXNEZXYpLFxuXHRcdGFsbG93T3V0c2lkZU9mU2VydmVyOiByb3V0ZXJMaXN0LmV2ZXJ5KChyKSA9PiByLl9kZWYuX2NvbmZpZy5hbGxvd091dHNpZGVPZlNlcnZlciksXG5cdFx0aXNTZXJ2ZXI6IHJvdXRlckxpc3QuZXZlcnkoKHIpID0+IHIuX2RlZi5fY29uZmlnLmlzU2VydmVyKSxcblx0XHQkdHlwZXM6IHJvdXRlckxpc3RbMF0/Ll9kZWYuX2NvbmZpZy4kdHlwZXNcblx0fSkocmVjb3JkKTtcblx0cmV0dXJuIHJvdXRlcjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdHJhY2tlZC50c1xuY29uc3QgdHJhY2tlZFN5bWJvbCA9IFN5bWJvbCgpO1xuLyoqXG4qIFByb2R1Y2UgYSB0eXBlZCBzZXJ2ZXItc2VudCBldmVudCBtZXNzYWdlXG4qIEBkZXByZWNhdGVkIHVzZSBgdHJhY2tlZChpZCwgZGF0YSlgIGluc3RlYWRcbiovXG5mdW5jdGlvbiBzc2UoZXZlbnQpIHtcblx0cmV0dXJuIHRyYWNrZWQoZXZlbnQuaWQsIGV2ZW50LmRhdGEpO1xufVxuZnVuY3Rpb24gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlWzJdID09PSB0cmFja2VkU3ltYm9sO1xufVxuLyoqXG4qIEF1dG9tYXRpY2FsbHkgdHJhY2sgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBmcm9tIGEgZ2l2ZW4gaWQgaWYgdGhlIGNvbm5lY3Rpb24gaXMgbG9zdFxuKi9cbmZ1bmN0aW9uIHRyYWNrZWQoaWQsIGRhdGEpIHtcblx0aWYgKGlkID09PSBcIlwiKSB0aHJvdyBuZXcgRXJyb3IoXCJgaWRgIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZyBhcyBlbXB0eSBzdHJpbmcgaXMgdGhlIHNhbWUgYXMgbm90IHNldHRpbmcgdGhlIGlkIGF0IGFsbFwiKTtcblx0cmV0dXJuIFtcblx0XHRpZCxcblx0XHRkYXRhLFxuXHRcdHRyYWNrZWRTeW1ib2xcblx0XTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBUUlBDRXJyb3IsIGNhbGxQcm9jZWR1cmUsIGNyZWF0ZUNhbGxlckZhY3RvcnksIGNyZWF0ZVJvdXRlckZhY3RvcnksIGRlZmF1bHRGb3JtYXR0ZXIsIGRlZmF1bHRUcmFuc2Zvcm1lciwgZ2V0Q2F1c2VGcm9tVW5rbm93biwgZ2V0RGF0YVRyYW5zZm9ybWVyLCBnZXRQcm9jZWR1cmVBdFBhdGgsIGdldFRSUENFcnJvckZyb21Vbmtub3duLCBpc1RyYWNrZWRFbnZlbG9wZSwgbGF6eSwgbWVyZ2VSb3V0ZXJzLCBzc2UsIHRyYWNrZWQsIHRyYW5zZm9ybVJlc3VsdCwgdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja2VkLUdFV1BvTDBDLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPC_ERROR_CODES_BY_KEY: () => (/* binding */ TRPC_ERROR_CODES_BY_KEY),\n/* harmony export */   TRPC_ERROR_CODES_BY_NUMBER: () => (/* binding */ TRPC_ERROR_CODES_BY_NUMBER),\n/* harmony export */   abortSignalsAnyPonyfill: () => (/* binding */ abortSignalsAnyPonyfill),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   mergeWithoutOverrides: () => (/* binding */ mergeWithoutOverrides),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   omitPrototype: () => (/* binding */ omitPrototype),\n/* harmony export */   retryableRpcCodes: () => (/* binding */ retryableRpcCodes),\n/* harmony export */   run: () => (/* binding */ run),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n//#region src/unstable-core-do-not-import/rpc/codes.ts\n/**\n* JSON-RPC 2.0 Error codes\n*\n* `-32000` to `-32099` are reserved for implementation-defined server-errors.\n* For tRPC we're copying the last digits of HTTP 4XX errors.\n*/\nconst TRPC_ERROR_CODES_BY_KEY = {\n\tPARSE_ERROR: -32700,\n\tBAD_REQUEST: -32600,\n\tINTERNAL_SERVER_ERROR: -32603,\n\tNOT_IMPLEMENTED: -32603,\n\tBAD_GATEWAY: -32603,\n\tSERVICE_UNAVAILABLE: -32603,\n\tGATEWAY_TIMEOUT: -32603,\n\tUNAUTHORIZED: -32001,\n\tPAYMENT_REQUIRED: -32002,\n\tFORBIDDEN: -32003,\n\tNOT_FOUND: -32004,\n\tMETHOD_NOT_SUPPORTED: -32005,\n\tTIMEOUT: -32008,\n\tCONFLICT: -32009,\n\tPRECONDITION_FAILED: -32012,\n\tPAYLOAD_TOO_LARGE: -32013,\n\tUNSUPPORTED_MEDIA_TYPE: -32015,\n\tUNPROCESSABLE_CONTENT: -32022,\n\tTOO_MANY_REQUESTS: -32029,\n\tCLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n\t[-32700]: \"PARSE_ERROR\",\n\t[-32600]: \"BAD_REQUEST\",\n\t[-32603]: \"INTERNAL_SERVER_ERROR\",\n\t[-32001]: \"UNAUTHORIZED\",\n\t[-32002]: \"PAYMENT_REQUIRED\",\n\t[-32003]: \"FORBIDDEN\",\n\t[-32004]: \"NOT_FOUND\",\n\t[-32005]: \"METHOD_NOT_SUPPORTED\",\n\t[-32008]: \"TIMEOUT\",\n\t[-32009]: \"CONFLICT\",\n\t[-32012]: \"PRECONDITION_FAILED\",\n\t[-32013]: \"PAYLOAD_TOO_LARGE\",\n\t[-32015]: \"UNSUPPORTED_MEDIA_TYPE\",\n\t[-32022]: \"UNPROCESSABLE_CONTENT\",\n\t[-32029]: \"TOO_MANY_REQUESTS\",\n\t[-32099]: \"CLIENT_CLOSED_REQUEST\"\n};\n/**\n* tRPC error codes that are considered retryable\n* With out of the box SSE, the client will reconnect when these errors are encountered\n*/\nconst retryableRpcCodes = [\n\tTRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n\tTRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n\tTRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n\tTRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n\n//#endregion\n//#region src/unstable-core-do-not-import/utils.ts\n/**\n* Ensures there are no duplicate keys when building a procedure.\n* @internal\n*/\nfunction mergeWithoutOverrides(obj1, ...objs) {\n\tconst newObj = Object.assign(Object.create(null), obj1);\n\tfor (const overrides of objs) for (const key in overrides) {\n\t\tif (key in newObj && newObj[key] !== overrides[key]) throw new Error(`Duplicate key ${key}`);\n\t\tnewObj[key] = overrides[key];\n\t}\n\treturn newObj;\n}\n/**\n* Check that value is object\n* @internal\n*/\nfunction isObject(value) {\n\treturn !!value && !Array.isArray(value) && typeof value === \"object\";\n}\nfunction isFunction(fn) {\n\treturn typeof fn === \"function\";\n}\n/**\n* Create an object without inheriting anything from `Object.prototype`\n* @internal\n*/\nfunction omitPrototype(obj) {\n\treturn Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === \"function\" && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n\treturn asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n* Run an IIFE\n*/\nconst run = (fn) => fn();\nfunction noop() {}\nfunction identity(it) {\n\treturn it;\n}\n/**\n* Generic runtime assertion function. Throws, if the condition is not `true`.\n*\n* Can be used as a slightly less dangerous variant of type assertions. Code\n* mistakes would be revealed at runtime then (hopefully during testing).\n*/\nfunction assert(condition, msg = \"no additional info\") {\n\tif (!condition) throw new Error(`AssertionError: ${msg}`);\n}\nfunction sleep(ms = 0) {\n\treturn new Promise((res) => setTimeout(res, ms));\n}\n/**\n* Ponyfill for\n* [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n*/\nfunction abortSignalsAnyPonyfill(signals) {\n\tif (typeof AbortSignal.any === \"function\") return AbortSignal.any(signals);\n\tconst ac = new AbortController();\n\tfor (const signal of signals) {\n\t\tif (signal.aborted) {\n\t\t\ttrigger();\n\t\t\tbreak;\n\t\t}\n\t\tsignal.addEventListener(\"abort\", trigger, { once: true });\n\t}\n\treturn ac.signal;\n\tfunction trigger() {\n\t\tac.abort();\n\t\tfor (const signal of signals) signal.removeEventListener(\"abort\", trigger);\n\t}\n}\n\n//#endregion\n\n//# sourceMappingURL=utils-BHZJcBRv.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC91dGlscy1CSFpKY0JSdi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzROO0FBQzVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC91dGlscy1CSFpKY0JSdi5tanM/YmQ3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9ycGMvY29kZXMudHNcbi8qKlxuKiBKU09OLVJQQyAyLjAgRXJyb3IgY29kZXNcbipcbiogYC0zMjAwMGAgdG8gYC0zMjA5OWAgYXJlIHJlc2VydmVkIGZvciBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHNlcnZlci1lcnJvcnMuXG4qIEZvciB0UlBDIHdlJ3JlIGNvcHlpbmcgdGhlIGxhc3QgZGlnaXRzIG9mIEhUVFAgNFhYIGVycm9ycy5cbiovXG5jb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSA9IHtcblx0UEFSU0VfRVJST1I6IC0zMjcwMCxcblx0QkFEX1JFUVVFU1Q6IC0zMjYwMCxcblx0SU5URVJOQUxfU0VSVkVSX0VSUk9SOiAtMzI2MDMsXG5cdE5PVF9JTVBMRU1FTlRFRDogLTMyNjAzLFxuXHRCQURfR0FURVdBWTogLTMyNjAzLFxuXHRTRVJWSUNFX1VOQVZBSUxBQkxFOiAtMzI2MDMsXG5cdEdBVEVXQVlfVElNRU9VVDogLTMyNjAzLFxuXHRVTkFVVEhPUklaRUQ6IC0zMjAwMSxcblx0UEFZTUVOVF9SRVFVSVJFRDogLTMyMDAyLFxuXHRGT1JCSURERU46IC0zMjAwMyxcblx0Tk9UX0ZPVU5EOiAtMzIwMDQsXG5cdE1FVEhPRF9OT1RfU1VQUE9SVEVEOiAtMzIwMDUsXG5cdFRJTUVPVVQ6IC0zMjAwOCxcblx0Q09ORkxJQ1Q6IC0zMjAwOSxcblx0UFJFQ09ORElUSU9OX0ZBSUxFRDogLTMyMDEyLFxuXHRQQVlMT0FEX1RPT19MQVJHRTogLTMyMDEzLFxuXHRVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiAtMzIwMTUsXG5cdFVOUFJPQ0VTU0FCTEVfQ09OVEVOVDogLTMyMDIyLFxuXHRUT09fTUFOWV9SRVFVRVNUUzogLTMyMDI5LFxuXHRDTElFTlRfQ0xPU0VEX1JFUVVFU1Q6IC0zMjA5OVxufTtcbmNvbnN0IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSID0ge1xuXHRbLTMyNzAwXTogXCJQQVJTRV9FUlJPUlwiLFxuXHRbLTMyNjAwXTogXCJCQURfUkVRVUVTVFwiLFxuXHRbLTMyNjAzXTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcblx0Wy0zMjAwMV06IFwiVU5BVVRIT1JJWkVEXCIsXG5cdFstMzIwMDJdOiBcIlBBWU1FTlRfUkVRVUlSRURcIixcblx0Wy0zMjAwM106IFwiRk9SQklEREVOXCIsXG5cdFstMzIwMDRdOiBcIk5PVF9GT1VORFwiLFxuXHRbLTMyMDA1XTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRbLTMyMDA4XTogXCJUSU1FT1VUXCIsXG5cdFstMzIwMDldOiBcIkNPTkZMSUNUXCIsXG5cdFstMzIwMTJdOiBcIlBSRUNPTkRJVElPTl9GQUlMRURcIixcblx0Wy0zMjAxM106IFwiUEFZTE9BRF9UT09fTEFSR0VcIixcblx0Wy0zMjAxNV06IFwiVU5TVVBQT1JURURfTUVESUFfVFlQRVwiLFxuXHRbLTMyMDIyXTogXCJVTlBST0NFU1NBQkxFX0NPTlRFTlRcIixcblx0Wy0zMjAyOV06IFwiVE9PX01BTllfUkVRVUVTVFNcIixcblx0Wy0zMjA5OV06IFwiQ0xJRU5UX0NMT1NFRF9SRVFVRVNUXCJcbn07XG4vKipcbiogdFJQQyBlcnJvciBjb2RlcyB0aGF0IGFyZSBjb25zaWRlcmVkIHJldHJ5YWJsZVxuKiBXaXRoIG91dCBvZiB0aGUgYm94IFNTRSwgdGhlIGNsaWVudCB3aWxsIHJlY29ubmVjdCB3aGVuIHRoZXNlIGVycm9ycyBhcmUgZW5jb3VudGVyZWRcbiovXG5jb25zdCByZXRyeWFibGVScGNDb2RlcyA9IFtcblx0VFJQQ19FUlJPUl9DT0RFU19CWV9LRVkuQkFEX0dBVEVXQVksXG5cdFRSUENfRVJST1JfQ09ERVNfQllfS0VZLlNFUlZJQ0VfVU5BVkFJTEFCTEUsXG5cdFRSUENfRVJST1JfQ09ERVNfQllfS0VZLkdBVEVXQVlfVElNRU9VVCxcblx0VFJQQ19FUlJPUl9DT0RFU19CWV9LRVkuSU5URVJOQUxfU0VSVkVSX0VSUk9SXG5dO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3V0aWxzLnRzXG4vKipcbiogRW5zdXJlcyB0aGVyZSBhcmUgbm8gZHVwbGljYXRlIGtleXMgd2hlbiBidWlsZGluZyBhIHByb2NlZHVyZS5cbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gbWVyZ2VXaXRob3V0T3ZlcnJpZGVzKG9iajEsIC4uLm9ianMpIHtcblx0Y29uc3QgbmV3T2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvYmoxKTtcblx0Zm9yIChjb25zdCBvdmVycmlkZXMgb2Ygb2JqcykgZm9yIChjb25zdCBrZXkgaW4gb3ZlcnJpZGVzKSB7XG5cdFx0aWYgKGtleSBpbiBuZXdPYmogJiYgbmV3T2JqW2tleV0gIT09IG92ZXJyaWRlc1trZXldKSB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBrZXkgJHtrZXl9YCk7XG5cdFx0bmV3T2JqW2tleV0gPSBvdmVycmlkZXNba2V5XTtcblx0fVxuXHRyZXR1cm4gbmV3T2JqO1xufVxuLyoqXG4qIENoZWNrIHRoYXQgdmFsdWUgaXMgb2JqZWN0XG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZuKSB7XG5cdHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuKiBDcmVhdGUgYW4gb2JqZWN0IHdpdGhvdXQgaW5oZXJpdGluZyBhbnl0aGluZyBmcm9tIGBPYmplY3QucHJvdG90eXBlYFxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBvbWl0UHJvdG90eXBlKG9iaikge1xuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvYmopO1xufVxuY29uc3QgYXN5bmNJdGVyYXRvcnNTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgISFTeW1ib2wuYXN5bmNJdGVyYXRvcjtcbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh2YWx1ZSkge1xuXHRyZXR1cm4gYXN5bmNJdGVyYXRvcnNTdXBwb3J0ZWQgJiYgaXNPYmplY3QodmFsdWUpICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlO1xufVxuLyoqXG4qIFJ1biBhbiBJSUZFXG4qL1xuY29uc3QgcnVuID0gKGZuKSA9PiBmbigpO1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBpZGVudGl0eShpdCkge1xuXHRyZXR1cm4gaXQ7XG59XG4vKipcbiogR2VuZXJpYyBydW50aW1lIGFzc2VydGlvbiBmdW5jdGlvbi4gVGhyb3dzLCBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBgdHJ1ZWAuXG4qXG4qIENhbiBiZSB1c2VkIGFzIGEgc2xpZ2h0bHkgbGVzcyBkYW5nZXJvdXMgdmFyaWFudCBvZiB0eXBlIGFzc2VydGlvbnMuIENvZGVcbiogbWlzdGFrZXMgd291bGQgYmUgcmV2ZWFsZWQgYXQgcnVudGltZSB0aGVuIChob3BlZnVsbHkgZHVyaW5nIHRlc3RpbmcpLlxuKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZyA9IFwibm8gYWRkaXRpb25hbCBpbmZvXCIpIHtcblx0aWYgKCFjb25kaXRpb24pIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uRXJyb3I6ICR7bXNnfWApO1xufVxuZnVuY3Rpb24gc2xlZXAobXMgPSAwKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgbXMpKTtcbn1cbi8qKlxuKiBQb255ZmlsbCBmb3JcbiogW2BBYm9ydFNpZ25hbC5hbnlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRTaWduYWwvYW55X3N0YXRpYykuXG4qL1xuZnVuY3Rpb24gYWJvcnRTaWduYWxzQW55UG9ueWZpbGwoc2lnbmFscykge1xuXHRpZiAodHlwZW9mIEFib3J0U2lnbmFsLmFueSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gQWJvcnRTaWduYWwuYW55KHNpZ25hbHMpO1xuXHRjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0Zm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykge1xuXHRcdGlmIChzaWduYWwuYWJvcnRlZCkge1xuXHRcdFx0dHJpZ2dlcigpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdHJpZ2dlciwgeyBvbmNlOiB0cnVlIH0pO1xuXHR9XG5cdHJldHVybiBhYy5zaWduYWw7XG5cdGZ1bmN0aW9uIHRyaWdnZXIoKSB7XG5cdFx0YWMuYWJvcnQoKTtcblx0XHRmb3IgKGNvbnN0IHNpZ25hbCBvZiBzaWduYWxzKSBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRyaWdnZXIpO1xuXHR9XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVksIFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSLCBhYm9ydFNpZ25hbHNBbnlQb255ZmlsbCwgYXNzZXJ0LCBpZGVudGl0eSwgaXNBc3luY0l0ZXJhYmxlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgbWVyZ2VXaXRob3V0T3ZlcnJpZGVzLCBub29wLCBvbWl0UHJvdG90eXBlLCByZXRyeWFibGVScGNDb2RlcywgcnVuLCBzbGVlcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMtQkhaSmNCUnYubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/adapters/fetch/index.mjs":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/adapters/fetch/index.mjs ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchRequestHandler: () => (/* binding */ fetchRequestHandler)\n/* harmony export */ });\n/* harmony import */ var _resolveResponse_DPbYgJDD_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../resolveResponse-DPbYgJDD.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-DPbYgJDD.mjs\");\n\n\n\n\n\n//#region src/adapters/fetch/fetchRequestHandler.ts\nconst trimSlashes = (path)=>{\n    path = path.startsWith(\"/\") ? path.slice(1) : path;\n    path = path.endsWith(\"/\") ? path.slice(0, -1) : path;\n    return path;\n};\nasync function fetchRequestHandler(opts) {\n    const resHeaders = new Headers();\n    const createContext = async (innerOpts)=>{\n        return opts.createContext?.({\n            req: opts.req,\n            resHeaders,\n            ...innerOpts\n        });\n    };\n    const url = new URL(opts.req.url);\n    const pathname = trimSlashes(url.pathname);\n    const endpoint = trimSlashes(opts.endpoint);\n    const path = trimSlashes(pathname.slice(endpoint.length));\n    return await (0,_resolveResponse_DPbYgJDD_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveResponse)({\n        ...opts,\n        req: opts.req,\n        createContext,\n        path,\n        error: null,\n        onError (o) {\n            opts?.onError?.({\n                ...o,\n                req: opts.req\n            });\n        },\n        responseMeta (data) {\n            const meta = opts.responseMeta?.(data);\n            if (meta?.headers) {\n                if (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries())resHeaders.append(key, value);\n                else /**\n\t\t\t\t* @deprecated, delete in v12\n\t\t\t\t*/ for (const [key, value] of Object.entries(meta.headers))if (Array.isArray(value)) for (const v of value)resHeaders.append(key, v);\n                else if (typeof value === \"string\") resHeaders.set(key, value);\n            }\n            return {\n                headers: resHeaders,\n                status: meta?.status\n            };\n        }\n    });\n}\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9hZGFwdGVycy9mZXRjaC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUU7QUFDM0I7QUFDTjtBQUNGO0FBQ0s7QUFFdkMsbURBQW1EO0FBQ25ELE1BQU1DLGNBQWMsQ0FBQ0M7SUFDcEJBLE9BQU9BLEtBQUtDLFVBQVUsQ0FBQyxPQUFPRCxLQUFLRSxLQUFLLENBQUMsS0FBS0Y7SUFDOUNBLE9BQU9BLEtBQUtHLFFBQVEsQ0FBQyxPQUFPSCxLQUFLRSxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUtGO0lBQ2hELE9BQU9BO0FBQ1I7QUFDQSxlQUFlSSxvQkFBb0JDLElBQUk7SUFDdEMsTUFBTUMsYUFBYSxJQUFJQztJQUN2QixNQUFNQyxnQkFBZ0IsT0FBT0M7UUFDNUIsT0FBT0osS0FBS0csYUFBYSxHQUFHO1lBQzNCRSxLQUFLTCxLQUFLSyxHQUFHO1lBQ2JKO1lBQ0EsR0FBR0csU0FBUztRQUNiO0lBQ0Q7SUFDQSxNQUFNRSxNQUFNLElBQUlDLElBQUlQLEtBQUtLLEdBQUcsQ0FBQ0MsR0FBRztJQUNoQyxNQUFNRSxXQUFXZCxZQUFZWSxJQUFJRSxRQUFRO0lBQ3pDLE1BQU1DLFdBQVdmLFlBQVlNLEtBQUtTLFFBQVE7SUFDMUMsTUFBTWQsT0FBT0QsWUFBWWMsU0FBU1gsS0FBSyxDQUFDWSxTQUFTQyxNQUFNO0lBQ3ZELE9BQU8sTUFBTWpCLDhFQUFlQSxDQUFDO1FBQzVCLEdBQUdPLElBQUk7UUFDUEssS0FBS0wsS0FBS0ssR0FBRztRQUNiRjtRQUNBUjtRQUNBZ0IsT0FBTztRQUNQQyxTQUFRQyxDQUFDO1lBQ1JiLE1BQU1ZLFVBQVU7Z0JBQ2YsR0FBR0MsQ0FBQztnQkFDSlIsS0FBS0wsS0FBS0ssR0FBRztZQUNkO1FBQ0Q7UUFDQVMsY0FBYUMsSUFBSTtZQUNoQixNQUFNQyxPQUFPaEIsS0FBS2MsWUFBWSxHQUFHQztZQUNqQyxJQUFJQyxNQUFNQyxTQUFTO2dCQUNsQixJQUFJRCxLQUFLQyxPQUFPLFlBQVlmLFNBQVMsS0FBSyxNQUFNLENBQUNnQixLQUFLQyxNQUFNLElBQUlILEtBQUtDLE9BQU8sQ0FBQ0csT0FBTyxHQUFJbkIsV0FBV29CLE1BQU0sQ0FBQ0gsS0FBS0M7cUJBRWxIOztJQUVHLEdBQ0EsS0FBSyxNQUFNLENBQUNELEtBQUtDLE1BQU0sSUFBSUcsT0FBT0YsT0FBTyxDQUFDSixLQUFLQyxPQUFPLEVBQUcsSUFBSU0sTUFBTUMsT0FBTyxDQUFDTCxRQUFRLEtBQUssTUFBTU0sS0FBS04sTUFBT2xCLFdBQVdvQixNQUFNLENBQUNILEtBQUtPO3FCQUM1SCxJQUFJLE9BQU9OLFVBQVUsVUFBVWxCLFdBQVd5QixHQUFHLENBQUNSLEtBQUtDO1lBQ3pEO1lBQ0EsT0FBTztnQkFDTkYsU0FBU2hCO2dCQUNUMEIsUUFBUVgsTUFBTVc7WUFDZjtRQUNEO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDbUIsQ0FDL0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9hZGFwdGVycy9mZXRjaC9pbmRleC5tanM/MGI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNvbHZlUmVzcG9uc2UgfSBmcm9tIFwiLi4vLi4vcmVzb2x2ZVJlc3BvbnNlLURQYllnSkRELm1qc1wiO1xuaW1wb3J0IFwiLi4vLi4vZ2V0RXJyb3JTaGFwZS1EeVlpbDRhVC5tanNcIjtcbmltcG9ydCBcIi4uLy4uL3RyYWNrZWQtR0VXUG9MMEMubWpzXCI7XG5pbXBvcnQgXCIuLi8uLi91dGlscy1CSFpKY0JSdi5tanNcIjtcbmltcG9ydCBcIi4uLy4uL29ic2VydmFibGUtQjFvckxISEkubWpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvYWRhcHRlcnMvZmV0Y2gvZmV0Y2hSZXF1ZXN0SGFuZGxlci50c1xuY29uc3QgdHJpbVNsYXNoZXMgPSAocGF0aCkgPT4ge1xuXHRwYXRoID0gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSA/IHBhdGguc2xpY2UoMSkgOiBwYXRoO1xuXHRwYXRoID0gcGF0aC5lbmRzV2l0aChcIi9cIikgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG5cdHJldHVybiBwYXRoO1xufTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVxdWVzdEhhbmRsZXIob3B0cykge1xuXHRjb25zdCByZXNIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcblx0Y29uc3QgY3JlYXRlQ29udGV4dCA9IGFzeW5jIChpbm5lck9wdHMpID0+IHtcblx0XHRyZXR1cm4gb3B0cy5jcmVhdGVDb250ZXh0Py4oe1xuXHRcdFx0cmVxOiBvcHRzLnJlcSxcblx0XHRcdHJlc0hlYWRlcnMsXG5cdFx0XHQuLi5pbm5lck9wdHNcblx0XHR9KTtcblx0fTtcblx0Y29uc3QgdXJsID0gbmV3IFVSTChvcHRzLnJlcS51cmwpO1xuXHRjb25zdCBwYXRobmFtZSA9IHRyaW1TbGFzaGVzKHVybC5wYXRobmFtZSk7XG5cdGNvbnN0IGVuZHBvaW50ID0gdHJpbVNsYXNoZXMob3B0cy5lbmRwb2ludCk7XG5cdGNvbnN0IHBhdGggPSB0cmltU2xhc2hlcyhwYXRobmFtZS5zbGljZShlbmRwb2ludC5sZW5ndGgpKTtcblx0cmV0dXJuIGF3YWl0IHJlc29sdmVSZXNwb25zZSh7XG5cdFx0Li4ub3B0cyxcblx0XHRyZXE6IG9wdHMucmVxLFxuXHRcdGNyZWF0ZUNvbnRleHQsXG5cdFx0cGF0aCxcblx0XHRlcnJvcjogbnVsbCxcblx0XHRvbkVycm9yKG8pIHtcblx0XHRcdG9wdHM/Lm9uRXJyb3I/Lih7XG5cdFx0XHRcdC4uLm8sXG5cdFx0XHRcdHJlcTogb3B0cy5yZXFcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0cmVzcG9uc2VNZXRhKGRhdGEpIHtcblx0XHRcdGNvbnN0IG1ldGEgPSBvcHRzLnJlc3BvbnNlTWV0YT8uKGRhdGEpO1xuXHRcdFx0aWYgKG1ldGE/LmhlYWRlcnMpIHtcblx0XHRcdFx0aWYgKG1ldGEuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1ldGEuaGVhZGVycy5lbnRyaWVzKCkpIHJlc0hlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRlbHNlXG4gLyoqXG5cdFx0XHRcdCogQGRlcHJlY2F0ZWQsIGRlbGV0ZSBpbiB2MTJcblx0XHRcdFx0Ki9cblx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YS5oZWFkZXJzKSkgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHJlc0hlYWRlcnMuYXBwZW5kKGtleSwgdik7XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgcmVzSGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRoZWFkZXJzOiByZXNIZWFkZXJzLFxuXHRcdFx0XHRzdGF0dXM6IG1ldGE/LnN0YXR1c1xuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IGZldGNoUmVxdWVzdEhhbmRsZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsicmVzb2x2ZVJlc3BvbnNlIiwidHJpbVNsYXNoZXMiLCJwYXRoIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZW5kc1dpdGgiLCJmZXRjaFJlcXVlc3RIYW5kbGVyIiwib3B0cyIsInJlc0hlYWRlcnMiLCJIZWFkZXJzIiwiY3JlYXRlQ29udGV4dCIsImlubmVyT3B0cyIsInJlcSIsInVybCIsIlVSTCIsInBhdGhuYW1lIiwiZW5kcG9pbnQiLCJsZW5ndGgiLCJlcnJvciIsIm9uRXJyb3IiLCJvIiwicmVzcG9uc2VNZXRhIiwiZGF0YSIsIm1ldGEiLCJoZWFkZXJzIiwia2V5IiwidmFsdWUiLCJlbnRyaWVzIiwiYXBwZW5kIiwiT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwidiIsInNldCIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/adapters/fetch/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTP_CODE_TO_JSONRPC2: () => (/* binding */ HTTP_CODE_TO_JSONRPC2),\n/* harmony export */   JSONRPC2_TO_HTTP_CODE: () => (/* binding */ JSONRPC2_TO_HTTP_CODE),\n/* harmony export */   createFlatProxy: () => (/* binding */ createFlatProxy),\n/* harmony export */   createRecursiveProxy: () => (/* binding */ createRecursiveProxy),\n/* harmony export */   getErrorShape: () => (/* binding */ getErrorShape),\n/* harmony export */   getHTTPStatusCode: () => (/* binding */ getHTTPStatusCode),\n/* harmony export */   getHTTPStatusCodeFromError: () => (/* binding */ getHTTPStatusCodeFromError),\n/* harmony export */   getStatusCodeFromKey: () => (/* binding */ getStatusCodeFromKey),\n/* harmony export */   getStatusKeyFromCode: () => (/* binding */ getStatusKeyFromCode)\n/* harmony export */ });\n/* harmony import */ var _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-BHZJcBRv.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\");\n\n//#region src/unstable-core-do-not-import/createProxy.ts\nconst noop = ()=>{};\nconst freezeIfAvailable = (obj)=>{\n    if (Object.freeze) Object.freeze(obj);\n};\nfunction createInnerProxy(callback, path, memo) {\n    const cacheKey = path.join(\".\");\n    memo[cacheKey] ??= new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== \"string\" || key === \"then\") return void 0;\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ], memo);\n        },\n        apply (_1, _2, args) {\n            const lastOfPath = path[path.length - 1];\n            let opts = {\n                args,\n                path\n            };\n            if (lastOfPath === \"call\") opts = {\n                args: args.length >= 2 ? [\n                    args[1]\n                ] : [],\n                path: path.slice(0, -1)\n            };\n            else if (lastOfPath === \"apply\") opts = {\n                args: args.length >= 2 ? args[1] : [],\n                path: path.slice(0, -1)\n            };\n            freezeIfAvailable(opts.args);\n            freezeIfAvailable(opts.path);\n            return callback(opts);\n        }\n    });\n    return memo[cacheKey];\n}\n/**\n* Creates a proxy that calls the callback with the path and arguments\n*\n* @internal\n*/ const createRecursiveProxy = (callback)=>createInnerProxy(callback, [], Object.create(null));\n/**\n* Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n*\n* @internal\n*/ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (name === \"then\") return void 0;\n            return callback(name);\n        }\n    });\n};\n//#endregion\n//#region src/unstable-core-do-not-import/http/getHTTPStatusCode.ts\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    PAYMENT_REQUIRED: 402,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNSUPPORTED_MEDIA_TYPE: 415,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501,\n    BAD_GATEWAY: 502,\n    SERVICE_UNAVAILABLE: 503,\n    GATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n    400: \"BAD_REQUEST\",\n    401: \"UNAUTHORIZED\",\n    402: \"PAYMENT_REQUIRED\",\n    403: \"FORBIDDEN\",\n    404: \"NOT_FOUND\",\n    405: \"METHOD_NOT_SUPPORTED\",\n    408: \"TIMEOUT\",\n    409: \"CONFLICT\",\n    412: \"PRECONDITION_FAILED\",\n    413: \"PAYLOAD_TOO_LARGE\",\n    415: \"UNSUPPORTED_MEDIA_TYPE\",\n    422: \"UNPROCESSABLE_CONTENT\",\n    429: \"TOO_MANY_REQUESTS\",\n    499: \"CLIENT_CLOSED_REQUEST\",\n    500: \"INTERNAL_SERVER_ERROR\",\n    501: \"NOT_IMPLEMENTED\",\n    502: \"BAD_GATEWAY\",\n    503: \"SERVICE_UNAVAILABLE\",\n    504: \"GATEWAY_TIMEOUT\"\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getStatusKeyFromCode(code) {\n    return HTTP_CODE_TO_JSONRPC2[code] ?? \"INTERNAL_SERVER_ERROR\";\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if (\"error\" in res && (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(res.error.data)) {\n            if (typeof res.error.data?.[\"httpStatus\"] === \"number\") return res.error.data[\"httpStatus\"];\n            const code = _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) return 207;\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    return getStatusCodeFromKey(error.code);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/error/getErrorShape.ts\n/**\n* @internal\n*/ function getErrorShape(opts) {\n    const { path, error, config } = opts;\n    const { code } = opts.error;\n    const shape = {\n        message: error.message,\n        code: _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_KEY[code],\n        data: {\n            code,\n            httpStatus: getHTTPStatusCodeFromError(error)\n        }\n    };\n    if (config.isDev && typeof opts.error.stack === \"string\") shape.data.stack = opts.error.stack;\n    if (typeof path === \"string\") shape.data.path = path;\n    return config.errorFormatter({\n        ...opts,\n        shape\n    });\n}\n//#endregion\n //# sourceMappingURL=getErrorShape-DyYil4aT.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9nZXRFcnJvclNoYXBlLUR5WWlsNGFULm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXFHO0FBRXJHLHdEQUF3RDtBQUN4RCxNQUFNRyxPQUFPLEtBQU87QUFDcEIsTUFBTUMsb0JBQW9CLENBQUNDO0lBQzFCLElBQUlDLE9BQU9DLE1BQU0sRUFBRUQsT0FBT0MsTUFBTSxDQUFDRjtBQUNsQztBQUNBLFNBQVNHLGlCQUFpQkMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDN0MsTUFBTUMsV0FBV0YsS0FBS0csSUFBSSxDQUFDO0lBQzNCRixJQUFJLENBQUNDLFNBQVMsS0FBSyxJQUFJRSxNQUFNWCxNQUFNO1FBQ2xDWSxLQUFJQyxJQUFJLEVBQUVDLEdBQUc7WUFDWixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsUUFBUSxRQUFRLE9BQU8sS0FBSztZQUMzRCxPQUFPVCxpQkFBaUJDLFVBQVU7bUJBQUlDO2dCQUFNTzthQUFJLEVBQUVOO1FBQ25EO1FBQ0FPLE9BQU1DLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxJQUFJO1lBQ2pCLE1BQU1DLGFBQWFaLElBQUksQ0FBQ0EsS0FBS2EsTUFBTSxHQUFHLEVBQUU7WUFDeEMsSUFBSUMsT0FBTztnQkFDVkg7Z0JBQ0FYO1lBQ0Q7WUFDQSxJQUFJWSxlQUFlLFFBQVFFLE9BQU87Z0JBQ2pDSCxNQUFNQSxLQUFLRSxNQUFNLElBQUksSUFBSTtvQkFBQ0YsSUFBSSxDQUFDLEVBQUU7aUJBQUMsR0FBRyxFQUFFO2dCQUN2Q1gsTUFBTUEsS0FBS2UsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUN0QjtpQkFDSyxJQUFJSCxlQUFlLFNBQVNFLE9BQU87Z0JBQ3ZDSCxNQUFNQSxLQUFLRSxNQUFNLElBQUksSUFBSUYsSUFBSSxDQUFDLEVBQUUsR0FBRyxF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QU1VLFFBQVE7UUFDYkMsU0FBU1gsTUFBTVcsT0FBTztRQUN0QnRCLE1BQU1yRCx3RUFBdUIsQ0FBQ3FELEtBQUs7UUFDbkNZLE1BQU07WUFDTFo7WUFDQWMsWUFBWUksMkJBQTJCUDtRQUN4QztJQUNEO0lBQ0EsSUFBSVMsT0FBT0csS0FBSyxJQUFJLE9BQU9wRCxLQUFLd0MsS0FBSyxDQUFDYSxLQUFLLEtBQUssVUFBVUgsTUFBTVQsSUFBSSxDQUFDWSxLQUFLLEdBQUdyRCxLQUFLd0MsS0FBSyxDQUFDYSxLQUFLO0lBQzdGLElBQUksT0FBT25FLFNBQVMsVUFBVWdFLE1BQU1ULElBQUksQ0FBQ3ZELElBQUksR0FBR0E7SUFDaEQsT0FBTytELE9BQU9LLGNBQWMsQ0FBQztRQUM1QixHQUFHdEQsSUFBSTtRQUNQa0Q7SUFDRDtBQUNEO0FBRUEsWUFBWTtBQUM2TCxDQUN6TSxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTEuNC4xX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0B0cnBjL3NlcnZlci9kaXN0L2dldEVycm9yU2hhcGUtRHlZaWw0YVQubWpzPzA3MzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVksIFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSLCBpc09iamVjdCB9IGZyb20gXCIuL3V0aWxzLUJIWkpjQlJ2Lm1qc1wiO1xuXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9jcmVhdGVQcm94eS50c1xuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuY29uc3QgZnJlZXplSWZBdmFpbGFibGUgPSAob2JqKSA9PiB7XG5cdGlmIChPYmplY3QuZnJlZXplKSBPYmplY3QuZnJlZXplKG9iaik7XG59O1xuZnVuY3Rpb24gY3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgcGF0aCwgbWVtbykge1xuXHRjb25zdCBjYWNoZUtleSA9IHBhdGguam9pbihcIi5cIik7XG5cdG1lbW9bY2FjaGVLZXldID8/PSBuZXcgUHJveHkobm9vcCwge1xuXHRcdGdldChfb2JqLCBrZXkpIHtcblx0XHRcdGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiIHx8IGtleSA9PT0gXCJ0aGVuXCIpIHJldHVybiB2b2lkIDA7XG5cdFx0XHRyZXR1cm4gY3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgWy4uLnBhdGgsIGtleV0sIG1lbW8pO1xuXHRcdH0sXG5cdFx0YXBwbHkoXzEsIF8yLCBhcmdzKSB7XG5cdFx0XHRjb25zdCBsYXN0T2ZQYXRoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXHRcdFx0bGV0IG9wdHMgPSB7XG5cdFx0XHRcdGFyZ3MsXG5cdFx0XHRcdHBhdGhcblx0XHRcdH07XG5cdFx0XHRpZiAobGFzdE9mUGF0aCA9PT0gXCJjYWxsXCIpIG9wdHMgPSB7XG5cdFx0XHRcdGFyZ3M6IGFyZ3MubGVuZ3RoID49IDIgPyBbYXJnc1sxXV0gOiBbXSxcblx0XHRcdFx0cGF0aDogcGF0aC5zbGljZSgwLCAtMSlcblx0XHRcdH07XG5cdFx0XHRlbHNlIGlmIChsYXN0T2ZQYXRoID09PSBcImFwcGx5XCIpIG9wdHMgPSB7XG5cdFx0XHRcdGFyZ3M6IGFyZ3MubGVuZ3RoID49IDIgPyBhcmdzWzFdIDogW10sXG5cdFx0XHRcdHBhdGg6IHBhdGguc2xpY2UoMCwgLTEpXG5cdFx0XHR9O1xuXHRcdFx0ZnJlZXplSWZBdmFpbGFibGUob3B0cy5hcmdzKTtcblx0XHRcdGZyZWV6ZUlmQXZhaWxhYmxlKG9wdHMucGF0aCk7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sob3B0cyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIG1lbW9bY2FjaGVLZXldO1xufVxuLyoqXG4qIENyZWF0ZXMgYSBwcm94eSB0aGF0IGNhbGxzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwYXRoIGFuZCBhcmd1bWVudHNcbipcbiogQGludGVybmFsXG4qL1xuY29uc3QgY3JlYXRlUmVjdXJzaXZlUHJveHkgPSAoY2FsbGJhY2spID0+IGNyZWF0ZUlubmVyUHJveHkoY2FsbGJhY2ssIFtdLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbi8qKlxuKiBVc2VkIGluIHBsYWNlIG9mIGBuZXcgUHJveHlgIHdoZXJlIGVhY2ggaGFuZGxlciB3aWxsIG1hcCAxIGxldmVsIGRlZXAgdG8gYW5vdGhlciB2YWx1ZS5cbipcbiogQGludGVybmFsXG4qL1xuY29uc3QgY3JlYXRlRmxhdFByb3h5ID0gKGNhbGxiYWNrKSA9PiB7XG5cdHJldHVybiBuZXcgUHJveHkobm9vcCwgeyBnZXQoX29iaiwgbmFtZSkge1xuXHRcdGlmIChuYW1lID09PSBcInRoZW5cIikgcmV0dXJuIHZvaWQgMDtcblx0XHRyZXR1cm4gY2FsbGJhY2sobmFtZSk7XG5cdH0gfSk7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvZ2V0SFRUUFN0YXR1c0NvZGUudHNcbmNvbnN0IEpTT05SUEMyX1RPX0hUVFBfQ09ERSA9IHtcblx0UEFSU0VfRVJST1I6IDQwMCxcblx0QkFEX1JFUVVFU1Q6IDQwMCxcblx0VU5BVVRIT1JJWkVEOiA0MDEsXG5cdFBBWU1FTlRfUkVRVUlSRUQ6IDQwMixcblx0Rk9SQklEREVOOiA0MDMsXG5cdE5PVF9GT1VORDogNDA0LFxuXHRNRVRIT0RfTk9UX1NVUFBPUlRFRDogNDA1LFxuXHRUSU1FT1VUOiA0MDgsXG5cdENPTkZMSUNUOiA0MDksXG5cdFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQxMixcblx0UEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcblx0VU5TVVBQT1JURURfTUVESUFfVFlQRTogNDE1LFxuXHRVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IDQyMixcblx0VE9PX01BTllfUkVRVUVTVFM6IDQyOSxcblx0Q0xJRU5UX0NMT1NFRF9SRVFVRVNUOiA0OTksXG5cdElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuXHROT1RfSU1QTEVNRU5URUQ6IDUwMSxcblx0QkFEX0dBVEVXQVk6IDUwMixcblx0U0VSVklDRV9VTkFWQUlMQUJMRTogNTAzLFxuXHRHQVRFV0FZX1RJTUVPVVQ6IDUwNFxufTtcbmNvbnN0IEhUVFBfQ09ERV9UT19KU09OUlBDMiA9IHtcblx0NDAwOiBcIkJBRF9SRVFVRVNUXCIsXG5cdDQwMTogXCJVTkFVVEhPUklaRURcIixcblx0NDAyOiBcIlBBWU1FTlRfUkVRVUlSRURcIixcblx0NDAzOiBcIkZPUkJJRERFTlwiLFxuXHQ0MDQ6IFwiTk9UX0ZPVU5EXCIsXG5cdDQwNTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHQ0MDg6IFwiVElNRU9VVFwiLFxuXHQ0MDk6IFwiQ09ORkxJQ1RcIixcblx0NDEyOiBcIlBSRUNPTkRJVElPTl9GQUlMRURcIixcblx0NDEzOiBcIlBBWUxPQURfVE9PX0xBUkdFXCIsXG5cdDQxNTogXCJVTlNVUFBPUlRFRF9NRURJQV9UWVBFXCIsXG5cdDQyMjogXCJVTlBST0NFU1NBQkxFX0NPTlRFTlRcIixcblx0NDI5OiBcIlRPT19NQU5ZX1JFUVVFU1RTXCIsXG5cdDQ5OTogXCJDTElFTlRfQ0xPU0VEX1JFUVVFU1RcIixcblx0NTAwOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuXHQ1MDE6IFwiTk9UX0lNUExFTUVOVEVEXCIsXG5cdDUwMjogXCJCQURfR0FURVdBWVwiLFxuXHQ1MDM6IFwiU0VSVklDRV9VTkFWQUlMQUJMRVwiLFxuXHQ1MDQ6IFwiR0FURVdBWV9USU1FT1VUXCJcbn07XG5mdW5jdGlvbiBnZXRTdGF0dXNDb2RlRnJvbUtleShjb2RlKSB7XG5cdHJldHVybiBKU09OUlBDMl9UT19IVFRQX0NPREVbY29kZV0gPz8gNTAwO1xufVxuZnVuY3Rpb24gZ2V0U3RhdHVzS2V5RnJvbUNvZGUoY29kZSkge1xuXHRyZXR1cm4gSFRUUF9DT0RFX1RPX0pTT05SUEMyW2NvZGVdID8/IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCI7XG59XG5mdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZShqc29uKSB7XG5cdGNvbnN0IGFyciA9IEFycmF5LmlzQXJyYXkoanNvbikgPyBqc29uIDogW2pzb25dO1xuXHRjb25zdCBodHRwU3RhdHVzZXMgPSBuZXcgU2V0KGFyci5tYXAoKHJlcykgPT4ge1xuXHRcdGlmIChcImVycm9yXCIgaW4gcmVzICYmIGlzT2JqZWN0KHJlcy5lcnJvci5kYXRhKSkge1xuXHRcdFx0aWYgKHR5cGVvZiByZXMuZXJyb3IuZGF0YT8uW1wiaHR0cFN0YXR1c1wiXSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHJlcy5lcnJvci5kYXRhW1wiaHR0cFN0YXR1c1wiXTtcblx0XHRcdGNvbnN0IGNvZGUgPSBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUltyZXMuZXJyb3IuY29kZV07XG5cdFx0XHRyZXR1cm4gZ2V0U3RhdHVzQ29kZUZyb21LZXkoY29kZSk7XG5cdFx0fVxuXHRcdHJldHVybiAyMDA7XG5cdH0pKTtcblx0aWYgKGh0dHBTdGF0dXNlcy5zaXplICE9PSAxKSByZXR1cm4gMjA3O1xuXHRjb25zdCBodHRwU3RhdHVzID0gaHR0cFN0YXR1c2VzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblx0cmV0dXJuIGh0dHBTdGF0dXM7XG59XG5mdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcikge1xuXHRyZXR1cm4gZ2V0U3RhdHVzQ29kZUZyb21LZXkoZXJyb3IuY29kZSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvZXJyb3IvZ2V0RXJyb3JTaGFwZS50c1xuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGdldEVycm9yU2hhcGUob3B0cykge1xuXHRjb25zdCB7IHBhdGgsIGVycm9yLCBjb25maWcgfSA9IG9wdHM7XG5cdGNvbnN0IHsgY29kZSB9ID0gb3B0cy5lcnJvcjtcblx0Y29uc3Qgc2hhcGUgPSB7XG5cdFx0bWVzc2FnZTogZXJyb3IubWVzc2FnZSxcblx0XHRjb2RlOiBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWVtjb2RlXSxcblx0XHRkYXRhOiB7XG5cdFx0XHRjb2RlLFxuXHRcdFx0aHR0cFN0YXR1czogZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IoZXJyb3IpXG5cdFx0fVxuXHR9O1xuXHRpZiAoY29uZmlnLmlzRGV2ICYmIHR5cGVvZiBvcHRzLmVycm9yLnN0YWNrID09PSBcInN0cmluZ1wiKSBzaGFwZS5kYXRhLnN0YWNrID0gb3B0cy5lcnJvci5zdGFjaztcblx0aWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKSBzaGFwZS5kYXRhLnBhdGggPSBwYXRoO1xuXHRyZXR1cm4gY29uZmlnLmVycm9yRm9ybWF0dGVyKHtcblx0XHQuLi5vcHRzLFxuXHRcdHNoYXBlXG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IEhUVFBfQ09ERV9UT19KU09OUlBDMiwgSlNPTlJQQzJfVE9fSFRUUF9DT0RFLCBjcmVhdGVGbGF0UHJveHksIGNyZWF0ZVJlY3Vyc2l2ZVByb3h5LCBnZXRFcnJvclNoYXBlLCBnZXRIVFRQU3RhdHVzQ29kZSwgZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IsIGdldFN0YXR1c0NvZGVGcm9tS2V5LCBnZXRTdGF0dXNLZXlGcm9tQ29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0RXJyb3JTaGFwZS1EeVlpbDRhVC5tanMubWFwIl0sIm5hbWVzIjpbIlRSUENfRVJST1JfQ09ERVNfQllfS0VZIiwiVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVIiLCJpc09iamVjdCIsIm5vb3AiLCJmcmVlemVJZkF2YWlsYWJsZSIsIm9iaiIsIk9iamVjdCIsImZyZWV6ZSIsImNyZWF0ZUlubmVyUHJveHkiLCJjYWxsYmFjayIsInBhdGgiLCJtZW1vIiwiY2FjaGVLZXkiLCJqb2luIiwiUHJveHkiLCJnZXQiLCJfb2JqIiwia2V5IiwiYXBwbHkiLCJfMSIsIl8yIiwiYXJncyIsImxhc3RPZlBhdGgiLCJsZW5ndGgiLCJvcHRzIiwic2xpY2UiLCJjcmVhdGVSZWN1cnNpdmVQcm94eSIsImNyZWF0ZSIsImNyZWF0ZUZsYXRQcm94eSIsIm5hbWUiLCJKU09OUlBDMl9UT19IVFRQX0NPREUiLCJQQVJTRV9FUlJPUiIsIkJBRF9SRVFVRVNUIiwiVU5BVVRIT1JJWkVEIiwiUEFZTUVOVF9SRVFVSVJFRCIsIkZPUkJJRERFTiIsIk5PVF9GT1VORCIsIk1FVEhPRF9OT1RfU1VQUE9SVEVEIiwiVElNRU9VVCIsIkNPTkZMSUNUIiwiUFJFQ09ORElUSU9OX0ZBSUxFRCIsIlBBWUxPQURfVE9PX0xBUkdFIiwiVU5TVVBQT1JURURfTUVESUFfVFlQRSIsIlVOUFJPQ0VTU0FCTEVfQ09OVEVOVCIsIlRPT19NQU5ZX1JFUVVFU1RTIiwiQ0xJRU5UX0NMT1NFRF9SRVFVRVNUIiwiSU5URVJOQUxfU0VSVkVSX0VSUk9SIiwiTk9UX0lNUExFTUVOVEVEIiwiQkFEX0dBVEVXQVkiLCJTRVJWSUNFX1VOQVZBSUxBQkxFIiwiR0FURVdBWV9USU1FT1VUIiwiSFRUUF9DT0RFX1RPX0pTT05SUEMyIiwiZ2V0U3RhdHVzQ29kZUZyb21LZXkiLCJjb2RlIiwiZ2V0U3RhdHVzS2V5RnJvbUNvZGUiLCJnZXRIVFRQU3RhdHVzQ29kZSIsImpzb24iLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJodHRwU3RhdHVzZXMiLCJTZXQiLCJtYXAiLCJyZXMiLCJlcnJvciIsImRhdGEiLCJzaXplIiwiaHR0cFN0YXR1cyIsInZhbHVlcyIsIm5leHQiLCJ2YWx1ZSIsImdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yIiwiZ2V0RXJyb3JTaGFwZSIsImNvbmZpZyIsInNoYXBlIiwibWVzc2FnZSIsImlzRGV2Iiwic3RhY2siLCJlcnJvckZvcm1hdHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/initTRPC-COaJMShh.mjs":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/initTRPC-COaJMShh.mjs ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StandardSchemaV1Error: () => (/* binding */ StandardSchemaV1Error),\n/* harmony export */   createBuilder: () => (/* binding */ createBuilder),\n/* harmony export */   createInputMiddleware: () => (/* binding */ createInputMiddleware),\n/* harmony export */   createMiddlewareFactory: () => (/* binding */ createMiddlewareFactory),\n/* harmony export */   createOutputMiddleware: () => (/* binding */ createOutputMiddleware),\n/* harmony export */   experimental_standaloneMiddleware: () => (/* binding */ experimental_standaloneMiddleware),\n/* harmony export */   getParseFn: () => (/* binding */ getParseFn),\n/* harmony export */   initTRPC: () => (/* binding */ initTRPC),\n/* harmony export */   isServerDefault: () => (/* binding */ isServerDefault),\n/* harmony export */   middlewareMarker: () => (/* binding */ middlewareMarker)\n/* harmony export */ });\n/* harmony import */ var _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tracked-GEWPoL0C.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs\");\n/* harmony import */ var _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-BHZJcBRv.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\");\n\n\n//#region src/unstable-core-do-not-import/middleware.ts\n/** @internal */ const middlewareMarker = \"middlewareMarker\";\n/**\n* @internal\n*/ function createMiddlewareFactory() {\n    function createMiddlewareInner(middlewares) {\n        return {\n            _middlewares: middlewares,\n            unstable_pipe (middlewareBuilderOrFn) {\n                const pipedMiddleware = \"_middlewares\" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                    middlewareBuilderOrFn\n                ];\n                return createMiddlewareInner([\n                    ...middlewares,\n                    ...pipedMiddleware\n                ]);\n            }\n        };\n    }\n    function createMiddleware(fn) {\n        return createMiddlewareInner([\n            fn\n        ]);\n    }\n    return createMiddleware;\n}\n/**\n* Create a standalone middleware\n* @see https://trpc.io/docs/v11/server/middlewares#experimental-standalone-middlewares\n* @deprecated use `.concat()` instead\n*/ const experimental_standaloneMiddleware = ()=>({\n        create: createMiddlewareFactory()\n    });\n/**\n* @internal\n* Please note, `trpc-openapi` uses this function.\n*/ function createInputMiddleware(parse) {\n    const inputMiddleware = async function inputValidatorMiddleware(opts) {\n        let parsedInput;\n        const rawInput = await opts.getRawInput();\n        try {\n            parsedInput = await parse(rawInput);\n        } catch (cause) {\n            throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPCError({\n                code: \"BAD_REQUEST\",\n                cause\n            });\n        }\n        const combinedInput = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts.input) && (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(parsedInput) ? {\n            ...opts.input,\n            ...parsedInput\n        } : parsedInput;\n        return opts.next({\n            input: combinedInput\n        });\n    };\n    inputMiddleware._type = \"input\";\n    return inputMiddleware;\n}\n/**\n* @internal\n*/ function createOutputMiddleware(parse) {\n    const outputMiddleware = async function outputValidatorMiddleware({ next }) {\n        const result = await next();\n        if (!result.ok) return result;\n        try {\n            const data = await parse(result.data);\n            return {\n                ...result,\n                data\n            };\n        } catch (cause) {\n            throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPCError({\n                message: \"Output validation failed\",\n                code: \"INTERNAL_SERVER_ERROR\",\n                cause\n            });\n        }\n    };\n    outputMiddleware._type = \"output\";\n    return outputMiddleware;\n}\n//#endregion\n//#region src/vendor/standard-schema-v1/error.ts\n/** A schema error with useful information. */ var StandardSchemaV1Error = class extends Error {\n    /**\n\t* Creates a schema error with useful information.\n\t*\n\t* @param issues The schema issues.\n\t*/ constructor(issues){\n        super(issues[0]?.message);\n        this.name = \"SchemaError\";\n        this.issues = issues;\n    }\n};\n//#endregion\n//#region src/unstable-core-do-not-import/parser.ts\nfunction getParseFn(procedureParser) {\n    const parser = procedureParser;\n    const isStandardSchema = \"~standard\" in parser;\n    if (typeof parser === \"function\" && typeof parser.assert === \"function\") return parser.assert.bind(parser);\n    if (typeof parser === \"function\" && !isStandardSchema) return parser;\n    if (typeof parser.parseAsync === \"function\") return parser.parseAsync.bind(parser);\n    if (typeof parser.parse === \"function\") return parser.parse.bind(parser);\n    if (typeof parser.validateSync === \"function\") return parser.validateSync.bind(parser);\n    if (typeof parser.create === \"function\") return parser.create.bind(parser);\n    if (typeof parser.assert === \"function\") return (value)=>{\n        parser.assert(value);\n        return value;\n    };\n    if (isStandardSchema) return async (value)=>{\n        const result = await parser[\"~standard\"].validate(value);\n        if (result.issues) throw new StandardSchemaV1Error(result.issues);\n        return result.value;\n    };\n    throw new Error(\"Could not find a validator fn\");\n}\n//#endregion\n//#region src/unstable-core-do-not-import/procedureBuilder.ts\nfunction createNewBuilder(def1, def2) {\n    const { middlewares = [], inputs, meta, ...rest } = def2;\n    return createBuilder({\n        ...(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_1__.mergeWithoutOverrides)(def1, rest),\n        inputs: [\n            ...def1.inputs,\n            ...inputs ?? []\n        ],\n        middlewares: [\n            ...def1.middlewares,\n            ...middlewares\n        ],\n        meta: def1.meta && meta ? {\n            ...def1.meta,\n            ...meta\n        } : meta ?? def1.meta\n    });\n}\nfunction createBuilder(initDef = {}) {\n    const _def = {\n        procedure: true,\n        inputs: [],\n        middlewares: [],\n        ...initDef\n    };\n    const builder = {\n        _def,\n        input (input) {\n            const parser = getParseFn(input);\n            return createNewBuilder(_def, {\n                inputs: [\n                    input\n                ],\n                middlewares: [\n                    createInputMiddleware(parser)\n                ]\n            });\n        },\n        output (output) {\n            const parser = getParseFn(output);\n            return createNewBuilder(_def, {\n                output,\n                middlewares: [\n                    createOutputMiddleware(parser)\n                ]\n            });\n        },\n        meta (meta) {\n            return createNewBuilder(_def, {\n                meta\n            });\n        },\n        use (middlewareBuilderOrFn) {\n            const middlewares = \"_middlewares\" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                middlewareBuilderOrFn\n            ];\n            return createNewBuilder(_def, {\n                middlewares\n            });\n        },\n        unstable_concat (builder$1) {\n            return createNewBuilder(_def, builder$1._def);\n        },\n        concat (builder$1) {\n            return createNewBuilder(_def, builder$1._def);\n        },\n        query (resolver) {\n            return createResolver({\n                ..._def,\n                type: \"query\"\n            }, resolver);\n        },\n        mutation (resolver) {\n            return createResolver({\n                ..._def,\n                type: \"mutation\"\n            }, resolver);\n        },\n        subscription (resolver) {\n            return createResolver({\n                ..._def,\n                type: \"subscription\"\n            }, resolver);\n        },\n        experimental_caller (caller) {\n            return createNewBuilder(_def, {\n                caller\n            });\n        }\n    };\n    return builder;\n}\nfunction createResolver(_defIn, resolver) {\n    const finalBuilder = createNewBuilder(_defIn, {\n        resolver,\n        middlewares: [\n            async function resolveMiddleware(opts) {\n                const data = await resolver(opts);\n                return {\n                    marker: middlewareMarker,\n                    ok: true,\n                    data,\n                    ctx: opts.ctx\n                };\n            }\n        ]\n    });\n    const _def = {\n        ...finalBuilder._def,\n        type: _defIn.type,\n        experimental_caller: Boolean(finalBuilder._def.caller),\n        meta: finalBuilder._def.meta,\n        $types: null\n    };\n    const invoke = createProcedureCaller(finalBuilder._def);\n    const callerOverride = finalBuilder._def.caller;\n    if (!callerOverride) return invoke;\n    const callerWrapper = async (...args)=>{\n        return await callerOverride({\n            args,\n            invoke,\n            _def\n        });\n    };\n    callerWrapper._def = _def;\n    return callerWrapper;\n}\nconst codeblock = `\nThis is a client-only function.\nIf you want to call this function on the server, see https://trpc.io/docs/v11/server/server-side-calls\n`.trim();\nasync function callRecursive(index, _def, opts) {\n    try {\n        const middleware = _def.middlewares[index];\n        const result = await middleware({\n            ...opts,\n            meta: _def.meta,\n            input: opts.input,\n            next (_nextOpts) {\n                const nextOpts = _nextOpts;\n                return callRecursive(index + 1, _def, {\n                    ...opts,\n                    ctx: nextOpts?.ctx ? {\n                        ...opts.ctx,\n                        ...nextOpts.ctx\n                    } : opts.ctx,\n                    input: nextOpts && \"input\" in nextOpts ? nextOpts.input : opts.input,\n                    getRawInput: nextOpts?.getRawInput ?? opts.getRawInput\n                });\n            }\n        });\n        return result;\n    } catch (cause) {\n        return {\n            ok: false,\n            error: (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.getTRPCErrorFromUnknown)(cause),\n            marker: middlewareMarker\n        };\n    }\n}\nfunction createProcedureCaller(_def) {\n    async function procedure(opts) {\n        if (!opts || !(\"getRawInput\" in opts)) throw new Error(codeblock);\n        const result = await callRecursive(0, _def, opts);\n        if (!result) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"No result from middlewares - did you forget to `return next()`?\"\n        });\n        if (!result.ok) throw result.error;\n        return result.data;\n    }\n    procedure._def = _def;\n    procedure.procedure = true;\n    procedure.meta = _def.meta;\n    return procedure;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/rootConfig.ts\n/**\n* The default check to see if we're in a server\n*/ const isServerDefault =  true || 0;\n//#endregion\n//#region src/unstable-core-do-not-import/initTRPC.ts\nvar TRPCBuilder = class TRPCBuilder {\n    /**\n\t* Add a context shape as a generic to the root object\n\t* @see https://trpc.io/docs/v11/server/context\n\t*/ context() {\n        return new TRPCBuilder();\n    }\n    /**\n\t* Add a meta shape as a generic to the root object\n\t* @see https://trpc.io/docs/v11/quickstart\n\t*/ meta() {\n        return new TRPCBuilder();\n    }\n    /**\n\t* Create the root object\n\t* @see https://trpc.io/docs/v11/server/routers#initialize-trpc\n\t*/ create(opts) {\n        const config = {\n            ...opts,\n            transformer: (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.getDataTransformer)(opts?.transformer ?? _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultTransformer),\n            isDev: opts?.isDev ?? globalThis.process?.env[\"NODE_ENV\"] !== \"production\",\n            allowOutsideOfServer: opts?.allowOutsideOfServer ?? false,\n            errorFormatter: opts?.errorFormatter ?? _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultFormatter,\n            isServer: opts?.isServer ?? isServerDefault,\n            $types: null\n        };\n        {\n            const isServer = opts?.isServer ?? isServerDefault;\n            if (!isServer && opts?.allowOutsideOfServer !== true) throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);\n        }\n        return {\n            _config: config,\n            procedure: createBuilder({\n                meta: opts?.defaultMeta\n            }),\n            middleware: createMiddlewareFactory(),\n            router: (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.createRouterFactory)(config),\n            mergeRouters: _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.mergeRouters,\n            createCallerFactory: (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_0__.createCallerFactory)()\n        };\n    }\n};\n/**\n* Builder to initialize the tRPC root object - use this exactly once per backend\n* @see https://trpc.io/docs/v11/quickstart\n*/ const initTRPC = new TRPCBuilder();\n//#endregion\n //# sourceMappingURL=initTRPC-COaJMShh.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9pbml0VFJQQy1DT2FKTVNoaC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQThMO0FBQ3ZIO0FBRXZFLHVEQUF1RDtBQUN2RCxjQUFjLEdBQ2QsTUFBTVUsbUJBQW1CO0FBQ3pCOztBQUVBLEdBQ0EsU0FBU0M7SUFDUixTQUFTQyxzQkFBc0JDLFdBQVc7UUFDekMsT0FBTztZQUNOQyxjQUFjRDtZQUNkRSxlQUFjQyxxQkFBcUI7Z0JBQ2xDLE1BQU1DLGtCQUFrQixrQkFBa0JELHdCQUF3QkEsc0JBQXNCRixZQUFZLEdBQUc7b0JBQUNFO2lCQUFzQjtnQkFDOUgsT0FBT0osc0JBQXNCO3VCQUFJQzt1QkFBZ0JJO2lCQUFnQjtZQUNsRTtRQUNEO0lBQ0Q7SUFDQSxTQUFTQyxpQkFBaUJDLEVBQUU7UUFDM0IsT0FBT1Asc0JBQXNCO1lBQUNPO1NBQUc7SUFDbEM7SUFDQSxPQUFPRDtBQUNSO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU1FLG9DQUFvQyxJQUFPO1FBQUVDLFFBQVFWO0lBQTBCO0FBQ3JGOzs7QUFHQSxHQUNBLFNBQVNXLHNCQUFzQkMsS0FBSztJQUNuQyxNQUFNQyxrQkFBa0IsZUFBZUMseUJBQXlCQyxJQUFJO1FBQ25FLElBQUlDO1FBQ0osTUFBTUMsV0FBVyxNQUFNRixLQUFLRyxXQUFXO1FBQ3ZDLElBQUk7WUFDSEYsY0FBYyxNQUFNSixNQUFNSztRQUMzQixFQUFFLE9BQU9FLE9BQU87WUFDZixNQUFNLElBQUk5Qiw0REFBU0EsQ0FBQztnQkFDbkIrQixNQUFNO2dCQUNORDtZQUNEO1FBQ0Q7UUFDQSxNQUFNRSxnQkFBZ0J4Qiw2REFBUUEsQ0FBQ2tCLEtBQUtPLEtBQUssS0FBS3pCLDZEQUFRQSxDQUFDbUIsZUFBZTtZQUNyRSxHQUFHRCxLQUFLTyxLQUFLO1lBQ2Is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QkFBcUJBLDBFQUFtQkE7UUFDekM7SUFDRDtBQUNEO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTXFILFdBQVcsSUFBSVg7QUFFckIsWUFBWTtBQUN3TSxDQUNwTiw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTEuNC4xX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0B0cnBjL3NlcnZlci9kaXN0L2luaXRUUlBDLUNPYUpNU2hoLm1qcz9hZDM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRSUENFcnJvciwgY3JlYXRlQ2FsbGVyRmFjdG9yeSwgY3JlYXRlUm91dGVyRmFjdG9yeSwgZGVmYXVsdEZvcm1hdHRlciwgZGVmYXVsdFRyYW5zZm9ybWVyLCBnZXREYXRhVHJhbnNmb3JtZXIsIGdldFRSUENFcnJvckZyb21Vbmtub3duLCBtZXJnZVJvdXRlcnMgfSBmcm9tIFwiLi90cmFja2VkLUdFV1BvTDBDLm1qc1wiO1xuaW1wb3J0IHsgaXNPYmplY3QsIG1lcmdlV2l0aG91dE92ZXJyaWRlcyB9IGZyb20gXCIuL3V0aWxzLUJIWkpjQlJ2Lm1qc1wiO1xuXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9taWRkbGV3YXJlLnRzXG4vKiogQGludGVybmFsICovXG5jb25zdCBtaWRkbGV3YXJlTWFya2VyID0gXCJtaWRkbGV3YXJlTWFya2VyXCI7XG4vKipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZUZhY3RvcnkoKSB7XG5cdGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVJbm5lcihtaWRkbGV3YXJlcykge1xuXHRcdHJldHVybiB7XG5cdFx0XHRfbWlkZGxld2FyZXM6IG1pZGRsZXdhcmVzLFxuXHRcdFx0dW5zdGFibGVfcGlwZShtaWRkbGV3YXJlQnVpbGRlck9yRm4pIHtcblx0XHRcdFx0Y29uc3QgcGlwZWRNaWRkbGV3YXJlID0gXCJfbWlkZGxld2FyZXNcIiBpbiBtaWRkbGV3YXJlQnVpbGRlck9yRm4gPyBtaWRkbGV3YXJlQnVpbGRlck9yRm4uX21pZGRsZXdhcmVzIDogW21pZGRsZXdhcmVCdWlsZGVyT3JGbl07XG5cdFx0XHRcdHJldHVybiBjcmVhdGVNaWRkbGV3YXJlSW5uZXIoWy4uLm1pZGRsZXdhcmVzLCAuLi5waXBlZE1pZGRsZXdhcmVdKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmUoZm4pIHtcblx0XHRyZXR1cm4gY3JlYXRlTWlkZGxld2FyZUlubmVyKFtmbl0pO1xuXHR9XG5cdHJldHVybiBjcmVhdGVNaWRkbGV3YXJlO1xufVxuLyoqXG4qIENyZWF0ZSBhIHN0YW5kYWxvbmUgbWlkZGxld2FyZVxuKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9zZXJ2ZXIvbWlkZGxld2FyZXMjZXhwZXJpbWVudGFsLXN0YW5kYWxvbmUtbWlkZGxld2FyZXNcbiogQGRlcHJlY2F0ZWQgdXNlIGAuY29uY2F0KClgIGluc3RlYWRcbiovXG5jb25zdCBleHBlcmltZW50YWxfc3RhbmRhbG9uZU1pZGRsZXdhcmUgPSAoKSA9PiAoeyBjcmVhdGU6IGNyZWF0ZU1pZGRsZXdhcmVGYWN0b3J5KCkgfSk7XG4vKipcbiogQGludGVybmFsXG4qIFBsZWFzZSBub3RlLCBgdHJwYy1vcGVuYXBpYCB1c2VzIHRoaXMgZnVuY3Rpb24uXG4qL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRNaWRkbGV3YXJlKHBhcnNlKSB7XG5cdGNvbnN0IGlucHV0TWlkZGxld2FyZSA9IGFzeW5jIGZ1bmN0aW9uIGlucHV0VmFsaWRhdG9yTWlkZGxld2FyZShvcHRzKSB7XG5cdFx0bGV0IHBhcnNlZElucHV0O1xuXHRcdGNvbnN0IHJhd0lucHV0ID0gYXdhaXQgb3B0cy5nZXRSYXdJbnB1dCgpO1xuXHRcdHRyeSB7XG5cdFx0XHRwYXJzZWRJbnB1dCA9IGF3YWl0IHBhcnNlKHJhd0lucHV0KTtcblx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcblx0XHRcdFx0Y2F1c2Vcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRjb25zdCBjb21iaW5lZElucHV0ID0gaXNPYmplY3Qob3B0cy5pbnB1dCkgJiYgaXNPYmplY3QocGFyc2VkSW5wdXQpID8ge1xuXHRcdFx0Li4ub3B0cy5pbnB1dCxcblx0XHRcdC4uLnBhcnNlZElucHV0XG5cdFx0fSA6IHBhcnNlZElucHV0O1xuXHRcdHJldHVybiBvcHRzLm5leHQoeyBpbnB1dDogY29tYmluZWRJbnB1dCB9KTtcblx0fTtcblx0aW5wdXRNaWRkbGV3YXJlLl90eXBlID0gXCJpbnB1dFwiO1xuXHRyZXR1cm4gaW5wdXRNaWRkbGV3YXJlO1xufVxuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGNyZWF0ZU91dHB1dE1pZGRsZXdhcmUocGFyc2UpIHtcblx0Y29uc3Qgb3V0cHV0TWlkZGxld2FyZSA9IGFzeW5jIGZ1bmN0aW9uIG91dHB1dFZhbGlkYXRvck1pZGRsZXdhcmUoeyBuZXh0IH0pIHtcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBuZXh0KCk7XG5cdFx0aWYgKCFyZXN1bHQub2spIHJldHVybiByZXN1bHQ7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCBwYXJzZShyZXN1bHQuZGF0YSk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQuLi5yZXN1bHQsXG5cdFx0XHRcdGRhdGFcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0XHRtZXNzYWdlOiBcIk91dHB1dCB2YWxpZGF0aW9uIGZhaWxlZFwiLFxuXHRcdFx0XHRjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuXHRcdFx0XHRjYXVzZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXHRvdXRwdXRNaWRkbGV3YXJlLl90eXBlID0gXCJvdXRwdXRcIjtcblx0cmV0dXJuIG91dHB1dE1pZGRsZXdhcmU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy92ZW5kb3Ivc3RhbmRhcmQtc2NoZW1hLXYxL2Vycm9yLnRzXG4vKiogQSBzY2hlbWEgZXJyb3Igd2l0aCB1c2VmdWwgaW5mb3JtYXRpb24uICovXG52YXIgU3RhbmRhcmRTY2hlbWFWMUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdC8qKiBUaGUgc2NoZW1hIGlzc3Vlcy4gKi9cblx0aXNzdWVzO1xuXHQvKipcblx0KiBDcmVhdGVzIGEgc2NoZW1hIGVycm9yIHdpdGggdXNlZnVsIGluZm9ybWF0aW9uLlxuXHQqXG5cdCogQHBhcmFtIGlzc3VlcyBUaGUgc2NoZW1hIGlzc3Vlcy5cblx0Ki9cblx0Y29uc3RydWN0b3IoaXNzdWVzKSB7XG5cdFx0c3VwZXIoaXNzdWVzWzBdPy5tZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSBcIlNjaGVtYUVycm9yXCI7XG5cdFx0dGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcGFyc2VyLnRzXG5mdW5jdGlvbiBnZXRQYXJzZUZuKHByb2NlZHVyZVBhcnNlcikge1xuXHRjb25zdCBwYXJzZXIgPSBwcm9jZWR1cmVQYXJzZXI7XG5cdGNvbnN0IGlzU3RhbmRhcmRTY2hlbWEgPSBcIn5zdGFuZGFyZFwiIGluIHBhcnNlcjtcblx0aWYgKHR5cGVvZiBwYXJzZXIgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcGFyc2VyLmFzc2VydCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gcGFyc2VyLmFzc2VydC5iaW5kKHBhcnNlcik7XG5cdGlmICh0eXBlb2YgcGFyc2VyID09PSBcImZ1bmN0aW9uXCIgJiYgIWlzU3RhbmRhcmRTY2hlbWEpIHJldHVybiBwYXJzZXI7XG5cdGlmICh0eXBlb2YgcGFyc2VyLnBhcnNlQXN5bmMgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHBhcnNlci5wYXJzZUFzeW5jLmJpbmQocGFyc2VyKTtcblx0aWYgKHR5cGVvZiBwYXJzZXIucGFyc2UgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHBhcnNlci5wYXJzZS5iaW5kKHBhcnNlcik7XG5cdGlmICh0eXBlb2YgcGFyc2VyLnZhbGlkYXRlU3luYyA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gcGFyc2VyLnZhbGlkYXRlU3luYy5iaW5kKHBhcnNlcik7XG5cdGlmICh0eXBlb2YgcGFyc2VyLmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gcGFyc2VyLmNyZWF0ZS5iaW5kKHBhcnNlcik7XG5cdGlmICh0eXBlb2YgcGFyc2VyLmFzc2VydCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gKHZhbHVlKSA9PiB7XG5cdFx0cGFyc2VyLmFzc2VydCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXHRpZiAoaXNTdGFuZGFyZFNjaGVtYSkgcmV0dXJuIGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlcltcIn5zdGFuZGFyZFwiXS52YWxpZGF0ZSh2YWx1ZSk7XG5cdFx0aWYgKHJlc3VsdC5pc3N1ZXMpIHRocm93IG5ldyBTdGFuZGFyZFNjaGVtYVYxRXJyb3IocmVzdWx0Lmlzc3Vlcyk7XG5cdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0fTtcblx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZGF0b3IgZm5cIik7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcHJvY2VkdXJlQnVpbGRlci50c1xuZnVuY3Rpb24gY3JlYXRlTmV3QnVpbGRlcihkZWYxLCBkZWYyKSB7XG5cdGNvbnN0IHsgbWlkZGxld2FyZXMgPSBbXSwgaW5wdXRzLCBtZXRhLC4uLnJlc3QgfSA9IGRlZjI7XG5cdHJldHVybiBjcmVhdGVCdWlsZGVyKHtcblx0XHQuLi5tZXJnZVdpdGhvdXRPdmVycmlkZXMoZGVmMSwgcmVzdCksXG5cdFx0aW5wdXRzOiBbLi4uZGVmMS5pbnB1dHMsIC4uLmlucHV0cyA/PyBbXV0sXG5cdFx0bWlkZGxld2FyZXM6IFsuLi5kZWYxLm1pZGRsZXdhcmVzLCAuLi5taWRkbGV3YXJlc10sXG5cdFx0bWV0YTogZGVmMS5tZXRhICYmIG1ldGEgPyB7XG5cdFx0XHQuLi5kZWYxLm1ldGEsXG5cdFx0XHQuLi5tZXRhXG5cdFx0fSA6IG1ldGEgPz8gZGVmMS5tZXRhXG5cdH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQnVpbGRlcihpbml0RGVmID0ge30pIHtcblx0Y29uc3QgX2RlZiA9IHtcblx0XHRwcm9jZWR1cmU6IHRydWUsXG5cdFx0aW5wdXRzOiBbXSxcblx0XHRtaWRkbGV3YXJlczogW10sXG5cdFx0Li4uaW5pdERlZlxuXHR9O1xuXHRjb25zdCBidWlsZGVyID0ge1xuXHRcdF9kZWYsXG5cdFx0aW5wdXQoaW5wdXQpIHtcblx0XHRcdGNvbnN0IHBhcnNlciA9IGdldFBhcnNlRm4oaW5wdXQpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuXHRcdFx0XHRpbnB1dHM6IFtpbnB1dF0sXG5cdFx0XHRcdG1pZGRsZXdhcmVzOiBbY3JlYXRlSW5wdXRNaWRkbGV3YXJlKHBhcnNlcildXG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG91dHB1dChvdXRwdXQpIHtcblx0XHRcdGNvbnN0IHBhcnNlciA9IGdldFBhcnNlRm4ob3V0cHV0KTtcblx0XHRcdHJldHVybiBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIHtcblx0XHRcdFx0b3V0cHV0LFxuXHRcdFx0XHRtaWRkbGV3YXJlczogW2NyZWF0ZU91dHB1dE1pZGRsZXdhcmUocGFyc2VyKV1cblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0bWV0YShtZXRhKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7IG1ldGEgfSk7XG5cdFx0fSxcblx0XHR1c2UobWlkZGxld2FyZUJ1aWxkZXJPckZuKSB7XG5cdFx0XHRjb25zdCBtaWRkbGV3YXJlcyA9IFwiX21pZGRsZXdhcmVzXCIgaW4gbWlkZGxld2FyZUJ1aWxkZXJPckZuID8gbWlkZGxld2FyZUJ1aWxkZXJPckZuLl9taWRkbGV3YXJlcyA6IFttaWRkbGV3YXJlQnVpbGRlck9yRm5dO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwgeyBtaWRkbGV3YXJlcyB9KTtcblx0XHR9LFxuXHRcdHVuc3RhYmxlX2NvbmNhdChidWlsZGVyJDEpIHtcblx0XHRcdHJldHVybiBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIGJ1aWxkZXIkMS5fZGVmKTtcblx0XHR9LFxuXHRcdGNvbmNhdChidWlsZGVyJDEpIHtcblx0XHRcdHJldHVybiBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIGJ1aWxkZXIkMS5fZGVmKTtcblx0XHR9LFxuXHRcdHF1ZXJ5KHJlc29sdmVyKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUmVzb2x2ZXIoe1xuXHRcdFx0XHQuLi5fZGVmLFxuXHRcdFx0XHR0eXBlOiBcInF1ZXJ5XCJcblx0XHRcdH0sIHJlc29sdmVyKTtcblx0XHR9LFxuXHRcdG11dGF0aW9uKHJlc29sdmVyKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUmVzb2x2ZXIoe1xuXHRcdFx0XHQuLi5fZGVmLFxuXHRcdFx0XHR0eXBlOiBcIm11dGF0aW9uXCJcblx0XHRcdH0sIHJlc29sdmVyKTtcblx0XHR9LFxuXHRcdHN1YnNjcmlwdGlvbihyZXNvbHZlcikge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVJlc29sdmVyKHtcblx0XHRcdFx0Li4uX2RlZixcblx0XHRcdFx0dHlwZTogXCJzdWJzY3JpcHRpb25cIlxuXHRcdFx0fSwgcmVzb2x2ZXIpO1xuXHRcdH0sXG5cdFx0ZXhwZXJpbWVudGFsX2NhbGxlcihjYWxsZXIpIHtcblx0XHRcdHJldHVybiBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIHsgY2FsbGVyIH0pO1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIGJ1aWxkZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZlcihfZGVmSW4sIHJlc29sdmVyKSB7XG5cdGNvbnN0IGZpbmFsQnVpbGRlciA9IGNyZWF0ZU5ld0J1aWxkZXIoX2RlZkluLCB7XG5cdFx0cmVzb2x2ZXIsXG5cdFx0bWlkZGxld2FyZXM6IFthc3luYyBmdW5jdGlvbiByZXNvbHZlTWlkZGxld2FyZShvcHRzKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcmVzb2x2ZXIob3B0cyk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtYXJrZXI6IG1pZGRsZXdhcmVNYXJrZXIsXG5cdFx0XHRcdG9rOiB0cnVlLFxuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRjdHg6IG9wdHMuY3R4XG5cdFx0XHR9O1xuXHRcdH1dXG5cdH0pO1xuXHRjb25zdCBfZGVmID0ge1xuXHRcdC4uLmZpbmFsQnVpbGRlci5fZGVmLFxuXHRcdHR5cGU6IF9kZWZJbi50eXBlLFxuXHRcdGV4cGVyaW1lbnRhbF9jYWxsZXI6IEJvb2xlYW4oZmluYWxCdWlsZGVyLl9kZWYuY2FsbGVyKSxcblx0XHRtZXRhOiBmaW5hbEJ1aWxkZXIuX2RlZi5tZXRhLFxuXHRcdCR0eXBlczogbnVsbFxuXHR9O1xuXHRjb25zdCBpbnZva2UgPSBjcmVhdGVQcm9jZWR1cmVDYWxsZXIoZmluYWxCdWlsZGVyLl9kZWYpO1xuXHRjb25zdCBjYWxsZXJPdmVycmlkZSA9IGZpbmFsQnVpbGRlci5fZGVmLmNhbGxlcjtcblx0aWYgKCFjYWxsZXJPdmVycmlkZSkgcmV0dXJuIGludm9rZTtcblx0Y29uc3QgY2FsbGVyV3JhcHBlciA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG5cdFx0cmV0dXJuIGF3YWl0IGNhbGxlck92ZXJyaWRlKHtcblx0XHRcdGFyZ3MsXG5cdFx0XHRpbnZva2UsXG5cdFx0XHRfZGVmXG5cdFx0fSk7XG5cdH07XG5cdGNhbGxlcldyYXBwZXIuX2RlZiA9IF9kZWY7XG5cdHJldHVybiBjYWxsZXJXcmFwcGVyO1xufVxuY29uc3QgY29kZWJsb2NrID0gYFxuVGhpcyBpcyBhIGNsaWVudC1vbmx5IGZ1bmN0aW9uLlxuSWYgeW91IHdhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBzZXJ2ZXIsIHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL3NlcnZlci1zaWRlLWNhbGxzXG5gLnRyaW0oKTtcbmFzeW5jIGZ1bmN0aW9uIGNhbGxSZWN1cnNpdmUoaW5kZXgsIF9kZWYsIG9wdHMpIHtcblx0dHJ5IHtcblx0XHRjb25zdCBtaWRkbGV3YXJlID0gX2RlZi5taWRkbGV3YXJlc1tpbmRleF07XG5cdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgbWlkZGxld2FyZSh7XG5cdFx0XHQuLi5vcHRzLFxuXHRcdFx0bWV0YTogX2RlZi5tZXRhLFxuXHRcdFx0aW5wdXQ6IG9wdHMuaW5wdXQsXG5cdFx0XHRuZXh0KF9uZXh0T3B0cykge1xuXHRcdFx0XHRjb25zdCBuZXh0T3B0cyA9IF9uZXh0T3B0cztcblx0XHRcdFx0cmV0dXJuIGNhbGxSZWN1cnNpdmUoaW5kZXggKyAxLCBfZGVmLCB7XG5cdFx0XHRcdFx0Li4ub3B0cyxcblx0XHRcdFx0XHRjdHg6IG5leHRPcHRzPy5jdHggPyB7XG5cdFx0XHRcdFx0XHQuLi5vcHRzLmN0eCxcblx0XHRcdFx0XHRcdC4uLm5leHRPcHRzLmN0eFxuXHRcdFx0XHRcdH0gOiBvcHRzLmN0eCxcblx0XHRcdFx0XHRpbnB1dDogbmV4dE9wdHMgJiYgXCJpbnB1dFwiIGluIG5leHRPcHRzID8gbmV4dE9wdHMuaW5wdXQgOiBvcHRzLmlucHV0LFxuXHRcdFx0XHRcdGdldFJhd0lucHV0OiBuZXh0T3B0cz8uZ2V0UmF3SW5wdXQgPz8gb3B0cy5nZXRSYXdJbnB1dFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRvazogZmFsc2UsXG5cdFx0XHRlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuXHRcdFx0bWFya2VyOiBtaWRkbGV3YXJlTWFya2VyXG5cdFx0fTtcblx0fVxufVxuZnVuY3Rpb24gY3JlYXRlUHJvY2VkdXJlQ2FsbGVyKF9kZWYpIHtcblx0YXN5bmMgZnVuY3Rpb24gcHJvY2VkdXJlKG9wdHMpIHtcblx0XHRpZiAoIW9wdHMgfHwgIShcImdldFJhd0lucHV0XCIgaW4gb3B0cykpIHRocm93IG5ldyBFcnJvcihjb2RlYmxvY2spO1xuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxSZWN1cnNpdmUoMCwgX2RlZiwgb3B0cyk7XG5cdFx0aWYgKCFyZXN1bHQpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcblx0XHRcdG1lc3NhZ2U6IFwiTm8gcmVzdWx0IGZyb20gbWlkZGxld2FyZXMgLSBkaWQgeW91IGZvcmdldCB0byBgcmV0dXJuIG5leHQoKWA/XCJcblx0XHR9KTtcblx0XHRpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0LmVycm9yO1xuXHRcdHJldHVybiByZXN1bHQuZGF0YTtcblx0fVxuXHRwcm9jZWR1cmUuX2RlZiA9IF9kZWY7XG5cdHByb2NlZHVyZS5wcm9jZWR1cmUgPSB0cnVlO1xuXHRwcm9jZWR1cmUubWV0YSA9IF9kZWYubWV0YTtcblx0cmV0dXJuIHByb2NlZHVyZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9yb290Q29uZmlnLnRzXG4vKipcbiogVGhlIGRlZmF1bHQgY2hlY2sgdG8gc2VlIGlmIHdlJ3JlIGluIGEgc2VydmVyXG4qL1xuY29uc3QgaXNTZXJ2ZXJEZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBcIkRlbm9cIiBpbiB3aW5kb3cgfHwgZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/LltcIk5PREVfRU5WXCJdID09PSBcInRlc3RcIiB8fCAhIWdsb2JhbFRoaXMucHJvY2Vzcz8uZW52Py5bXCJKRVNUX1dPUktFUl9JRFwiXSB8fCAhIWdsb2JhbFRoaXMucHJvY2Vzcz8uZW52Py5bXCJWSVRFU1RfV09SS0VSX0lEXCJdO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2luaXRUUlBDLnRzXG52YXIgVFJQQ0J1aWxkZXIgPSBjbGFzcyBUUlBDQnVpbGRlciB7XG5cdC8qKlxuXHQqIEFkZCBhIGNvbnRleHQgc2hhcGUgYXMgYSBnZW5lcmljIHRvIHRoZSByb290IG9iamVjdFxuXHQqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL3NlcnZlci9jb250ZXh0XG5cdCovXG5cdGNvbnRleHQoKSB7XG5cdFx0cmV0dXJuIG5ldyBUUlBDQnVpbGRlcigpO1xuXHR9XG5cdC8qKlxuXHQqIEFkZCBhIG1ldGEgc2hhcGUgYXMgYSBnZW5lcmljIHRvIHRoZSByb290IG9iamVjdFxuXHQqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL3F1aWNrc3RhcnRcblx0Ki9cblx0bWV0YSgpIHtcblx0XHRyZXR1cm4gbmV3IFRSUENCdWlsZGVyKCk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlIHRoZSByb290IG9iamVjdFxuXHQqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL3NlcnZlci9yb3V0ZXJzI2luaXRpYWxpemUtdHJwY1xuXHQqL1xuXHRjcmVhdGUob3B0cykge1xuXHRcdGNvbnN0IGNvbmZpZyA9IHtcblx0XHRcdC4uLm9wdHMsXG5cdFx0XHR0cmFuc2Zvcm1lcjogZ2V0RGF0YVRyYW5zZm9ybWVyKG9wdHM/LnRyYW5zZm9ybWVyID8/IGRlZmF1bHRUcmFuc2Zvcm1lciksXG5cdFx0XHRpc0Rldjogb3B0cz8uaXNEZXYgPz8gZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnZbXCJOT0RFX0VOVlwiXSAhPT0gXCJwcm9kdWN0aW9uXCIsXG5cdFx0XHRhbGxvd091dHNpZGVPZlNlcnZlcjogb3B0cz8uYWxsb3dPdXRzaWRlT2ZTZXJ2ZXIgPz8gZmFsc2UsXG5cdFx0XHRlcnJvckZvcm1hdHRlcjogb3B0cz8uZXJyb3JGb3JtYXR0ZXIgPz8gZGVmYXVsdEZvcm1hdHRlcixcblx0XHRcdGlzU2VydmVyOiBvcHRzPy5pc1NlcnZlciA/PyBpc1NlcnZlckRlZmF1bHQsXG5cdFx0XHQkdHlwZXM6IG51bGxcblx0XHR9O1xuXHRcdHtcblx0XHRcdGNvbnN0IGlzU2VydmVyID0gb3B0cz8uaXNTZXJ2ZXIgPz8gaXNTZXJ2ZXJEZWZhdWx0O1xuXHRcdFx0aWYgKCFpc1NlcnZlciAmJiBvcHRzPy5hbGxvd091dHNpZGVPZlNlcnZlciAhPT0gdHJ1ZSkgdGhyb3cgbmV3IEVycm9yKGBZb3UncmUgdHJ5aW5nIHRvIHVzZSBAdHJwYy9zZXJ2ZXIgaW4gYSBub24tc2VydmVyIGVudmlyb25tZW50LiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZGVmYXVsdC5gKTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdF9jb25maWc6IGNvbmZpZyxcblx0XHRcdHByb2NlZHVyZTogY3JlYXRlQnVpbGRlcih7IG1ldGE6IG9wdHM/LmRlZmF1bHRNZXRhIH0pLFxuXHRcdFx0bWlkZGxld2FyZTogY3JlYXRlTWlkZGxld2FyZUZhY3RvcnkoKSxcblx0XHRcdHJvdXRlcjogY3JlYXRlUm91dGVyRmFjdG9yeShjb25maWcpLFxuXHRcdFx0bWVyZ2VSb3V0ZXJzLFxuXHRcdFx0Y3JlYXRlQ2FsbGVyRmFjdG9yeTogY3JlYXRlQ2FsbGVyRmFjdG9yeSgpXG5cdFx0fTtcblx0fVxufTtcbi8qKlxuKiBCdWlsZGVyIHRvIGluaXRpYWxpemUgdGhlIHRSUEMgcm9vdCBvYmplY3QgLSB1c2UgdGhpcyBleGFjdGx5IG9uY2UgcGVyIGJhY2tlbmRcbiogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvcXVpY2tzdGFydFxuKi9cbmNvbnN0IGluaXRUUlBDID0gbmV3IFRSUENCdWlsZGVyKCk7XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgU3RhbmRhcmRTY2hlbWFWMUVycm9yLCBjcmVhdGVCdWlsZGVyLCBjcmVhdGVJbnB1dE1pZGRsZXdhcmUsIGNyZWF0ZU1pZGRsZXdhcmVGYWN0b3J5LCBjcmVhdGVPdXRwdXRNaWRkbGV3YXJlLCBleHBlcmltZW50YWxfc3RhbmRhbG9uZU1pZGRsZXdhcmUsIGdldFBhcnNlRm4sIGluaXRUUlBDLCBpc1NlcnZlckRlZmF1bHQsIG1pZGRsZXdhcmVNYXJrZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXRUUlBDLUNPYUpNU2hoLm1qcy5tYXAiXSwibmFtZXMiOlsiVFJQQ0Vycm9yIiwiY3JlYXRlQ2FsbGVyRmFjdG9yeSIsImNyZWF0ZVJvdXRlckZhY3RvcnkiLCJkZWZhdWx0Rm9ybWF0dGVyIiwiZGVmYXVsdFRyYW5zZm9ybWVyIiwiZ2V0RGF0YVRyYW5zZm9ybWVyIiwiZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24iLCJtZXJnZVJvdXRlcnMiLCJpc09iamVjdCIsIm1lcmdlV2l0aG91dE92ZXJyaWRlcyIsIm1pZGRsZXdhcmVNYXJrZXIiLCJjcmVhdGVNaWRkbGV3YXJlRmFjdG9yeSIsImNyZWF0ZU1pZGRsZXdhcmVJbm5lciIsIm1pZGRsZXdhcmVzIiwiX21pZGRsZXdhcmVzIiwidW5zdGFibGVfcGlwZSIsIm1pZGRsZXdhcmVCdWlsZGVyT3JGbiIsInBpcGVkTWlkZGxld2FyZSIsImNyZWF0ZU1pZGRsZXdhcmUiLCJmbiIsImV4cGVyaW1lbnRhbF9zdGFuZGFsb25lTWlkZGxld2FyZSIsImNyZWF0ZSIsImNyZWF0ZUlucHV0TWlkZGxld2FyZSIsInBhcnNlIiwiaW5wdXRNaWRkbGV3YXJlIiwiaW5wdXRWYWxpZGF0b3JNaWRkbGV3YXJlIiwib3B0cyIsInBhcnNlZElucHV0IiwicmF3SW5wdXQiLCJnZXRSYXdJbnB1dCIsImNhdXNlIiwiY29kZSIsImNvbWJpbmVkSW5wdXQiLCJpbnB1dCIsIm5leHQiLCJfdHlwZSIsImNyZWF0ZU91dHB1dE1pZGRsZXdhcmUiLCJvdXRwdXRNaWRkbGV3YXJlIiwib3V0cHV0VmFsaWRhdG9yTWlkZGxld2FyZSIsInJlc3VsdCIsIm9rIiwiZGF0YSIsIm1lc3NhZ2UiLCJTdGFuZGFyZFNjaGVtYVYxRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiaXNzdWVzIiwibmFtZSIsImdldFBhcnNlRm4iLCJwcm9jZWR1cmVQYXJzZXIiLCJwYXJzZXIiLCJpc1N0YW5kYXJkU2NoZW1hIiwiYXNzZXJ0IiwiYmluZCIsInBhcnNlQXN5bmMiLCJ2YWxpZGF0ZVN5bmMiLCJ2YWx1ZSIsInZhbGlkYXRlIiwiY3JlYXRlTmV3QnVpbGRlciIsImRlZjEiLCJkZWYyIiwiaW5wdXRzIiwibWV0YSIsInJlc3QiLCJjcmVhdGVCdWlsZGVyIiwiaW5pdERlZiIsIl9kZWYiLCJwcm9jZWR1cmUiLCJidWlsZGVyIiwib3V0cHV0IiwidXNlIiwidW5zdGFibGVfY29uY2F0IiwiYnVpbGRlciQxIiwiY29uY2F0IiwicXVlcnkiLCJyZXNvbHZlciIsImNyZWF0ZVJlc29sdmVyIiwidHlwZSIsIm11dGF0aW9uIiwic3Vic2NyaXB0aW9uIiwiZXhwZXJpbWVudGFsX2NhbGxlciIsImNhbGxlciIsIl9kZWZJbiIsImZpbmFsQnVpbGRlciIsInJlc29sdmVNaWRkbGV3YXJlIiwibWFya2VyIiwiY3R4IiwiQm9vbGVhbiIsIiR0eXBlcyIsImludm9rZSIsImNyZWF0ZVByb2NlZHVyZUNhbGxlciIsImNhbGxlck92ZXJyaWRlIiwiY2FsbGVyV3JhcHBlciIsImFyZ3MiLCJjb2RlYmxvY2siLCJ0cmltIiwiY2FsbFJlY3Vyc2l2ZSIsImluZGV4IiwibWlkZGxld2FyZSIsIl9uZXh0T3B0cyIsIm5leHRPcHRzIiwiZXJyb3IiLCJpc1NlcnZlckRlZmF1bHQiLCJ3aW5kb3ciLCJnbG9iYWxUaGlzIiwicHJvY2VzcyIsImVudiIsIlRSUENCdWlsZGVyIiwiY29udGV4dCIsImNvbmZpZyIsInRyYW5zZm9ybWVyIiwiaXNEZXYiLCJhbGxvd091dHNpZGVPZlNlcnZlciIsImVycm9yRm9ybWF0dGVyIiwiaXNTZXJ2ZXIiLCJfY29uZmlnIiwiZGVmYXVsdE1ldGEiLCJyb3V0ZXIiLCJpbml0VFJQQyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/initTRPC-COaJMShh.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isObservable: () => (/* binding */ isObservable),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   observableToAsyncIterable: () => (/* binding */ observableToAsyncIterable),\n/* harmony export */   observableToPromise: () => (/* binding */ observableToPromise)\n/* harmony export */ });\n//#region src/observable/observable.ts\n/** @public */ function isObservable(x) {\n    return typeof x === \"object\" && x !== null && \"subscribe\" in x;\n}\n/** @public */ function observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) return;\n                unsubscribed = true;\n                if (typeof teardownRef === \"function\") teardownRef();\n                else if (teardownRef) teardownRef.unsubscribe();\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    if (isDone) return;\n                    observer.next?.(value);\n                },\n                error (err) {\n                    if (isDone) return;\n                    isDone = true;\n                    observer.error?.(err);\n                    unsubscribe();\n                },\n                complete () {\n                    if (isDone) return;\n                    isDone = true;\n                    observer.complete?.();\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) unsubscribe();\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return operations.reduce(pipeReducer, self);\n        }\n    };\n    return self;\n}\nfunction pipeReducer(prev, fn) {\n    return fn(prev);\n}\n/** @internal */ function observableToPromise(observable$1) {\n    const ac = new AbortController();\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) return;\n            isDone = true;\n            obs$.unsubscribe();\n        }\n        ac.signal.addEventListener(\"abort\", ()=>{\n            reject(ac.signal.reason);\n        });\n        const obs$ = observable$1.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                reject(data);\n            },\n            complete () {\n                ac.abort();\n                onDone();\n            }\n        });\n    });\n    return promise;\n}\n/**\n* @internal\n*/ function observableToReadableStream(observable$1, signal) {\n    let unsub = null;\n    const onAbort = ()=>{\n        unsub?.unsubscribe();\n        unsub = null;\n        signal.removeEventListener(\"abort\", onAbort);\n    };\n    return new ReadableStream({\n        start (controller) {\n            unsub = observable$1.subscribe({\n                next (data) {\n                    controller.enqueue({\n                        ok: true,\n                        value: data\n                    });\n                },\n                error (error) {\n                    controller.enqueue({\n                        ok: false,\n                        error\n                    });\n                    controller.close();\n                },\n                complete () {\n                    controller.close();\n                }\n            });\n            if (signal.aborted) onAbort();\n            else signal.addEventListener(\"abort\", onAbort, {\n                once: true\n            });\n        },\n        cancel () {\n            onAbort();\n        }\n    });\n}\n/** @internal */ function observableToAsyncIterable(observable$1, signal) {\n    const stream = observableToReadableStream(observable$1, signal);\n    const reader = stream.getReader();\n    const iterator = {\n        async next () {\n            const value = await reader.read();\n            if (value.done) return {\n                value: void 0,\n                done: true\n            };\n            const { value: result } = value;\n            if (!result.ok) throw result.error;\n            return {\n                value: result.value,\n                done: false\n            };\n        },\n        async return () {\n            await reader.cancel();\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n    };\n    return {\n        [Symbol.asyncIterator] () {\n            return iterator;\n        }\n    };\n}\n//#endregion\n //# sourceMappingURL=observable-B1orLHHI.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLUIxb3JMSEhJLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsc0NBQXNDO0FBQ3RDLFlBQVksR0FDWixTQUFTQSxhQUFhQyxDQUFDO0lBQ3RCLE9BQU8sT0FBT0EsTUFBTSxZQUFZQSxNQUFNLFFBQVEsZUFBZUE7QUFDOUQ7QUFDQSxZQUFZLEdBQ1osU0FBU0MsV0FBV0MsU0FBUztJQUM1QixNQUFNQyxPQUFPO1FBQ1pELFdBQVVFLFFBQVE7WUFDakIsSUFBSUMsY0FBYztZQUNsQixJQUFJQyxTQUFTO1lBQ2IsSUFBSUMsZUFBZTtZQUNuQixJQUFJQyxzQkFBc0I7WUFDMUIsU0FBU0M7Z0JBQ1IsSUFBSUosZ0JBQWdCLE1BQU07b0JBQ3pCRyxzQkFBc0I7b0JBQ3RCO2dCQUNEO2dCQUNBLElBQUlELGNBQWM7Z0JBQ2xCQSxlQUFlO2dCQUNmLElBQUksT0FBT0YsZ0JBQWdCLFlBQVlBO3FCQUNsQyxJQUFJQSxhQUFhQSxZQUFZSSxXQUFXO1lBQzlDO1lBQ0FKLGNBQWNILFVBQVU7Z0JBQ3ZCUSxNQUFLQyxLQUFLO29CQUNULElBQUlMLFFBQVE7b0JBQ1pGLFNBQVNNLElBQUksR0FBR0M7Z0JBQ2pCO2dCQUNBQyxPQUFNQyxHQUFHO29CQUNSLElBQUlQLFFBQVE7b0JBQ1pBLFNBQVM7b0JBQ1RGLFNBQVNRLEtBQUssR0FBR0M7b0JBQ2pCSjtnQkFDRDtnQkFDQUs7b0JBQ0MsSUFBSVIsUUFBUTtvQkFDWkEsU0FBUztvQkFDVEYsU0FBU1UsUUFBUTtvQkFDakJMO2dCQUNEO1lBQ0Q7WUFDQSxJQUFJRCxxQkFBcUJDO1lBQ3pCLE9BQU87Z0JBQUVBO1lBQVk7UUFDdEI7UUFDQU0sTUFBSyxHQUFHQyxVQUFVO1lBQ2pCLE9BQU9BLFdBQVdDLE1BQU0sQ0FBQ0MsYUFBYWY7UUFDdkM7SUFDRDtJQUNBLE9BQU9BO0FBQ1I7QUFDQSxTQUFTZSxZQUFZQyxJQUFJLEVBQUVDLEVBQUU7SUFDNUIsT0FBT0EsR0FBR0Q7QUFDWDtBQUNBLGNBQWMsR0FDZCxTQUFTRSxvQkFBb0JDLFlBQVk7SUFDeEMsTUFBTUMsS0FBSyxJQUFJQztJQUNmLE1BQU1DLFVBQVUsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUNyQyxJQUFJdEIsU0FBUztRQUNiLFNBQVN1QjtZQUNSLElBQUl2QixRQUFRO1lBQ1pBLFNBQVM7WUFDVHdCLEtBQUtyQixXQUFXO1FBQ2pCO1FBQ0FjLEdBQUdRLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUMsU0FBUztZQUNuQ0osT0FBT0wsR0FBR1EsTUFBTSxDQUFDRSxNQUFNO1FBQ3hCO1FBQ0EsTUFBTUgsT0FBT1IsYUFBYXBCLFNBQVMsQ0FBQztZQUNuQ1EsTUFBS3dCLElBQUk7Z0JBQ1I1QixTQUFTO2dCQUNUcUIsUUFBUU87Z0JBQ1JMO1lBQ0Q7WUFDQWpCLE9BQU1zQixJQUFJO2dCQUNUTixPQUFPTTtZQUNSO1lBQ0FwQjtnQkFDQ1MsR0FBR1ksS0FBSztnQkFDUk47WUFDRDtRQUNEO0lBQ0Q7SUFDQSxPQUFPSjtBQUNSO0FBQ0E7O0FBRUEsR0FDQSxTQUFTVywyQkFBMkJkLFlBQVksRUFBRVMsTUFBTTtJQUN2RCxJQUFJTSxRQUFRO0lBQ1osTUFBTUMsVUFBVTtRQUNmRCxPQUFPNUI7UUFDUDRCLFFBQVE7UUFDUk4sT0FBT1EsbUJBQW1CLENBQUMsU0FBU0Q7SUFDckM7SUFDQSxPQUFPLElBQUlFLGVBQWU7UUFDekJDLE9BQU1DLFVBQVU7WUFDZkwsUUFBUWYsYUFBYXBCLFNBQVMsQ0FBQztnQkFDOUJRLE1BQUt3QixJQUFJO29CQUNSUSxXQUFXQyxPQUFPLENBQUM7d0JBQ2xCQyxJQUFJO3dCQUNKakMsT0FBT3VCO29CQUNSO2dCQUNEO2dCQUNBdEIsT0FBTUEsS0FBSztvQkFDVjhCLFdBQVdDLE9BQU8sQ0FBQzt3QkFDbEJDLElBQUk7d0JBQ0poQztvQkFDRDtvQkFDQThCLFdBQVdHLEtBQUs7Z0JBQ2pCO2dCQUNBL0I7b0JBQ0M0QixXQUFXRyxLQUFLO2dCQUNqQjtZQUNEO1lBQ0EsSUFBSWQsT0FBT2UsT0FBTyxFQUFFUjtpQkFDZlAsT0FBT0MsZ0JBQWdCLENBQUMsU0FBU00sU0FBUztnQkFBRVMsTUFBTTtZQUFLO1FBQzdEO1FBQ0FDO1lBQ0NWO1FBQ0Q7SUFDRDtBQUNEO0FBQ0EsY0FBYyxHQUNkLFNBQVNXLDBCQUEwQjNCLFlBQVksRUFBRVMsTUFBTTtJQUN0RCxNQUFNbUIsU0FBU2QsMkJBQTJCZCxjQUFjUztJQUN4RCxNQUFNb0IsU0FBU0QsT0FBT0UsU0FBUztJQUMvQixNQUFNQyxXQUFXO1FBQ2hCLE1BQU0zQztZQUNMLE1BQU1DLFFBQVEsTUFBTXdDLE9BQU9HLElBQUk7WUFDL0IsSUFBSTNDLE1BQU00QyxJQUFJLEVBQUUsT0FBTztnQkFDdEI1QyxPQUFPLEtBQUs7Z0JBQ1o0QyxNQUFNO1lBQ1A7WUFDQSxNQUFNLEVBQUU1QyxPQUFPNkMsTUFBTSxFQUFFLEdBQUc3QztZQUMxQixJQUFJLENBQUM2QyxPQUFPWixFQUFFLEVBQUUsTUFBTVksT0FBTzVDLEtBQUs7WUFDbEMsT0FBTztnQkFDTkQsT0FBTzZDLE9BQU83QyxLQUFLO2dCQUNuQjRDLE1BQU07WUFDUDtRQUNEO1FBQ0EsTUFBTUU7WUFDTCxNQUFNTixPQUFPSCxNQUFNO1lBQ25CLE9BQU87Z0JBQ05yQyxPQUFPLEtBQUs7Z0JBQ1o0QyxNQUFNO1lBQ1A7UUFDRDtJQUNEO0lBQ0EsT0FBTztRQUFFLENBQUNHLE9BQU9DLGFBQWEsQ0FBQztZQUM5QixPQUFPTjtRQUNSO0lBQUU7QUFDSDtBQUVBLFlBQVk7QUFDd0UsQ0FDcEYsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLUIxb3JMSEhJLm1qcz8zYmU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vI3JlZ2lvbiBzcmMvb2JzZXJ2YWJsZS9vYnNlcnZhYmxlLnRzXG4vKiogQHB1YmxpYyAqL1xuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHgpIHtcblx0cmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGwgJiYgXCJzdWJzY3JpYmVcIiBpbiB4O1xufVxuLyoqIEBwdWJsaWMgKi9cbmZ1bmN0aW9uIG9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG5cdGNvbnN0IHNlbGYgPSB7XG5cdFx0c3Vic2NyaWJlKG9ic2VydmVyKSB7XG5cdFx0XHRsZXQgdGVhcmRvd25SZWYgPSBudWxsO1xuXHRcdFx0bGV0IGlzRG9uZSA9IGZhbHNlO1xuXHRcdFx0bGV0IHVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuXHRcdFx0bGV0IHRlYXJkb3duSW1tZWRpYXRlbHkgPSBmYWxzZTtcblx0XHRcdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuXHRcdFx0XHRpZiAodGVhcmRvd25SZWYgPT09IG51bGwpIHtcblx0XHRcdFx0XHR0ZWFyZG93bkltbWVkaWF0ZWx5ID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHVuc3Vic2NyaWJlZCkgcmV0dXJuO1xuXHRcdFx0XHR1bnN1YnNjcmliZWQgPSB0cnVlO1xuXHRcdFx0XHRpZiAodHlwZW9mIHRlYXJkb3duUmVmID09PSBcImZ1bmN0aW9uXCIpIHRlYXJkb3duUmVmKCk7XG5cdFx0XHRcdGVsc2UgaWYgKHRlYXJkb3duUmVmKSB0ZWFyZG93blJlZi51bnN1YnNjcmliZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGVhcmRvd25SZWYgPSBzdWJzY3JpYmUoe1xuXHRcdFx0XHRuZXh0KHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKGlzRG9uZSkgcmV0dXJuO1xuXHRcdFx0XHRcdG9ic2VydmVyLm5leHQ/Lih2YWx1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yKGVycikge1xuXHRcdFx0XHRcdGlmIChpc0RvbmUpIHJldHVybjtcblx0XHRcdFx0XHRpc0RvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdG9ic2VydmVyLmVycm9yPy4oZXJyKTtcblx0XHRcdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0XHRpZiAoaXNEb25lKSByZXR1cm47XG5cdFx0XHRcdFx0aXNEb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG5cdFx0XHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAodGVhcmRvd25JbW1lZGlhdGVseSkgdW5zdWJzY3JpYmUoKTtcblx0XHRcdHJldHVybiB7IHVuc3Vic2NyaWJlIH07XG5cdFx0fSxcblx0XHRwaXBlKC4uLm9wZXJhdGlvbnMpIHtcblx0XHRcdHJldHVybiBvcGVyYXRpb25zLnJlZHVjZShwaXBlUmVkdWNlciwgc2VsZik7XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIHBpcGVSZWR1Y2VyKHByZXYsIGZuKSB7XG5cdHJldHVybiBmbihwcmV2KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG9ic2VydmFibGVUb1Byb21pc2Uob2JzZXJ2YWJsZSQxKSB7XG5cdGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHRjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGxldCBpc0RvbmUgPSBmYWxzZTtcblx0XHRmdW5jdGlvbiBvbkRvbmUoKSB7XG5cdFx0XHRpZiAoaXNEb25lKSByZXR1cm47XG5cdFx0XHRpc0RvbmUgPSB0cnVlO1xuXHRcdFx0b2JzJC51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0XHRhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcblx0XHRcdHJlamVjdChhYy5zaWduYWwucmVhc29uKTtcblx0XHR9KTtcblx0XHRjb25zdCBvYnMkID0gb2JzZXJ2YWJsZSQxLnN1YnNjcmliZSh7XG5cdFx0XHRuZXh0KGRhdGEpIHtcblx0XHRcdFx0aXNEb25lID0gdHJ1ZTtcblx0XHRcdFx0cmVzb2x2ZShkYXRhKTtcblx0XHRcdFx0b25Eb25lKCk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3IoZGF0YSkge1xuXHRcdFx0XHRyZWplY3QoZGF0YSk7XG5cdFx0XHR9LFxuXHRcdFx0Y29tcGxldGUoKSB7XG5cdFx0XHRcdGFjLmFib3J0KCk7XG5cdFx0XHRcdG9uRG9uZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIHByb21pc2U7XG59XG4vKipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW0ob2JzZXJ2YWJsZSQxLCBzaWduYWwpIHtcblx0bGV0IHVuc3ViID0gbnVsbDtcblx0Y29uc3Qgb25BYm9ydCA9ICgpID0+IHtcblx0XHR1bnN1Yj8udW5zdWJzY3JpYmUoKTtcblx0XHR1bnN1YiA9IG51bGw7XG5cdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcblx0fTtcblx0cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG5cdFx0c3RhcnQoY29udHJvbGxlcikge1xuXHRcdFx0dW5zdWIgPSBvYnNlcnZhYmxlJDEuc3Vic2NyaWJlKHtcblx0XHRcdFx0bmV4dChkYXRhKSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0XHRcdG9rOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGRhdGFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdFx0b2s6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoc2lnbmFsLmFib3J0ZWQpIG9uQWJvcnQoKTtcblx0XHRcdGVsc2Ugc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0LCB7IG9uY2U6IHRydWUgfSk7XG5cdFx0fSxcblx0XHRjYW5jZWwoKSB7XG5cdFx0XHRvbkFib3J0KCk7XG5cdFx0fVxuXHR9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUob2JzZXJ2YWJsZSQxLCBzaWduYWwpIHtcblx0Y29uc3Qgc3RyZWFtID0gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW0ob2JzZXJ2YWJsZSQxLCBzaWduYWwpO1xuXHRjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdGNvbnN0IGl0ZXJhdG9yID0ge1xuXHRcdGFzeW5jIG5leHQoKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cdFx0XHRpZiAodmFsdWUuZG9uZSkgcmV0dXJuIHtcblx0XHRcdFx0dmFsdWU6IHZvaWQgMCxcblx0XHRcdFx0ZG9uZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHRcdGNvbnN0IHsgdmFsdWU6IHJlc3VsdCB9ID0gdmFsdWU7XG5cdFx0XHRpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0LmVycm9yO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dmFsdWU6IHJlc3VsdC52YWx1ZSxcblx0XHRcdFx0ZG9uZTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fSxcblx0XHRhc3luYyByZXR1cm4oKSB7XG5cdFx0XHRhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogdm9pZCAwLFxuXHRcdFx0XHRkb25lOiB0cnVlXG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIHsgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcblx0XHRyZXR1cm4gaXRlcmF0b3I7XG5cdH0gfTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBpc09ic2VydmFibGUsIG9ic2VydmFibGUsIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUsIG9ic2VydmFibGVUb1Byb21pc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUtQjFvckxISEkubWpzLm1hcCJdLCJuYW1lcyI6WyJpc09ic2VydmFibGUiLCJ4Iiwib2JzZXJ2YWJsZSIsInN1YnNjcmliZSIsInNlbGYiLCJvYnNlcnZlciIsInRlYXJkb3duUmVmIiwiaXNEb25lIiwidW5zdWJzY3JpYmVkIiwidGVhcmRvd25JbW1lZGlhdGVseSIsInVuc3Vic2NyaWJlIiwibmV4dCIsInZhbHVlIiwiZXJyb3IiLCJlcnIiLCJjb21wbGV0ZSIsInBpcGUiLCJvcGVyYXRpb25zIiwicmVkdWNlIiwicGlwZVJlZHVjZXIiLCJwcmV2IiwiZm4iLCJvYnNlcnZhYmxlVG9Qcm9taXNlIiwib2JzZXJ2YWJsZSQxIiwiYWMiLCJBYm9ydENvbnRyb2xsZXIiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbkRvbmUiLCJvYnMkIiwic2lnbmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlYXNvbiIsImRhdGEiLCJhYm9ydCIsIm9ic2VydmFibGVUb1JlYWRhYmxlU3RyZWFtIiwidW5zdWIiLCJvbkFib3J0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyIiwiZW5xdWV1ZSIsIm9rIiwiY2xvc2UiLCJhYm9ydGVkIiwib25jZSIsImNhbmNlbCIsIm9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUiLCJzdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJpdGVyYXRvciIsInJlYWQiLCJkb25lIiwicmVzdWx0IiwicmV0dXJuIiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-DPbYgJDD.mjs":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-DPbYgJDD.mjs ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Unpromise: () => (/* binding */ Unpromise),\n/* harmony export */   __commonJS: () => (/* binding */ __commonJS),\n/* harmony export */   __toESM: () => (/* binding */ __toESM),\n/* harmony export */   createDeferred: () => (/* binding */ createDeferred),\n/* harmony export */   getRequestInfo: () => (/* binding */ getRequestInfo),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   iteratorResource: () => (/* binding */ iteratorResource),\n/* harmony export */   jsonlStreamConsumer: () => (/* binding */ jsonlStreamConsumer),\n/* harmony export */   jsonlStreamProducer: () => (/* binding */ jsonlStreamProducer),\n/* harmony export */   makeAsyncResource: () => (/* binding */ makeAsyncResource),\n/* harmony export */   makeResource: () => (/* binding */ makeResource),\n/* harmony export */   parseConnectionParamsFromString: () => (/* binding */ parseConnectionParamsFromString),\n/* harmony export */   parseConnectionParamsFromUnknown: () => (/* binding */ parseConnectionParamsFromUnknown),\n/* harmony export */   require_usingCtx: () => (/* binding */ require_usingCtx),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   sseHeaders: () => (/* binding */ sseHeaders),\n/* harmony export */   sseStreamConsumer: () => (/* binding */ sseStreamConsumer),\n/* harmony export */   sseStreamProducer: () => (/* binding */ sseStreamProducer),\n/* harmony export */   takeWithGrace: () => (/* binding */ takeWithGrace),\n/* harmony export */   throwAbortError: () => (/* binding */ throwAbortError),\n/* harmony export */   withMaxDuration: () => (/* binding */ withMaxDuration)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getErrorShape-DyYil4aT.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs\");\n/* harmony import */ var _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracked-GEWPoL0C.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs\");\n/* harmony import */ var _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-BHZJcBRv.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\");\n/* harmony import */ var _observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observable-B1orLHHI.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/observable-B1orLHHI.mjs\");\n\n\n\n\n//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod)=>function() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") for(var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++){\n        key = keys[i];\n        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ((k)=>from[k]).bind(null, key),\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\n//#endregion\n//#region src/unstable-core-do-not-import/http/parseConnectionParams.ts\nfunction parseConnectionParamsFromUnknown(parsed) {\n    try {\n        if (parsed === null) return null;\n        if (!(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(parsed)) throw new Error(\"Expected object\");\n        const nonStringValues = Object.entries(parsed).filter(([_key, value])=>typeof value !== \"string\");\n        if (nonStringValues.length > 0) throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value])=>`${key}: ${typeof value}`).join(\", \")}`);\n        return parsed;\n    } catch (cause) {\n        throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"PARSE_ERROR\",\n            message: \"Invalid connection params shape\",\n            cause\n        });\n    }\n}\nfunction parseConnectionParamsFromString(str) {\n    let parsed;\n    try {\n        parsed = JSON.parse(str);\n    } catch (cause) {\n        throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"PARSE_ERROR\",\n            message: \"Not JSON-parsable query params\",\n            cause\n        });\n    }\n    return parseConnectionParamsFromUnknown(parsed);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/http/contentType.ts\n/**\n* Memoize a function that takes no arguments\n* @internal\n*/ function memo(fn) {\n    let promise = null;\n    const sym = Symbol.for(\"@trpc/server/http/memo\");\n    let value = sym;\n    return {\n        read: async ()=>{\n            if (value !== sym) return value;\n            promise ??= fn().catch((cause)=>{\n                if (cause instanceof _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError) throw cause;\n                throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"BAD_REQUEST\",\n                    message: cause instanceof Error ? cause.message : \"Invalid input\",\n                    cause\n                });\n            });\n            value = await promise;\n            promise = null;\n            return value;\n        },\n        result: ()=>{\n            return value !== sym ? value : void 0;\n        }\n    };\n}\nconst jsonContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get(\"content-type\")?.startsWith(\"application/json\");\n    },\n    async parse (opts) {\n        const { req } = opts;\n        const isBatchCall = opts.searchParams.get(\"batch\") === \"1\";\n        const paths = isBatchCall ? opts.path.split(\",\") : [\n            opts.path\n        ];\n        const getInputs = memo(async ()=>{\n            let inputs = void 0;\n            if (req.method === \"GET\") {\n                const queryInput = opts.searchParams.get(\"input\");\n                if (queryInput) inputs = JSON.parse(queryInput);\n            } else inputs = await req.json();\n            if (inputs === void 0) return {};\n            if (!isBatchCall) return {\n                0: opts.router._def._config.transformer.input.deserialize(inputs)\n            };\n            if (!(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(inputs)) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                code: \"BAD_REQUEST\",\n                message: '\"input\" needs to be an object when doing a batch call'\n            });\n            const acc = {};\n            for (const index of paths.keys()){\n                const input = inputs[index];\n                if (input !== void 0) acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n            }\n            return acc;\n        });\n        const calls = await Promise.all(paths.map(async (path, index)=>{\n            const procedure = await (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, path);\n            return {\n                path,\n                procedure,\n                getRawInput: async ()=>{\n                    const inputs = await getInputs.read();\n                    let input = inputs[index];\n                    if (procedure?._def.type === \"subscription\") {\n                        const lastEventId = opts.headers.get(\"last-event-id\") ?? opts.searchParams.get(\"lastEventId\") ?? opts.searchParams.get(\"Last-Event-Id\");\n                        if (lastEventId) if ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) input = {\n                            ...input,\n                            lastEventId\n                        };\n                        else input ??= {\n                            lastEventId\n                        };\n                    }\n                    return input;\n                },\n                result: ()=>{\n                    return getInputs.result()?.[index];\n                }\n            };\n        }));\n        const types = new Set(calls.map((call)=>call.procedure?._def.type).filter(Boolean));\n        /* istanbul ignore if -- @preserve */ if (types.size > 1) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Cannot mix procedure types in call: ${Array.from(types).join(\", \")}`\n        });\n        const type = types.values().next().value ?? \"unknown\";\n        const connectionParamsStr = opts.searchParams.get(\"connectionParams\");\n        const info = {\n            isBatchCall,\n            accept: req.headers.get(\"trpc-accept\"),\n            calls,\n            type,\n            connectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n            signal: req.signal,\n            url: opts.url\n        };\n        return info;\n    }\n};\nconst formDataContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get(\"content-type\")?.startsWith(\"multipart/form-data\");\n    },\n    async parse (opts) {\n        const { req } = opts;\n        if (req.method !== \"POST\") throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"METHOD_NOT_SUPPORTED\",\n            message: \"Only POST requests are supported for multipart/form-data requests\"\n        });\n        const getInputs = memo(async ()=>{\n            const fd = await req.formData();\n            return fd;\n        });\n        const procedure = await (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path);\n        return {\n            accept: null,\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure\n                }\n            ],\n            isBatchCall: false,\n            type: \"mutation\",\n            connectionParams: null,\n            signal: req.signal,\n            url: opts.url\n        };\n    }\n};\nconst octetStreamContentTypeHandler = {\n    isMatch (req) {\n        return !!req.headers.get(\"content-type\")?.startsWith(\"application/octet-stream\");\n    },\n    async parse (opts) {\n        const { req } = opts;\n        if (req.method !== \"POST\") throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"METHOD_NOT_SUPPORTED\",\n            message: \"Only POST requests are supported for application/octet-stream requests\"\n        });\n        const getInputs = memo(async ()=>{\n            return req.body;\n        });\n        return {\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure: await (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path)\n                }\n            ],\n            isBatchCall: false,\n            accept: null,\n            type: \"mutation\",\n            connectionParams: null,\n            signal: req.signal,\n            url: opts.url\n        };\n    }\n};\nconst handlers = [\n    jsonContentTypeHandler,\n    formDataContentTypeHandler,\n    octetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n    const handler = handlers.find((handler$1)=>handler$1.isMatch(req));\n    if (handler) return handler;\n    if (!handler && req.method === \"GET\") return jsonContentTypeHandler;\n    throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n        code: \"UNSUPPORTED_MEDIA_TYPE\",\n        message: req.headers.has(\"content-type\") ? `Unsupported content-type \"${req.headers.get(\"content-type\")}` : \"Missing content-type header\"\n    });\n}\nasync function getRequestInfo(opts) {\n    const handler = getContentTypeHandler(opts.req);\n    return await handler.parse(opts);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/http/abortError.ts\nfunction isAbortError(error) {\n    return (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(error) && error[\"name\"] === \"AbortError\";\n}\nfunction throwAbortError(message = \"AbortError\") {\n    throw new DOMException(message, \"AbortError\");\n}\n//#endregion\n//#region src/vendor/unpromise/unpromise.ts\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n* which is retained for the lifetime of the original Promise.\n*/ const subscribableCache = /* @__PURE__ */ new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n* SubscribedPromises (settled promises are not subscribed - they resolve\n* immediately). */ const NOOP = ()=>{};\nlet prop;\n/**\n* Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n* created once, cached and reused throughout the lifetime of the Promise. Get a\n* Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n*\n* The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n* `.then()` and `.catch()` just once. Promises derived from it use a\n* subscription- (and unsubscription-) based mechanism that monitors these\n* handlers.\n*\n* Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n* `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n* `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n* from the original, potentially long-lived Promise, eliminating memory leaks.\n*\n* This approach can eliminate the memory leaks that otherwise come about from\n* repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n* times on the same long-lived native Promise (subscriptions which can never be\n* cleaned up).\n*\n* `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n* any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n* the scenes, `resolve` is implemented simply as\n* `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n* to tidy up!\n*\n*/ var Unpromise = class Unpromise {\n    static{\n        prop = Symbol.toStringTag;\n    }\n    constructor(arg){\n        /** Promises expecting eventual settlement (unless unsubscribed first). This list is deleted\n\t* after the original promise settles - no further notifications will be issued. */ this.subscribers = [];\n        /** The Promise's settlement (recorded when it fulfils or rejects). This is consulted when\n\t* calling .subscribe() .then() .catch() .finally() to see if an immediately-resolving Promise\n\t* can be returned, and therefore subscription can be bypassed. */ this.settlement = null;\n        /** TOSTRING SUPPORT */ this[prop] = \"Unpromise\";\n        if (typeof arg === \"function\") this.promise = new Promise(arg);\n        else this.promise = arg;\n        const thenReturn = this.promise.then((value)=>{\n            const { subscribers } = this;\n            this.subscribers = null;\n            this.settlement = {\n                status: \"fulfilled\",\n                value\n            };\n            subscribers?.forEach(({ resolve })=>{\n                resolve(value);\n            });\n        });\n        if (\"catch\" in thenReturn) thenReturn.catch((reason)=>{\n            const { subscribers } = this;\n            this.subscribers = null;\n            this.settlement = {\n                status: \"rejected\",\n                reason\n            };\n            subscribers?.forEach(({ reject })=>{\n                reject(reason);\n            });\n        });\n    }\n    /** Create a promise that mitigates uncontrolled subscription to a long-lived\n\t* Promise via .then() and .catch() - otherwise a source of memory leaks.\n\t*\n\t* The returned promise has an `unsubscribe()` method which can be called when\n\t* the Promise is no longer being tracked by application logic, and which\n\t* ensures that there is no reference chain from the original promise to the\n\t* new one, and therefore no memory leak.\n\t*\n\t* If original promise has not yet settled, this adds a new unique promise\n\t* that listens to then/catch events, along with an `unsubscribe()` method to\n\t* detach it.\n\t*\n\t* If original promise has settled, then creates a new Promise.resolve() or\n\t* Promise.reject() and provided unsubscribe is a noop.\n\t*\n\t* If you call `unsubscribe()` before the returned Promise has settled, it\n\t* will never settle.\n\t*/ subscribe() {\n        let promise;\n        let unsubscribe;\n        const { settlement } = this;\n        if (settlement === null) {\n            if (this.subscribers === null) throw new Error(\"Unpromise settled but still has subscribers\");\n            const subscriber = withResolvers();\n            this.subscribers = listWithMember(this.subscribers, subscriber);\n            promise = subscriber.promise;\n            unsubscribe = ()=>{\n                if (this.subscribers !== null) this.subscribers = listWithoutMember(this.subscribers, subscriber);\n            };\n        } else {\n            const { status } = settlement;\n            if (status === \"fulfilled\") promise = Promise.resolve(settlement.value);\n            else promise = Promise.reject(settlement.reason);\n            unsubscribe = NOOP;\n        }\n        return Object.assign(promise, {\n            unsubscribe\n        });\n    }\n    /** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */ then(onfulfilled, onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.then(onfulfilled, onrejected), {\n            unsubscribe\n        });\n    }\n    catch(onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.catch(onrejected), {\n            unsubscribe\n        });\n    }\n    finally(onfinally) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.finally(onfinally), {\n            unsubscribe\n        });\n    }\n    /** Unpromise STATIC METHODS */ /** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n\t* of the provided Promise reference) */ static proxy(promise) {\n        const cached = Unpromise.getSubscribablePromise(promise);\n        return typeof cached !== \"undefined\" ? cached : Unpromise.createSubscribablePromise(promise);\n    }\n    /** Create and store an Unpromise keyed by an original Promise. */ static createSubscribablePromise(promise) {\n        const created = new Unpromise(promise);\n        subscribableCache.set(promise, created);\n        subscribableCache.set(created, created);\n        return created;\n    }\n    /** Retrieve a previously-created Unpromise keyed by an original Promise. */ static getSubscribablePromise(promise) {\n        return subscribableCache.get(promise);\n    }\n    /** Promise STATIC METHODS */ /** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n\t* it (that can be later unsubscribed to eliminate Memory leaks) */ static resolve(value) {\n        const promise = typeof value === \"object\" && value !== null && \"then\" in value && typeof value.then === \"function\" ? value : Promise.resolve(value);\n        return Unpromise.proxy(promise).subscribe();\n    }\n    static async any(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.any(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    static async race(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.race(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    /** Create a race of SubscribedPromises that will fulfil to a single winning\n\t* Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n\t* accumulating .then() and .catch() subscribers. Allows simple logic to\n\t* consume the result, like...\n\t* ```ts\n\t* const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n\t* if(winner === promiseB){\n\t*   const result = await promiseB;\n\t*   // do the thing\n\t* }\n\t* ```\n\t* */ static async raceReferences(promises) {\n        const selfPromises = promises.map(resolveSelfTuple);\n        try {\n            return await Promise.race(selfPromises);\n        } finally{\n            for (const promise of selfPromises)promise.unsubscribe();\n        }\n    }\n};\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n* awaiting the eventual Promise ***reference*** (easy to destructure and\n* exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n* may be ambiguous and therefore hard to identify as the winner of a race).\n* You can call unsubscribe on the Promise to mitigate memory leaks.\n* */ function resolveSelfTuple(promise) {\n    return Unpromise.proxy(promise).then(()=>[\n            promise\n        ]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */ /** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */ function withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject)=>{\n        resolve = _resolve;\n        reject = _reject;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n/** IMMUTABLE LIST OPERATIONS */ function listWithMember(arr, member) {\n    return [\n        ...arr,\n        member\n    ];\n}\nfunction listWithoutIndex(arr, index) {\n    return [\n        ...arr.slice(0, index),\n        ...arr.slice(index + 1)\n    ];\n}\nfunction listWithoutMember(arr, member) {\n    const index = arr.indexOf(member);\n    if (index !== -1) return listWithoutIndex(arr, index);\n    return arr;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/disposable.ts\nSymbol.dispose ??= Symbol();\nSymbol.asyncDispose ??= Symbol();\n/**\n* Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n* The returned object is the original value augmented with a Symbol.dispose method.\n* @param thing The value to make disposable\n* @param dispose Function to call when disposing the resource\n* @returns The original value with Symbol.dispose method added\n*/ function makeResource(thing, dispose) {\n    const it = thing;\n    const existing = it[Symbol.dispose];\n    it[Symbol.dispose] = ()=>{\n        dispose();\n        existing?.();\n    };\n    return it;\n}\n/**\n* Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n* The returned object is the original value augmented with a Symbol.asyncDispose method.\n* @param thing The value to make async disposable\n* @param dispose Async function to call when disposing the resource\n* @returns The original value with Symbol.asyncDispose method added\n*/ function makeAsyncResource(thing, dispose) {\n    const it = thing;\n    const existing = it[Symbol.asyncDispose];\n    it[Symbol.asyncDispose] = async ()=>{\n        await dispose();\n        await existing?.();\n    };\n    return it;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/timerResource.ts\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n    let timer = null;\n    return makeResource({\n        start () {\n            if (timer) throw new Error(\"Timer already started\");\n            const promise = new Promise((resolve)=>{\n                timer = setTimeout(()=>resolve(disposablePromiseTimerResult), ms);\n            });\n            return promise;\n        }\n    }, ()=>{\n        if (timer) clearTimeout(timer);\n    });\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\nvar require_usingCtx = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\" (exports, module) {\n        function _usingCtx() {\n            var r = \"function\" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {\n                var n$1 = Error();\n                return n$1.name = \"SuppressedError\", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n            }, e = {}, n = [];\n            function using(r$1, e$1) {\n                if (null != e$1) {\n                    if (Object(e$1) !== e$1) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n                    if (r$1) var o = e$1[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n                    if (void 0 === o && (o = e$1[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r$1)) var t = o;\n                    if (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n                    t && (o = function o$1() {\n                        try {\n                            t.call(e$1);\n                        } catch (r$2) {\n                            return Promise.reject(r$2);\n                        }\n                    }), n.push({\n                        v: e$1,\n                        d: o,\n                        a: r$1\n                    });\n                } else r$1 && n.push({\n                    d: e$1,\n                    a: r$1\n                });\n                return e$1;\n            }\n            return {\n                e,\n                u: using.bind(null, !1),\n                a: using.bind(null, !0),\n                d: function d() {\n                    var o, t = this.e, s = 0;\n                    function next() {\n                        for(; o = n.pop();)try {\n                            if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n                            if (o.d) {\n                                var r$1 = o.d.call(o.v);\n                                if (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n                            } else s |= 1;\n                        } catch (r$2) {\n                            return err(r$2);\n                        }\n                        if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n                        if (t !== e) throw t;\n                    }\n                    function err(n$1) {\n                        return t = t !== e ? new r(n$1, t) : n$1, next();\n                    }\n                    return next();\n                }\n            };\n        }\n        module.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/asyncIterable.ts\nvar import_usingCtx$4 = __toESM(require_usingCtx(), 1);\nfunction iteratorResource(iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    if (iterator[Symbol.asyncDispose]) return iterator;\n    return makeAsyncResource(iterator, async ()=>{\n        await iterator.return?.();\n    });\n}\n/**\n* Derives a new {@link AsyncGenerator} based on {@link iterable}, that automatically aborts after the specified duration.\n*/ async function* withMaxDuration(iterable, opts) {\n    try {\n        var _usingCtx$1 = (0, import_usingCtx$4.default)();\n        const iterator = _usingCtx$1.a(iteratorResource(iterable));\n        const timer = _usingCtx$1.u(timerResource(opts.maxDurationMs));\n        const timerPromise = timer.start();\n        let result;\n        while(true){\n            result = await Unpromise.race([\n                iterator.next(),\n                timerPromise\n            ]);\n            if (result === disposablePromiseTimerResult) throwAbortError();\n            if (result.done) return result;\n            yield result.value;\n            result = null;\n        }\n    } catch (_) {\n        _usingCtx$1.e = _;\n    } finally{\n        await _usingCtx$1.d();\n    }\n}\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n* {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n* values may still come through. After this period, the generator aborts.\n*/ async function* takeWithGrace(iterable, opts) {\n    try {\n        var _usingCtx3 = (0, import_usingCtx$4.default)();\n        const iterator = _usingCtx3.a(iteratorResource(iterable));\n        let result;\n        const timer = _usingCtx3.u(timerResource(opts.gracePeriodMs));\n        let count = opts.count;\n        let timerPromise = new Promise(()=>{});\n        while(true){\n            result = await Unpromise.race([\n                iterator.next(),\n                timerPromise\n            ]);\n            if (result === disposablePromiseTimerResult) throwAbortError();\n            if (result.done) return result.value;\n            yield result.value;\n            if (--count === 0) timerPromise = timer.start();\n            result = null;\n        }\n    } catch (_) {\n        _usingCtx3.e = _;\n    } finally{\n        await _usingCtx3.d();\n    }\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/createDeferred.ts\nfunction createDeferred() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts\nvar import_usingCtx$3 = __toESM(require_usingCtx(), 1);\nfunction createManagedIterator(iterable, onResult) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let state = \"idle\";\n    function cleanup() {\n        state = \"done\";\n        onResult = ()=>{};\n    }\n    function pull() {\n        if (state !== \"idle\") return;\n        state = \"pending\";\n        const next = iterator.next();\n        next.then((result)=>{\n            if (result.done) {\n                state = \"done\";\n                onResult({\n                    status: \"return\",\n                    value: result.value\n                });\n                cleanup();\n                return;\n            }\n            state = \"idle\";\n            onResult({\n                status: \"yield\",\n                value: result.value\n            });\n        }).catch((cause)=>{\n            onResult({\n                status: \"error\",\n                error: cause\n            });\n            cleanup();\n        });\n    }\n    return {\n        pull,\n        destroy: async ()=>{\n            cleanup();\n            await iterator.return?.();\n        }\n    };\n}\n/**\n* Creates a new async iterable that merges multiple async iterables into a single stream.\n* Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n*\n* New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n*\n* If any of the input iterables throws an error, that error will be propagated through the merged stream.\n* Other iterables will not continue to be processed.\n*\n* @template TYield The type of values yielded by the input iterables\n*/ function mergeAsyncIterables() {\n    let state = \"idle\";\n    let flushSignal = createDeferred();\n    /**\n\t* used while {@link state} is `idle`\n\t*/ const iterables = [];\n    /**\n\t* used while {@link state} is `pending`\n\t*/ const iterators = /* @__PURE__ */ new Set();\n    const buffer = [];\n    function initIterable(iterable) {\n        if (state !== \"pending\") return;\n        const iterator = createManagedIterator(iterable, (result)=>{\n            if (state !== \"pending\") return;\n            switch(result.status){\n                case \"yield\":\n                    buffer.push([\n                        iterator,\n                        result\n                    ]);\n                    break;\n                case \"return\":\n                    iterators.delete(iterator);\n                    break;\n                case \"error\":\n                    buffer.push([\n                        iterator,\n                        result\n                    ]);\n                    iterators.delete(iterator);\n                    break;\n            }\n            flushSignal.resolve();\n        });\n        iterators.add(iterator);\n        iterator.pull();\n    }\n    return {\n        add (iterable) {\n            switch(state){\n                case \"idle\":\n                    iterables.push(iterable);\n                    break;\n                case \"pending\":\n                    initIterable(iterable);\n                    break;\n                case \"done\":\n                    break;\n            }\n        },\n        async *[Symbol.asyncIterator] () {\n            try {\n                var _usingCtx$1 = (0, import_usingCtx$3.default)();\n                if (state !== \"idle\") throw new Error(\"Cannot iterate twice\");\n                state = \"pending\";\n                const _finally = _usingCtx$1.a(makeAsyncResource({}, async ()=>{\n                    state = \"done\";\n                    const errors = [];\n                    await Promise.all(Array.from(iterators.values()).map(async (it)=>{\n                        try {\n                            await it.destroy();\n                        } catch (cause) {\n                            errors.push(cause);\n                        }\n                    }));\n                    buffer.length = 0;\n                    iterators.clear();\n                    flushSignal.resolve();\n                    if (errors.length > 0) throw new AggregateError(errors);\n                }));\n                while(iterables.length > 0)initIterable(iterables.shift());\n                while(iterators.size > 0){\n                    await flushSignal.promise;\n                    while(buffer.length > 0){\n                        const [iterator, result] = buffer.shift();\n                        switch(result.status){\n                            case \"yield\":\n                                yield result.value;\n                                iterator.pull();\n                                break;\n                            case \"error\":\n                                throw result.error;\n                        }\n                    }\n                    flushSignal = createDeferred();\n                }\n            } catch (_) {\n                _usingCtx$1.e = _;\n            } finally{\n                await _usingCtx$1.d();\n            }\n        }\n    };\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts\n/**\n* Creates a ReadableStream from an AsyncIterable.\n*\n* @param iterable - The source AsyncIterable to stream from\n* @returns A ReadableStream that yields values from the AsyncIterable\n*/ function readableStreamFrom(iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async cancel () {\n            await iterator.return?.();\n        },\n        async pull (controller) {\n            const result = await iterator.next();\n            if (result.done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(result.value);\n        }\n    });\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/withPing.ts\nvar import_usingCtx$2 = __toESM(require_usingCtx(), 1);\nconst PING_SYM = Symbol(\"ping\");\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n* whenever no value has been yielded for {@link pingIntervalMs}.\n*/ async function* withPing(iterable, pingIntervalMs) {\n    try {\n        var _usingCtx$1 = (0, import_usingCtx$2.default)();\n        const iterator = _usingCtx$1.a(iteratorResource(iterable));\n        let result;\n        let nextPromise = iterator.next();\n        while(true)try {\n            var _usingCtx3 = (0, import_usingCtx$2.default)();\n            const pingPromise = _usingCtx3.u(timerResource(pingIntervalMs));\n            result = await Unpromise.race([\n                nextPromise,\n                pingPromise.start()\n            ]);\n            if (result === disposablePromiseTimerResult) {\n                yield PING_SYM;\n                continue;\n            }\n            if (result.done) return result.value;\n            nextPromise = iterator.next();\n            yield result.value;\n            result = null;\n        } catch (_) {\n            _usingCtx3.e = _;\n        } finally{\n            _usingCtx3.d();\n        }\n    } catch (_) {\n        _usingCtx$1.e = _;\n    } finally{\n        await _usingCtx$1.d();\n    }\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/jsonl.ts\nvar import_usingCtx$1 = __toESM(require_usingCtx(), 1);\nfunction isPlainObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n    return ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) && typeof value?.[\"then\"] === \"function\" && typeof value?.[\"catch\"] === \"function\";\n}\nvar MaxDepthError = class extends Error {\n    constructor(path){\n        super(\"Max depth reached at path: \" + path.join(\".\"));\n        this.path = path;\n    }\n};\nasync function* createBatchStreamProducer(opts) {\n    const { data } = opts;\n    let counter = 0;\n    const placeholder = 0;\n    const mergedIterables = mergeAsyncIterables();\n    function registerAsync(callback) {\n        const idx = counter++;\n        const iterable$1 = callback(idx);\n        mergedIterables.add(iterable$1);\n        return idx;\n    }\n    function encodePromise(promise, path) {\n        return registerAsync(async function*(idx) {\n            const error = checkMaxDepth(path);\n            if (error) {\n                promise.catch((cause)=>{\n                    opts.onError?.({\n                        error: cause,\n                        path\n                    });\n                });\n                promise = Promise.reject(error);\n            }\n            try {\n                const next = await promise;\n                yield [\n                    idx,\n                    PROMISE_STATUS_FULFILLED,\n                    encode(next, path)\n                ];\n            } catch (cause) {\n                opts.onError?.({\n                    error: cause,\n                    path\n                });\n                yield [\n                    idx,\n                    PROMISE_STATUS_REJECTED,\n                    opts.formatError?.({\n                        error: cause,\n                        path\n                    })\n                ];\n            }\n        });\n    }\n    function encodeAsyncIterable(iterable$1, path) {\n        return registerAsync(async function*(idx) {\n            try {\n                var _usingCtx$1 = (0, import_usingCtx$1.default)();\n                const error = checkMaxDepth(path);\n                if (error) throw error;\n                const iterator = _usingCtx$1.a(iteratorResource(iterable$1));\n                try {\n                    while(true){\n                        const next = await iterator.next();\n                        if (next.done) {\n                            yield [\n                                idx,\n                                ASYNC_ITERABLE_STATUS_RETURN,\n                                encode(next.value, path)\n                            ];\n                            break;\n                        }\n                        yield [\n                            idx,\n                            ASYNC_ITERABLE_STATUS_YIELD,\n                            encode(next.value, path)\n                        ];\n                    }\n                } catch (cause) {\n                    opts.onError?.({\n                        error: cause,\n                        path\n                    });\n                    yield [\n                        idx,\n                        ASYNC_ITERABLE_STATUS_ERROR,\n                        opts.formatError?.({\n                            error: cause,\n                            path\n                        })\n                    ];\n                }\n            } catch (_) {\n                _usingCtx$1.e = _;\n            } finally{\n                await _usingCtx$1.d();\n            }\n        });\n    }\n    function checkMaxDepth(path) {\n        if (opts.maxDepth && path.length > opts.maxDepth) return new MaxDepthError(path);\n        return null;\n    }\n    function encodeAsync(value, path) {\n        if (isPromise(value)) return [\n            CHUNK_VALUE_TYPE_PROMISE,\n            encodePromise(value, path)\n        ];\n        if ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(value)) {\n            if (opts.maxDepth && path.length >= opts.maxDepth) throw new Error(\"Max depth reached\");\n            return [\n                CHUNK_VALUE_TYPE_ASYNC_ITERABLE,\n                encodeAsyncIterable(value, path)\n            ];\n        }\n        return null;\n    }\n    function encode(value, path) {\n        if (value === void 0) return [\n            []\n        ];\n        const reg = encodeAsync(value, path);\n        if (reg) return [\n            [\n                placeholder\n            ],\n            [\n                null,\n                ...reg\n            ]\n        ];\n        if (!isPlainObject(value)) return [\n            [\n                value\n            ]\n        ];\n        const newObj = {};\n        const asyncValues = [];\n        for (const [key, item] of Object.entries(value)){\n            const transformed = encodeAsync(item, [\n                ...path,\n                key\n            ]);\n            if (!transformed) {\n                newObj[key] = item;\n                continue;\n            }\n            newObj[key] = placeholder;\n            asyncValues.push([\n                key,\n                ...transformed\n            ]);\n        }\n        return [\n            [\n                newObj\n            ],\n            ...asyncValues\n        ];\n    }\n    const newHead = {};\n    for (const [key, item] of Object.entries(data))newHead[key] = encode(item, [\n        key\n    ]);\n    yield newHead;\n    let iterable = mergedIterables;\n    if (opts.pingMs) iterable = withPing(mergedIterables, opts.pingMs);\n    for await (const value of iterable)yield value;\n}\n/**\n* JSON Lines stream producer\n* @see https://jsonlines.org/\n*/ function jsonlStreamProducer(opts) {\n    let stream = readableStreamFrom(createBatchStreamProducer(opts));\n    const { serialize } = opts;\n    if (serialize) stream = stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (chunk === PING_SYM) controller.enqueue(PING_SYM);\n            else controller.enqueue(serialize(chunk));\n        }\n    }));\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (chunk === PING_SYM) controller.enqueue(\" \");\n            else controller.enqueue(JSON.stringify(chunk) + \"\\n\");\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nvar AsyncError = class extends Error {\n    constructor(data){\n        super(\"Received error from server\");\n        this.data = data;\n    }\n};\nconst nodeJsStreamToReaderEsque = (source)=>{\n    return {\n        getReader () {\n            const stream = new ReadableStream({\n                start (controller) {\n                    source.on(\"data\", (chunk)=>{\n                        controller.enqueue(chunk);\n                    });\n                    source.on(\"end\", ()=>{\n                        controller.close();\n                    });\n                    source.on(\"error\", (error)=>{\n                        controller.error(error);\n                    });\n                }\n            });\n            return stream.getReader();\n        }\n    };\n};\nfunction createLineAccumulator(from) {\n    const reader = \"getReader\" in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n    let lineAggregate = \"\";\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await reader.read();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        cancel () {\n            return reader.cancel();\n        }\n    }).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            lineAggregate += chunk;\n            const parts = lineAggregate.split(\"\\n\");\n            lineAggregate = parts.pop() ?? \"\";\n            for (const part of parts)controller.enqueue(part);\n        }\n    }));\n}\nfunction createConsumerStream(from) {\n    const stream = createLineAccumulator(from);\n    let sentHead = false;\n    return stream.pipeThrough(new TransformStream({\n        transform (line, controller) {\n            if (!sentHead) {\n                const head = JSON.parse(line);\n                controller.enqueue(head);\n                sentHead = true;\n            } else {\n                const chunk = JSON.parse(line);\n                controller.enqueue(chunk);\n            }\n        }\n    }));\n}\n/**\n* Creates a handler for managing stream controllers and their lifecycle\n*/ function createStreamsManager(abortController) {\n    const controllerMap = /* @__PURE__ */ new Map();\n    /**\n\t* Checks if there are no pending controllers or deferred promises\n\t*/ function isEmpty() {\n        return Array.from(controllerMap.values()).every((c)=>c.closed);\n    }\n    /**\n\t* Creates a stream controller\n\t*/ function createStreamController() {\n        let originalController;\n        const stream = new ReadableStream({\n            start (controller) {\n                originalController = controller;\n            }\n        });\n        const streamController = {\n            enqueue: (v)=>originalController.enqueue(v),\n            close: ()=>{\n                originalController.close();\n                clear();\n                if (isEmpty()) abortController.abort();\n            },\n            closed: false,\n            getReaderResource: ()=>{\n                const reader = stream.getReader();\n                return makeResource(reader, ()=>{\n                    reader.releaseLock();\n                    streamController.close();\n                });\n            },\n            error: (reason)=>{\n                originalController.error(reason);\n                clear();\n            }\n        };\n        function clear() {\n            Object.assign(streamController, {\n                closed: true,\n                close: ()=>{},\n                enqueue: ()=>{},\n                getReaderResource: null,\n                error: ()=>{}\n            });\n        }\n        return streamController;\n    }\n    /**\n\t* Gets or creates a stream controller\n\t*/ function getOrCreate(chunkId) {\n        let c = controllerMap.get(chunkId);\n        if (!c) {\n            c = createStreamController();\n            controllerMap.set(chunkId, c);\n        }\n        return c;\n    }\n    /**\n\t* Cancels all pending controllers and rejects deferred promises\n\t*/ function cancelAll(reason) {\n        for (const controller of controllerMap.values())controller.error(reason);\n    }\n    return {\n        getOrCreate,\n        isEmpty,\n        cancelAll\n    };\n}\n/**\n* JSON Lines stream consumer\n* @see https://jsonlines.org/\n*/ async function jsonlStreamConsumer(opts) {\n    const { deserialize = (v)=>v } = opts;\n    let source = createConsumerStream(opts.from);\n    if (deserialize) source = source.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(deserialize(chunk));\n        }\n    }));\n    let headDeferred = createDeferred();\n    const streamManager = createStreamsManager(opts.abortController);\n    function decodeChunkDefinition(value) {\n        const [_path, type, chunkId] = value;\n        const controller = streamManager.getOrCreate(chunkId);\n        switch(type){\n            case CHUNK_VALUE_TYPE_PROMISE:\n                return (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async ()=>{\n                    try {\n                        var _usingCtx3 = (0, import_usingCtx$1.default)();\n                        const reader = _usingCtx3.u(controller.getReaderResource());\n                        const { value: value$1 } = await reader.read();\n                        const [_chunkId, status, data] = value$1;\n                        switch(status){\n                            case PROMISE_STATUS_FULFILLED:\n                                return decode(data);\n                            case PROMISE_STATUS_REJECTED:\n                                throw opts.formatError?.({\n                                    error: data\n                                }) ?? new AsyncError(data);\n                        }\n                    } catch (_) {\n                        _usingCtx3.e = _;\n                    } finally{\n                        _usingCtx3.d();\n                    }\n                });\n            case CHUNK_VALUE_TYPE_ASYNC_ITERABLE:\n                return (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async function*() {\n                    try {\n                        var _usingCtx4 = (0, import_usingCtx$1.default)();\n                        const reader = _usingCtx4.u(controller.getReaderResource());\n                        while(true){\n                            const { value: value$1 } = await reader.read();\n                            const [_chunkId, status, data] = value$1;\n                            switch(status){\n                                case ASYNC_ITERABLE_STATUS_YIELD:\n                                    yield decode(data);\n                                    break;\n                                case ASYNC_ITERABLE_STATUS_RETURN:\n                                    return decode(data);\n                                case ASYNC_ITERABLE_STATUS_ERROR:\n                                    throw opts.formatError?.({\n                                        error: data\n                                    }) ?? new AsyncError(data);\n                            }\n                        }\n                    } catch (_) {\n                        _usingCtx4.e = _;\n                    } finally{\n                        _usingCtx4.d();\n                    }\n                });\n        }\n    }\n    function decode(value) {\n        const [[data], ...asyncProps] = value;\n        for (const value$1 of asyncProps){\n            const [key] = value$1;\n            const decoded = decodeChunkDefinition(value$1);\n            if (key === null) return decoded;\n            data[key] = decoded;\n        }\n        return data;\n    }\n    const closeOrAbort = (reason)=>{\n        headDeferred?.reject(reason);\n        streamManager.cancelAll(reason);\n    };\n    source.pipeTo(new WritableStream({\n        write (chunkOrHead) {\n            if (headDeferred) {\n                const head = chunkOrHead;\n                for (const [key, value] of Object.entries(chunkOrHead)){\n                    const parsed = decode(value);\n                    head[key] = parsed;\n                }\n                headDeferred.resolve(head);\n                headDeferred = null;\n                return;\n            }\n            const chunk = chunkOrHead;\n            const [idx] = chunk;\n            const controller = streamManager.getOrCreate(idx);\n            controller.enqueue(chunk);\n        },\n        close: ()=>closeOrAbort(new Error(\"Stream closed\")),\n        abort: closeOrAbort\n    }), {\n        signal: opts.abortController.signal\n    }).catch((error)=>{\n        opts.onError?.({\n            error\n        });\n        closeOrAbort(error);\n    });\n    return [\n        await headDeferred.promise,\n        streamManager\n    ];\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/sse.ts\nvar import_usingCtx = __toESM(require_usingCtx(), 1);\nconst PING_EVENT = \"ping\";\nconst SERIALIZED_ERROR_EVENT = \"serialized-error\";\nconst CONNECTED_EVENT = \"connected\";\nconst RETURN_EVENT = \"return\";\n/**\n*\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/ function sseStreamProducer(opts) {\n    const { serialize = _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.identity } = opts;\n    const ping = {\n        enabled: opts.ping?.enabled ?? false,\n        intervalMs: opts.ping?.intervalMs ?? 1e3\n    };\n    const client = opts.client ?? {};\n    if (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);\n    async function* generator() {\n        yield {\n            event: CONNECTED_EVENT,\n            data: JSON.stringify(client)\n        };\n        let iterable = opts.data;\n        if (opts.emitAndEndImmediately) iterable = takeWithGrace(iterable, {\n            count: 1,\n            gracePeriodMs: 1\n        });\n        if (opts.maxDurationMs && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) iterable = withMaxDuration(iterable, {\n            maxDurationMs: opts.maxDurationMs\n        });\n        if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) iterable = withPing(iterable, ping.intervalMs);\n        let value;\n        let chunk;\n        for await (value of iterable){\n            if (value === PING_SYM) {\n                yield {\n                    event: PING_EVENT,\n                    data: \"\"\n                };\n                continue;\n            }\n            chunk = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.isTrackedEnvelope)(value) ? {\n                id: value[0],\n                data: value[1]\n            } : {\n                data: value\n            };\n            chunk.data = JSON.stringify(serialize(chunk.data));\n            yield chunk;\n            value = null;\n            chunk = null;\n        }\n    }\n    async function* generatorWithErrorHandling() {\n        try {\n            yield* generator();\n            yield {\n                event: RETURN_EVENT,\n                data: \"\"\n            };\n        } catch (cause) {\n            if (isAbortError(cause)) return;\n            const error = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n            const data = opts.formatError?.({\n                error\n            }) ?? null;\n            yield {\n                event: SERIALIZED_ERROR_EVENT,\n                data: JSON.stringify(serialize(data))\n            };\n        }\n    }\n    const stream = readableStreamFrom(generatorWithErrorHandling());\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (\"event\" in chunk) controller.enqueue(`event: ${chunk.event}\\n`);\n            if (\"data\" in chunk) controller.enqueue(`data: ${chunk.data}\\n`);\n            if (\"id\" in chunk) controller.enqueue(`id: ${chunk.id}\\n`);\n            if (\"comment\" in chunk) controller.enqueue(`: ${chunk.comment}\\n`);\n            controller.enqueue(\"\\n\\n\");\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nasync function withTimeout(opts) {\n    try {\n        var _usingCtx$1 = (0, import_usingCtx.default)();\n        const timeoutPromise = _usingCtx$1.u(timerResource(opts.timeoutMs));\n        const res = await Unpromise.race([\n            opts.promise,\n            timeoutPromise.start()\n        ]);\n        if (res === disposablePromiseTimerResult) return await opts.onTimeout();\n        return res;\n    } catch (_) {\n        _usingCtx$1.e = _;\n    } finally{\n        _usingCtx$1.d();\n    }\n}\n/**\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/ function sseStreamConsumer(opts) {\n    const { deserialize = (v)=>v } = opts;\n    let clientOptions = {};\n    const signal = opts.signal;\n    let _es = null;\n    const createStream = ()=>new ReadableStream({\n            async start (controller) {\n                const [url, init] = await Promise.all([\n                    opts.url(),\n                    opts.init()\n                ]);\n                const eventSource = _es = new opts.EventSource(url, init);\n                controller.enqueue({\n                    type: \"connecting\",\n                    eventSource: _es,\n                    event: null\n                });\n                eventSource.addEventListener(CONNECTED_EVENT, (_msg)=>{\n                    const msg = _msg;\n                    const options = JSON.parse(msg.data);\n                    clientOptions = options;\n                    controller.enqueue({\n                        type: \"connected\",\n                        options,\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg)=>{\n                    const msg = _msg;\n                    controller.enqueue({\n                        type: \"serialized-error\",\n                        error: deserialize(JSON.parse(msg.data)),\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(PING_EVENT, ()=>{\n                    controller.enqueue({\n                        type: \"ping\",\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(RETURN_EVENT, ()=>{\n                    eventSource.close();\n                    controller.close();\n                    _es = null;\n                });\n                eventSource.addEventListener(\"error\", (event)=>{\n                    if (eventSource.readyState === eventSource.CLOSED) controller.error(event);\n                    else controller.enqueue({\n                        type: \"connecting\",\n                        eventSource,\n                        event\n                    });\n                });\n                eventSource.addEventListener(\"message\", (_msg)=>{\n                    const msg = _msg;\n                    const chunk = deserialize(JSON.parse(msg.data));\n                    const def = {\n                        data: chunk\n                    };\n                    if (msg.lastEventId) def.id = msg.lastEventId;\n                    controller.enqueue({\n                        type: \"data\",\n                        data: def,\n                        eventSource\n                    });\n                });\n                const onAbort = ()=>{\n                    try {\n                        eventSource.close();\n                        controller.close();\n                    } catch  {}\n                };\n                if (signal.aborted) onAbort();\n                else signal.addEventListener(\"abort\", onAbort);\n            },\n            cancel () {\n                _es?.close();\n            }\n        });\n    const getStreamResource = ()=>{\n        let stream = createStream();\n        let reader = stream.getReader();\n        async function dispose() {\n            await reader.cancel();\n            _es = null;\n        }\n        return makeAsyncResource({\n            read () {\n                return reader.read();\n            },\n            async recreate () {\n                await dispose();\n                stream = createStream();\n                reader = stream.getReader();\n            }\n        }, dispose);\n    };\n    return (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async function*() {\n        try {\n            var _usingCtx3 = (0, import_usingCtx.default)();\n            const stream = _usingCtx3.a(getStreamResource());\n            while(true){\n                let promise = stream.read();\n                const timeoutMs = clientOptions.reconnectAfterInactivityMs;\n                if (timeoutMs) promise = withTimeout({\n                    promise,\n                    timeoutMs,\n                    onTimeout: async ()=>{\n                        const res = {\n                            value: {\n                                type: \"timeout\",\n                                ms: timeoutMs,\n                                eventSource: _es\n                            },\n                            done: false\n                        };\n                        await stream.recreate();\n                        return res;\n                    }\n                });\n                const result = await promise;\n                if (result.done) return result.value;\n                yield result.value;\n            }\n        } catch (_) {\n            _usingCtx3.e = _;\n        } finally{\n            await _usingCtx3.d();\n        }\n    });\n}\nconst sseHeaders = {\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"no-cache, no-transform\",\n    \"X-Accel-Buffering\": \"no\",\n    Connection: \"keep-alive\"\n};\n//#endregion\n//#region src/unstable-core-do-not-import/http/resolveResponse.ts\nfunction errorToAsyncIterable(err) {\n    return (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async function*() {\n        throw err;\n    });\n}\nconst TYPE_ACCEPTED_METHOD_MAP = {\n    mutation: [\n        \"POST\"\n    ],\n    query: [\n        \"GET\"\n    ],\n    subscription: [\n        \"GET\"\n    ]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n    mutation: [\n        \"POST\"\n    ],\n    query: [\n        \"GET\",\n        \"POST\"\n    ],\n    subscription: [\n        \"GET\",\n        \"POST\"\n    ]\n};\nfunction initResponse(initOpts) {\n    const { ctx, info, responseMeta, untransformedJSON, errors = [], headers } = initOpts;\n    let status = untransformedJSON ? (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getHTTPStatusCode)(untransformedJSON) : 200;\n    const eagerGeneration = !untransformedJSON;\n    const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [\n        untransformedJSON\n    ];\n    const meta = responseMeta?.({\n        ctx,\n        info,\n        paths: info?.calls.map((call)=>call.path),\n        data,\n        errors,\n        eagerGeneration,\n        type: info?.calls.find((call)=>call.procedure?._def.type)?.procedure?._def.type ?? \"unknown\"\n    }) ?? {};\n    if (meta.headers) {\n        if (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries())headers.append(key, value);\n        else /**\n\t\t* @deprecated, delete in v12\n\t\t*/ for (const [key, value] of Object.entries(meta.headers))if (Array.isArray(value)) for (const v of value)headers.append(key, v);\n        else if (typeof value === \"string\") headers.set(key, value);\n    }\n    if (meta.status) status = meta.status;\n    return {\n        status\n    };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n    const { router, req, onError } = errorOpts.opts;\n    const error = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n    onError?.({\n        error,\n        path: errorOpts.path,\n        input: errorOpts.input,\n        ctx: errorOpts.ctx,\n        type: errorOpts.type,\n        req\n    });\n    const untransformedJSON = {\n        error: (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n            config: router._def._config,\n            error,\n            type: errorOpts.type,\n            path: errorOpts.path,\n            input: errorOpts.input,\n            ctx: errorOpts.ctx\n        })\n    };\n    const transformedJSON = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(router._def._config, untransformedJSON);\n    const body = JSON.stringify(transformedJSON);\n    return {\n        error,\n        untransformedJSON,\n        body\n    };\n}\n/**\n* Check if a value is a stream-like object\n* - if it's an async iterable\n* - if it's an object with async iterables or promises\n*/ function isDataStream(v) {\n    if (!(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(v)) return false;\n    if ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(v)) return true;\n    return Object.values(v).some(isPromise) || Object.values(v).some(_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n    const { router, req } = opts;\n    const headers = new Headers([\n        [\n            \"vary\",\n            \"trpc-accept\"\n        ]\n    ]);\n    const config = router._def._config;\n    const url = new URL(req.url);\n    if (req.method === \"HEAD\") return new Response(null, {\n        status: 204\n    });\n    const allowBatching = opts.allowBatching ?? opts.batching?.enabled ?? true;\n    const allowMethodOverride = (opts.allowMethodOverride ?? false) && req.method === \"POST\";\n    const infoTuple = await (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async ()=>{\n        try {\n            return [\n                void 0,\n                await getRequestInfo({\n                    req,\n                    path: decodeURIComponent(opts.path),\n                    router,\n                    searchParams: url.searchParams,\n                    headers: opts.req.headers,\n                    url\n                })\n            ];\n        } catch (cause) {\n            return [\n                (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                void 0\n            ];\n        }\n    });\n    const ctxManager = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(()=>{\n        let result = void 0;\n        return {\n            valueOrUndefined: ()=>{\n                if (!result) return void 0;\n                return result[1];\n            },\n            value: ()=>{\n                const [err, ctx] = result;\n                if (err) throw err;\n                return ctx;\n            },\n            create: async (info)=>{\n                if (result) throw new Error(\"This should only be called once - report a bug in tRPC\");\n                try {\n                    const ctx = await opts.createContext({\n                        info\n                    });\n                    result = [\n                        void 0,\n                        ctx\n                    ];\n                } catch (cause) {\n                    result = [\n                        (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                        void 0\n                    ];\n                }\n            }\n        };\n    });\n    const methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n    /**\n\t* @deprecated\n\t*/ const isStreamCall = req.headers.get(\"trpc-accept\") === \"application/jsonl\";\n    const experimentalSSE = config.sse?.enabled ?? true;\n    try {\n        const [infoError, info] = infoTuple;\n        if (infoError) throw infoError;\n        if (info.isBatchCall && !allowBatching) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Batching is not enabled on the server`\n        });\n        /* istanbul ignore if -- @preserve */ if (isStreamCall && !info.isBatchCall) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            message: `Streaming requests must be batched (you can do a batch of 1)`,\n            code: \"BAD_REQUEST\"\n        });\n        await ctxManager.create(info);\n        const rpcCalls = info.calls.map(async (call)=>{\n            const proc = call.procedure;\n            try {\n                if (opts.error) throw opts.error;\n                if (!proc) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"NOT_FOUND\",\n                    message: `No procedure found on path \"${call.path}\"`\n                });\n                if (!methodMapper[proc._def.type].includes(req.method)) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"METHOD_NOT_SUPPORTED\",\n                    message: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`\n                });\n                if (proc._def.type === \"subscription\") {\n                    /* istanbul ignore if -- @preserve */ if (info.isBatchCall) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                        code: \"BAD_REQUEST\",\n                        message: `Cannot batch subscription calls`\n                    });\n                }\n                const data = await proc({\n                    path: call.path,\n                    getRawInput: call.getRawInput,\n                    ctx: ctxManager.value(),\n                    type: proc._def.type,\n                    signal: opts.req.signal\n                });\n                return [\n                    void 0,\n                    {\n                        data\n                    }\n                ];\n            } catch (cause) {\n                const error = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n                const input = call.result();\n                opts.onError?.({\n                    error,\n                    path: call.path,\n                    input,\n                    ctx: ctxManager.valueOrUndefined(),\n                    type: call.procedure?._def.type ?? \"unknown\",\n                    req: opts.req\n                });\n                return [\n                    error,\n                    void 0\n                ];\n            }\n        });\n        if (!info.isBatchCall) {\n            const [call] = info.calls;\n            const [error, result] = await rpcCalls[0];\n            switch(info.type){\n                case \"unknown\":\n                case \"mutation\":\n                case \"query\":\n                    {\n                        headers.set(\"content-type\", \"application/json\");\n                        if (isDataStream(result?.data)) throw new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                            code: \"UNSUPPORTED_MEDIA_TYPE\",\n                            message: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n                        });\n                        const res = error ? {\n                            error: (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                                config,\n                                ctx: ctxManager.valueOrUndefined(),\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: info.type\n                            })\n                        } : {\n                            result: {\n                                data: result.data\n                            }\n                        };\n                        const headResponse$1 = initResponse({\n                            ctx: ctxManager.valueOrUndefined(),\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: error ? [\n                                error\n                            ] : [],\n                            headers,\n                            untransformedJSON: [\n                                res\n                            ]\n                        });\n                        return new Response(JSON.stringify((0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, res)), {\n                            status: headResponse$1.status,\n                            headers\n                        });\n                    }\n                case \"subscription\":\n                    {\n                        const iterable = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(()=>{\n                            if (error) return errorToAsyncIterable(error);\n                            if (!experimentalSSE) return errorToAsyncIterable(new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                                code: \"METHOD_NOT_SUPPORTED\",\n                                message: 'Missing experimental flag \"sseSubscriptions\"'\n                            }));\n                            if (!(0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) && !(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(result.data)) return errorToAsyncIterable(new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                                message: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n                                code: \"INTERNAL_SERVER_ERROR\"\n                            }));\n                            const dataAsIterable = (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : result.data;\n                            return dataAsIterable;\n                        });\n                        const stream = sseStreamProducer({\n                            ...config.sse,\n                            data: iterable,\n                            serialize: (v)=>config.transformer.output.serialize(v),\n                            formatError (errorOpts) {\n                                const error$1 = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n                                const input = call?.result();\n                                const path = call?.path;\n                                const type = call?.procedure?._def.type ?? \"unknown\";\n                                opts.onError?.({\n                                    error: error$1,\n                                    path,\n                                    input,\n                                    ctx: ctxManager.valueOrUndefined(),\n                                    req: opts.req,\n                                    type\n                                });\n                                const shape = (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                                    config,\n                                    ctx: ctxManager.valueOrUndefined(),\n                                    error: error$1,\n                                    input,\n                                    path,\n                                    type\n                                });\n                                return shape;\n                            }\n                        });\n                        for (const [key, value] of Object.entries(sseHeaders))headers.set(key, value);\n                        const headResponse$1 = initResponse({\n                            ctx: ctxManager.valueOrUndefined(),\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: [],\n                            headers,\n                            untransformedJSON: null\n                        });\n                        return new Response(stream, {\n                            headers,\n                            status: headResponse$1.status\n                        });\n                    }\n            }\n        }\n        if (info.accept === \"application/jsonl\") {\n            headers.set(\"content-type\", \"application/json\");\n            headers.set(\"transfer-encoding\", \"chunked\");\n            const headResponse$1 = initResponse({\n                ctx: ctxManager.valueOrUndefined(),\n                info,\n                responseMeta: opts.responseMeta,\n                errors: [],\n                headers,\n                untransformedJSON: null\n            });\n            const stream = jsonlStreamProducer({\n                ...config.jsonl,\n                maxDepth: Infinity,\n                data: rpcCalls.map(async (res)=>{\n                    const [error, result] = await res;\n                    const call = info.calls[0];\n                    if (error) return {\n                        error: (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                            config,\n                            ctx: ctxManager.valueOrUndefined(),\n                            error,\n                            input: call.result(),\n                            path: call.path,\n                            type: call.procedure?._def.type ?? \"unknown\"\n                        })\n                    };\n                    /**\n\t\t\t\t\t* Not very pretty, but we need to wrap nested data in promises\n\t\t\t\t\t* Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n\t\t\t\t\t*/ const iterable = (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_B1orLHHI_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : Promise.resolve(result.data);\n                    return {\n                        result: Promise.resolve({\n                            data: iterable\n                        })\n                    };\n                }),\n                serialize: config.transformer.output.serialize,\n                onError: (cause)=>{\n                    opts.onError?.({\n                        error: (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                        path: void 0,\n                        input: void 0,\n                        ctx: ctxManager.valueOrUndefined(),\n                        req: opts.req,\n                        type: info?.type ?? \"unknown\"\n                    });\n                },\n                formatError (errorOpts) {\n                    const call = info?.calls[errorOpts.path[0]];\n                    const error = (0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n                    const input = call?.result();\n                    const path = call?.path;\n                    const type = call?.procedure?._def.type ?? \"unknown\";\n                    const shape = (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                        config,\n                        ctx: ctxManager.valueOrUndefined(),\n                        error,\n                        input,\n                        path,\n                        type\n                    });\n                    return shape;\n                }\n            });\n            return new Response(stream, {\n                headers,\n                status: headResponse$1.status\n            });\n        }\n        /**\n\t\t* Non-streaming response:\n\t\t* - await all responses in parallel, blocking on the slowest one\n\t\t* - create headers with known response body\n\t\t* - return a complete HTTPResponse\n\t\t*/ headers.set(\"content-type\", \"application/json\");\n        const results = (await Promise.all(rpcCalls)).map((res)=>{\n            const [error, result] = res;\n            if (error) return res;\n            if (isDataStream(result.data)) return [\n                new _tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"UNSUPPORTED_MEDIA_TYPE\",\n                    message: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n                }),\n                void 0\n            ];\n            return res;\n        });\n        const resultAsRPCResponse = results.map(([error, result], index)=>{\n            const call = info.calls[index];\n            if (error) return {\n                error: (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                    config,\n                    ctx: ctxManager.valueOrUndefined(),\n                    error,\n                    input: call.result(),\n                    path: call.path,\n                    type: call.procedure?._def.type ?? \"unknown\"\n                })\n            };\n            return {\n                result: {\n                    data: result.data\n                }\n            };\n        });\n        const errors = results.map(([error])=>error).filter(Boolean);\n        const headResponse = initResponse({\n            ctx: ctxManager.valueOrUndefined(),\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON: resultAsRPCResponse,\n            errors,\n            headers\n        });\n        return new Response(JSON.stringify((0,_tracked_GEWPoL0C_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, resultAsRPCResponse)), {\n            status: headResponse.status,\n            headers\n        });\n    } catch (cause) {\n        const [_infoError, info] = infoTuple;\n        const ctx = ctxManager.valueOrUndefined();\n        const { error, untransformedJSON, body } = caughtErrorToData(cause, {\n            opts,\n            ctx: ctxManager.valueOrUndefined(),\n            type: info?.type ?? \"unknown\"\n        });\n        const headResponse = initResponse({\n            ctx,\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON,\n            errors: [\n                error\n            ],\n            headers\n        });\n        return new Response(body, {\n            status: headResponse.status,\n            headers\n        });\n    }\n}\n//#endregion\n //# sourceMappingURL=resolveResponse-DPbYgJDD.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9yZXNvbHZlUmVzcG9uc2UtRFBiWWdKREQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdGO0FBQzBEO0FBQzlDO0FBQ1I7QUFFcEYsMEJBQTBCO0FBQzFCLElBQUljLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxhQUFhLENBQUNDLElBQUlDLE1BQVE7UUFDN0IsT0FBT0EsT0FBTyxDQUFDLEdBQUdELEVBQUUsQ0FBQ1Isa0JBQWtCUSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsTUFBTTtZQUFFQyxTQUFTLENBQUM7UUFBRSxHQUFHQSxPQUFPLEVBQUVELE1BQU1BLElBQUlDLE9BQU87SUFDbkc7QUFDQSxJQUFJQyxjQUFjLENBQUNDLElBQUlDLE1BQU1DLFFBQVFDO0lBQ3BDLElBQUlGLFFBQVEsT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWSxJQUFLLElBQUlHLE9BQU9oQixrQkFBa0JhLE9BQU9JLElBQUksR0FBR0MsSUFBSUYsS0FBS0csTUFBTSxFQUFFQyxLQUFLSCxJQUFJQyxHQUFHRCxJQUFLO1FBQ3JKRyxNQUFNSixJQUFJLENBQUNDLEVBQUU7UUFDYixJQUFJLENBQUNiLGFBQWFpQixJQUFJLENBQUNULElBQUlRLFFBQVFBLFFBQVFOLFFBQVFsQixVQUFVZ0IsSUFBSVEsS0FBSztZQUNyRUUsS0FBSyxDQUFDLENBQUNDLElBQU1WLElBQUksQ0FBQ1UsRUFBRSxFQUFFQyxJQUFJLENBQUMsTUFBTUo7WUFDakNLLFlBQVksQ0FBRVYsQ0FBQUEsT0FBT2pCLGlCQUFpQmUsTUFBTU8sSUFBRyxLQUFNTCxLQUFLVSxVQUFVO1FBQ3JFO0lBQ0Q7SUFDQSxPQUFPYjtBQUNSO0FBQ0EsSUFBSWMsVUFBVSxDQUFDakIsS0FBS2tCLFlBQVlDLFNBQVlBLENBQUFBLFNBQVNuQixPQUFPLE9BQU9oQixTQUFTUyxhQUFhTyxRQUFRLENBQUMsR0FBR0UsWUFBWWdCLGNBQWMsQ0FBQ2xCLE9BQU8sQ0FBQ0EsSUFBSW9CLFVBQVUsR0FBR2pDLFVBQVVnQyxRQUFRLFdBQVc7UUFDckxFLE9BQU9yQjtRQUNQZ0IsWUFBWTtJQUNiLEtBQUtHLFFBQVFuQixJQUFHO0FBRWhCLFlBQVk7QUFDWix1RUFBdUU7QUFDdkUsU0FBU3NCLGlDQUFpQ0MsTUFBTTtJQUMvQyxJQUFJO1FBQ0gsSUFBSUEsV0FBVyxNQUFNLE9BQU87UUFDNUIsSUFBSSxDQUFDM0MsNkRBQVFBLENBQUMyQyxTQUFTLE1BQU0sSUFBSUMsTUFBTTtRQUN2QyxNQUFNQyxrQkFBa0J4QyxPQUFPeUMsT0FBTyxDQUFDSCxRQUFRSSxNQUFNLENBQUMsQ0FBQyxDQUFDQyxNQUFNUCxNQUFNLEdBQUssT0FBT0EsVUFBVTtRQUMxRixJQUFJSSxnQkFBZ0JmLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSWMsTUFBTSxDQUFDLG1EQUFtRCxFQUFFQyxnQkFBZ0JJLEdBQUcsQ0FBQyxDQUFDLENBQUNsQixLQUFLVSxNQUFNLEdBQUssQ0FBQyxFQUFFVixJQUFJLEVBQUUsRUFBRSxPQUFPVSxNQUFNLENBQUMsRUFBRVMsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNuTCxPQUFPUDtJQUNSLEVBQUUsT0FBT1EsT0FBTztRQUNmLE1BQU0sSUFBSTNELDREQUFTQSxDQUFDO1lBQ25CNEQsTUFBTTtZQUNOQyxTQUFTO1lBQ1RGO1FBQ0Q7SUFDRDtBQUNEO0FBQ0EsU0FBU0csZ0NBQWdDQyxHQUFHO0lBQzNDLElBQUlaO0lBQ0osSUFBSTtRQUNIQSxTQUFTYSxLQUFLQyxLQUFLLENBQUNGO0lBQ3JCLEVBQUUsT0FBT0osT0FBTztRQUNmLE1BQU0sSUFBSTNELDREQUFTQSxDQUFDO1lBQ25CNEQsTUFBTTtZQUNOQyxTQUFTO1lBQ1RGO1FBQ0Q7SUFDRDtJQUNBLE9BQU9ULGlDQUFpQ0M7QUFDekM7QUFFQSxZQUFZO0FBQ1osNkRBQTZEO0FBQzdEOzs7QUFHQSxHQUNBLFNBQVNlLEtBQUtDLEVBQUU7SUFDZixJQUFJQyxVQUFVO0lBQ2QsTUFBTUMsTUFBTUMsT0FBT0MsR0FBRyxDQUFDO0lBQ3ZCLElBQUl0QixRQUFRb0I7SUFDWixPQUFPO1FBQ05HLE1BQU07WUFDTCxJQUFJdkIsVUFBVW9CLEtBQUssT0FBT3BCO1lBQzFCbUIsWUFBWUQsS0FBS00sS0FBSyxDQUFDLENBQUNkO2dCQUN2QixJQUFJQSxpQkFBaUIzRCw0REFBU0EsRUFBRSxNQUFNMkQ7Z0JBQ3RDLE1BQU0sSUFBSTNELDREQUFTQSxDQUFDO29CQUNuQjRELE1BQU07b0JBQ05DLFNBQVNGLGlCQUFpQlAsUUFBUU8sTUFBTUUsT0FBTyxHQUFHO29CQUNsREY7Z0JBQ0Q7WUFDRDtZQUNBVixRQUFRLE1BQU1tQjtZQUNkQSxVQUFVO1lBQ1YsT0FBT25CO1FBQ1I7UUFDQXlCLFFBQVE7WUFDUCxPQUFPekIsVUFBVW9CLE1BQU1wQixRQUFRLEtBQUs7UUFDckM7SUFDRDtBQUNEO0FBQ0EsTUFBTTBCLHlCQUF5QjtJQUM5QkMsU0FBUUMsR0FBRztRQUNWLE9BQU8sQ0FBQyxDQUFDQSxJQUFJQyxPQUFPLENBQUNyQyxHQUFHLENBQUMsaUJBQWlCc0MsV0FBVztJQUN0RDtJQUNBLE1BQU1kLE9BQU1lLElBQUk7UUFDZixNQUFNLEVBQUVILEdBQUcsRUFBRSxHQUFHRztRQUNoQixNQUFNQyxjQUFjRCxLQUFLRSxZQUFZLENBQUN6QyxHQUFHLENBQUMsYUFBYTtRQUN2RCxNQUFNMEMsUUFBUUYsY0FBY0QsS0FBS0ksSUFBSSxDQUFDQyxLQUFLLENBQUMsT0FBTztZQUFDTCxLQUFLSSxJQUFJO1NBQUM7UUFDOUQsTUFBTUUsWUFBWXBCLEtBQUs7WUFDdEIsSUFBSXFCLFNBQVMsS0FBSztZQUNsQixJQUFJVixJQUFJVyxNQUFNLEtBQUssT0FBTztnQkFDekIsTUFBTUMsYUFBYVQsS0FBS0UsWUFBWSxDQUFDekMsR0FBRyxDQUFDO2dCQUN6QyxJQUFJZ0QsWUFBWUYsU0FBU3ZCLEtBQUtDLEtBQUssQ0FBQ3dCO1lBQ3JDLE9BQU9GLFNBQVMsTUFBTVYsSUFBSWEsSUFBSTtZQUM5QixJQUFJSCxXQUFXLEtBQUssR0FBRyxPQUFPLENBQUM7WUFDL0IsSUFBSSxDQUFDTixhQUFhLE9BQU87Z0JBQUUsR0FBR0QsS0FBS1csTUFBTSxDQUFDQyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsV0FBVyxDQUFDQyxLQUFLLENBQUNDLFdBQVcsQ0FBQ1Q7WUFBUTtZQUM3RixJQUFJLENBQUMvRSw2REFBUUEsQ0FBQytFLFNBQVMsTUFBTSxJQUFJdkYsNERBQVNBLENBQUM7Z0JBQzFDNEQsTUFBTTtnQkFDTkMsU0FBUztZQUNWO1lBQ0EsTUFBTW9DLE1BQU0sQ0FBQztZQUNiLEtBQUssTUFBTUMsU0FBU2YsTUFBTWhELElBQUksR0FBSTtnQkFDakMsTUFBTTRELFFBQVFSLE1BQU0sQ0FBQ1csTUFBTTtnQkFDM0IsSUFBSUgsVUFBVSxLQUFLLEdBQUdFLEdBQUcsQ0FBQ0MsTUFBTSxHQUFHbEIsS0FBS1csTUFBTSxDQUFDQyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsV0FBVyxDQUFDQyxLQUFLLENBQUNDLFdBQVcsQ0FBQ0Q7WUFDM0Y7WUFDQSxPQUFPRTtRQUNSO1FBQ0EsTUFBTUUsUUFBUSxNQUFNQyxRQUFRQyxHQUFHLENBQUNsQixNQUFNMUIsR0FBRyxDQUFDLE9BQU8yQixNQUFNYztZQUN0RCxNQUFNSSxZQUFZLE1BQU1yRyx5RUFBa0JBLENBQUMrRSxLQUFLVyxNQUFNLEVBQUVQO1lBQ3hELE9BQU87Z0JBQ05BO2dCQUNBa0I7Z0JBQ0FDLGFBQWE7b0JBQ1osTUFBTWhCLFNBQVMsTUFBTUQsVUFBVWQsSUFBSTtvQkFDbkMsSUFBSXVCLFFBQVFSLE1BQU0sQ0FBQ1csTUFBTTtvQkFDekIsSUFBSUksV0FBV1YsS0FBS1ksU0FBUyxnQkFBZ0I7d0JBQzVDLE1BQU1DLGNBQWN6QixLQUFLRixPQUFPLENBQUNyQyxHQUFHLENBQUMsb0JBQW9CdUMsS0FBS0UsWUFBWSxDQUFDekMsR0FBRyxDQUFDLGtCQUFrQnVDLEtBQUtFLFlBQVksQ0FBQ3pDLEdBQUcsQ0FBQzt3QkFDdkgsSUFBSWdFLGFBQWEsSUFBSWpHLDZEQUFRQSxDQUFDdUYsUUFBUUEsUUFBUTs0QkFDN0MsR0FBR0EsS0FBSzs0QkFDUlU7d0JBQ0Q7NkJBQ0tWLFVBQVU7NEJBQUVVO3dCQUFZO29CQUM5QjtvQkFDQSxPQUFPVjtnQkFDUjtnQkFDQXJCLFFBQVE7b0JBQ1AsT0FBT1ksVUFBVVosTUFBTSxJQUFJLENBQUN3QixNQUFNO2dCQUNuQztZQUNEO1FBQ0Q7UUFDQSxNQUFNUSxRQUFRLElBQUlDLElBQUlSLE1BQU0xQyxHQUFHLENBQUMsQ0FBQ2pCLE9BQVNBLEtBQUs4RCxTQUFTLEVBQUVWLEtBQUtZLE1BQU1qRCxNQUFNLENBQUNxRDtRQUM1RSxtQ0FBbUMsR0FDbkMsSUFBSUYsTUFBTUcsSUFBSSxHQUFHLEdBQUcsTUFBTSxJQUFJN0csNERBQVNBLENBQUM7WUFDdkM0RCxNQUFNO1lBQ05DLFNBQVMsQ0FBQyxvQ0FBb0MsRUFBRWlELE1BQU05RSxJQUFJLENBQUMwRSxPQUFPaEQsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMvRTtRQUNBLE1BQU04QyxPQUFPRSxNQUFNSyxNQUFNLEdBQUdDLElBQUksR0FBRy9ELEtBQUssSUFBSTtRQUM1QyxNQUFNZ0Usc0JBQXNCakMsS0FBS0UsWUFBWSxDQUFDekMsR0FBRyxDQUFDO1FBQ2xELE1BQU15RSxPQUFPO1lBQ1pqQztZQUNBa0MsUUFBUXRDLElBQUlDLE9BQU8sQ0FBQ3JDLEdBQUcsQ0FBQztZQUN4QjBEO1lBQ0FLO1lBQ0FZLGtCQUFrQkgsd0JBQXdCLE9BQU8sT0FBT25ELGdDQUFnQ21EO1lBQ3hGSSxRQUFReEMsSUFBSXdDLE1BQU07WUFDbEJDLEtBQUt0QyxLQUFLc0MsR0FBRztRQUNkO1FBQ0EsT0FBT0o7SUFDUjtBQUNEO0FBQ0EsTUFBTUssNkJBQTZCO0lBQ2xDM0MsU0FBUUMsR0FBRztRQUNWLE9BQU8sQ0FBQyxDQUFDQSxJQUFJQyxPQUFPLENBQUNyQyxHQUFHLENBQUMsaUJBQWlCc0MsV0FBVztJQUN0RDtJQUNBLE1BQU1kLE9BQU1lLElBQUk7UUFDZixNQUFNLEVBQUVILEdBQUcsRUFBRSxHQUFHRztRQUNoQixJQUFJSCxJQUFJVyxNQUFNLEtBQUssUUFBUSxNQUFNLElBQUl4Riw0REFBU0EsQ0FBQztZQUM5QzRELE1BQU07WUFDTkMsU0FBUztRQUNWO1FBQ0EsTUFBTXlCLFlBQVlwQixLQUFLO1lBQ3RCLE1BQU1zRCxLQUFLLE1BQU0zQyxJQUFJNEMsUUFBUTtZQUM3QixPQUFPRDtRQUNSO1FBQ0EsTUFBTWxCLFlBQVksTUFBTXJHLHlFQUFrQkEsQ0FBQytFLEtBQUtXLE1BQU0sRUFBRVgsS0FBS0ksSUFBSTtRQUNqRSxPQUFPO1lBQ04rQixRQUFRO1lBQ1JoQixPQUFPO2dCQUFDO29CQUNQZixNQUFNSixLQUFLSSxJQUFJO29CQUNmbUIsYUFBYWpCLFVBQVVkLElBQUk7b0JBQzNCRSxRQUFRWSxVQUFVWixNQUFNO29CQUN4QjRCO2dCQUNEO2FBQUU7WUFDRnJCLGFBQWE7WUFDYnVCLE1BQU07WUFDTlksa0JBQWtCO1lBQ2xCQyxRQUFReEMsSUFBSXdDLE1BQU07WUFDbEJDLEtBQUt0QyxLQUFLc0MsR0FBRztRQUNkO0lBQ0Q7QUFDRDtBQUNBLE1BQU1JLGdDQUFnQztJQUNyQzlDLFNBQVFDLEdBQUc7UUFDVixPQUFPLENBQUMsQ0FBQ0EsSUFBSUMsT0FBTyxDQUFDckMsR0FBRyxDQUFDLGlCQUFpQnNDLFdBQVc7SUFDdEQ7SUFDQSxNQUFNZCxPQUFNZSxJQUFJO1FBQ2YsTUFBTSxFQUFFSCxHQUFHLEVBQUUsR0FBR0c7UUFDaEIsSUFBSUgsSUFBSVcsTUFBTSxLQUFLLFFBQVEsTUFBTSxJQUFJeEYsNERBQVNBLENBQUM7WUFDOUM0RCxNQUFNO1lBQ05DLFNBQVM7UUFDVjtRQUNBLE1BQU15QixZQUFZcEIsS0FBSztZQUN0QixPQUFPVyxJQUFJOEMsSUFBSTtRQUNoQjtRQUNBLE9BQU87WUFDTnhCLE9BQU87Z0JBQUM7b0JBQ1BmLE1BQU1KLEtBQUtJLElBQUk7b0JBQ2ZtQixhQUFhakIsVUFBVWQsSUFBSTtvQkFDM0JFLFFBQVFZLFVBQVVaLE1BQU07b0JBQ3hCNEIsV0FBVyxNQUFNckcseUVBQWtCQSxDQUFDK0UsS0FBS1csTUFBTSxFQUFFWCxLQUFLSSxJQUFJO2dCQUMzRDthQUFFO1lBQ0ZILGFBQWE7WUFDYmtDLFFBQVE7WUFDUlgsTUFBTTtZQUNOWSxrQkFBa0I7WUFDbEJDLFFBQVF4QyxJQUFJd0MsTUFBTTtZQUNsQkMsS0FBS3RDLEtBQUtzQyxHQUFHO1FBQ2Q7SUFDRDtBQUNEO0FBQ0EsTUFBTU0sV0FBVztJQUNoQmpEO0lBQ0E0QztJQUNBRztDQUNBO0FBQ0QsU0FBU0csc0JBQXNCaEQsR0FBRztJQUNqQyxNQUFNaUQsVUFBVUYsU0FBU0csSUFBSSxDQUFDLENBQUNDLFlBQWNBLFVBQVVwRCxPQUFPLENBQUNDO0lBQy9ELElBQUlpRCxTQUFTLE9BQU9BO0lBQ3BCLElBQUksQ0FBQ0EsV0FBV2pELElBQUlXLE1BQU0sS0FBSyxPQUFPLE9BQU9iO0lBQzdDLE1BQU0sSUFBSTNFLDREQUFTQSxDQUFDO1FBQ25CNEQsTUFBTTtRQUNOQyxTQUFTZ0IsSUFBSUMsT0FBTyxDQUFDbUQsR0FBRyxDQUFDLGtCQUFrQixDQUFDLDBCQUEwQixFQUFFcEQsSUFBSUMsT0FBTyxDQUFDckMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEdBQUc7SUFDN0c7QUFDRDtBQUNBLGVBQWV5RixlQUFlbEQsSUFBSTtJQUNqQyxNQUFNOEMsVUFBVUQsc0JBQXNCN0MsS0FBS0gsR0FBRztJQUM5QyxPQUFPLE1BQU1pRCxRQUFRN0QsS0FBSyxDQUFDZTtBQUM1QjtBQUVBLFlBQVk7QUFDWiw0REFBNEQ7QUFDNUQsU0FBU21ELGFBQWFDLEtBQUs7SUFDMUIsT0FBTzVILDZEQUFRQSxDQUFDNEgsVUFBVUEsS0FBSyxDQUFDLE9BQU8sS0FBSztBQUM3QztBQUNBLFNBQVNDLGdCQUFnQnhFLFVBQVUsWUFBWTtJQUM5QyxNQUFNLElBQUl5RSxhQUFhekUsU0FBUztBQUNqQztBQUVBLFlBQVk7QUFDWiwyQ0FBMkM7QUFDM0M7O0FBRUEsR0FDQSxNQUFNMEUsb0JBQW9CLGFBQWEsR0FBRyxJQUFJQztBQUM5Qzs7Z0JBRWdCLEdBQ2hCLE1BQU1DLE9BQU8sS0FBTzs7QUFDcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBLEdBQ0EsSUFBSUMsWUFBWSxNQUFNQTs7ZUE0RnBCcEUsT0FBT3FFLFdBQVc7O0lBakZuQkMsWUFBWUMsR0FBRyxDQUFFO1FBUGpCO2lGQUNnRixRQUNoRkMsY0FBYyxFQUFFO1FBQ2hCOztnRUFFK0QsUUFDL0RDLGFBQWE7UUFpRmIscUJBQXFCLE9BQ3JCLE1BQW9CLEdBQUc7UUFoRnRCLElBQUksT0FBT0YsUUFBUSxZQUFZLElBQUksQ0FBQ3pFLE9BQU8sR0FBRyxJQUFJZ0MsUUFBUXlDO2FBQ3JELElBQUksQ0FBQ3pFLE9BQU8sR0FBR3lFO1FBQ3BCLE1BQU1HLGFBQWEsSUFBSSxDQUFDNUUsT0FBTyxDQUFDNkUsSUFBSSxDQUFDLENBQUNoRztZQUNyQyxNQUFNLEVBQUU2RixXQUFXLEVBQUUsR0FBRyxJQUFJO1lBQzVCLElBQUksQ0FBQ0EsV0FBVyxHQUFHO1lBQ25CLElBQUksQ0FBQ0MsVUFBVSxHQUFHO2dCQUNqQkcsUUFBUTtnQkFDUmpHO1lBQ0Q7WUFDQTZGLGFBQWFLLFFBQVEsQ0FBQyxFQUFFQyxPQUFPLEVBQUU7Z0JBQ2hDQSxRQUFRbkc7WUFDVDtRQUNEO1FBQ0EsSUFBSSxXQUFXK0YsWUFBWUEsV0FBV3ZFLEtBQUssQ0FBQyxDQUFDNEU7WUFDNUMsTUFBTSxFQUFFUCxXQUFXLEVBQUUsR0FBRyxJQUFJO1lBQzVCLElBQUksQ0FBQ0EsV0FBVyxHQUFHO1lBQ25CLElBQUksQ0FBQ0MsVUFBVSxHQUFHO2dCQUNqQkcsUUFBUTtnQkFDUkc7WUFDRDtZQUNBUCxhQUFhSyxRQUFRLENBQUMsRUFBRUcsTUFBTSxFQUFFO2dCQUMvQkEsT0FBT0Q7WUFDUjtRQUNEO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkEsR0FDQUUsWUFBWTtRQUNYLElBQUluRjtRQUNKLElBQUlvRjtRQUNKLE1BQU0sRUFBRVQsVUFBVSxFQUFFLEdBQUcsSUFBSTtRQUMzQixJQUFJQSxlQUFlLE1BQU07WUFDeEIsSUFBSSxJQUFJLENBQUNELFdBQVcsS0FBSyxNQUFNLE1BQU0sSUFBSTFGLE1BQU07WUFDL0MsTUFBTXFHLGFBQWFDO1lBQ25CLElBQUksQ0FBQ1osV0FBVyxHQUFHYSxlQUFlLElBQUksQ0FBQ2IsV0FBVyxFQUFFVztZQUNwRHJGLFVBQVVxRixXQUFXckYsT0FBTztZQUM1Qm9GLGNBQWM7Z0JBQ2IsSUFBSSxJQUFJLENBQUNWLFdBQVcsS0FBSyxNQUFNLElBQUksQ0FBQ0EsV0FBVyxHQUFHYyxrQkFBa0IsSUFBSSxDQUFDZCxXQUFXLEVBQUVXO1lBQ3ZGO1FBQ0QsT0FBTztZQUNOLE1BQU0sRUFBRVAsTUFBTSxFQUFFLEdBQUdIO1lBQ25CLElBQUlHLFdBQVcsYUFBYTlFLFVBQVVnQyxRQUFRZ0QsT0FBTyxDQUFDTCxXQUFXOUYsS0FBSztpQkFDakVtQixVQUFVZ0MsUUFBUWtELE1BQU0sQ0FBQ1AsV0FBV00sTUFBTTtZQUMvQ0csY0FBY2Y7UUFDZjtRQUNBLE9BQU81SCxPQUFPZ0osTUFBTSxDQUFDekYsU0FBUztZQUFFb0Y7UUFBWTtJQUM3QztJQUNBLGlFQUFpRSxHQUNqRVAsS0FBS2EsV0FBVyxFQUFFQyxVQUFVLEVBQUU7UUFDN0IsTUFBTUMsYUFBYSxJQUFJLENBQUNULFNBQVM7UUFDakMsTUFBTSxFQUFFQyxXQUFXLEVBQUUsR0FBR1E7UUFDeEIsT0FBT25KLE9BQU9nSixNQUFNLENBQUNHLFdBQVdmLElBQUksQ0FBQ2EsYUFBYUMsYUFBYTtZQUFFUDtRQUFZO0lBQzlFO0lBQ0EvRSxNQUFNc0YsVUFBVSxFQUFFO1FBQ2pCLE1BQU1DLGFBQWEsSUFBSSxDQUFDVCxTQUFTO1FBQ2pDLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdRO1FBQ3hCLE9BQU9uSixPQUFPZ0osTUFBTSxDQUFDRyxXQUFXdkYsS0FBSyxDQUFDc0YsYUFBYTtZQUFFUDtRQUFZO0lBQ2xFO0lBQ0FTLFFBQVFDLFNBQVMsRUFBRTtRQUNsQixNQUFNRixhQUFhLElBQUksQ0FBQ1QsU0FBUztRQUNqQyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHUTtRQUN4QixPQUFPbkosT0FBT2dKLE1BQU0sQ0FBQ0csV0FBV0MsT0FBTyxDQUFDQyxZQUFZO1lBQUVWO1FBQVk7SUFDbkU7SUFHQSw2QkFBNkIsR0FDN0I7c0NBQ3FDLEdBQ3JDLE9BQU9XLE1BQU0vRixPQUFPLEVBQUU7UUFDckIsTUFBTWdHLFNBQVMxQixVQUFVMkIsc0JBQXNCLENBQUNqRztRQUNoRCxPQUFPLE9BQU9nRyxXQUFXLGNBQWNBLFNBQVMxQixVQUFVNEIseUJBQXlCLENBQUNsRztJQUNyRjtJQUNBLGdFQUFnRSxHQUNoRSxPQUFPa0csMEJBQTBCbEcsT0FBTyxFQUFFO1FBQ3pDLE1BQU1tRyxVQUFVLElBQUk3QixVQUFVdEU7UUFDOUJtRSxrQkFBa0JpQyxHQUFHLENBQUNwRyxTQUFTbUc7UUFDL0JoQyxrQkFBa0JpQyxHQUFHLENBQUNELFNBQVNBO1FBQy9CLE9BQU9BO0lBQ1I7SUFDQSwwRUFBMEUsR0FDMUUsT0FBT0YsdUJBQXVCakcsT0FBTyxFQUFFO1FBQ3RDLE9BQU9tRSxrQkFBa0I5RixHQUFHLENBQUMyQjtJQUM5QjtJQUNBLDJCQUEyQixHQUMzQjtpRUFDZ0UsR0FDaEUsT0FBT2dGLFFBQVFuRyxLQUFLLEVBQUU7UUFDckIsTUFBTW1CLFVBQVUsT0FBT25CLFVBQVUsWUFBWUEsVUFBVSxRQUFRLFVBQVVBLFNBQVMsT0FBT0EsTUFBTWdHLElBQUksS0FBSyxhQUFhaEcsUUFBUW1ELFFBQVFnRCxPQUFPLENBQUNuRztRQUM3SSxPQUFPeUYsVUFBVXlCLEtBQUssQ0FBQy9GLFNBQVNtRixTQUFTO0lBQzFDO0lBQ0EsYUFBYWtCLElBQUkxRCxNQUFNLEVBQUU7UUFDeEIsTUFBTTJELGNBQWM1RCxNQUFNNkQsT0FBTyxDQUFDNUQsVUFBVUEsU0FBUztlQUFJQTtTQUFPO1FBQ2hFLE1BQU02RCxxQkFBcUJGLFlBQVlqSCxHQUFHLENBQUNpRixVQUFVVSxPQUFPO1FBQzVELElBQUk7WUFDSCxPQUFPLE1BQU1oRCxRQUFRcUUsR0FBRyxDQUFDRztRQUMxQixTQUFVO1lBQ1RBLG1CQUFtQnpCLE9BQU8sQ0FBQyxDQUFDLEVBQUVLLFdBQVcsRUFBRTtnQkFDMUNBO1lBQ0Q7UUFDRDtJQUNEO0lBQ0EsYUFBYXFCLEtBQUs5RCxNQUFNLEVBQUU7UUFDekIsTUFBTTJELGNBQWM1RCxNQUFNNkQsT0FBTyxDQUFDNUQsVUFBVUEsU0FBUztlQUFJQTtTQUFPO1FBQ2hFLE1BQU02RCxxQkFBcUJGLFlBQVlqSCxHQUFHLENBQUNpRixVQUFVVSxPQUFPO1FBQzVELElBQUk7WUFDSCxPQUFPLE1BQU1oRCxRQUFReUUsSUFBSSxDQUFDRDtRQUMzQixTQUFVO1lBQ1RBLG1CQUFtQnpCLE9BQU8sQ0FBQyxDQUFDLEVBQUVLLFdBQVcsRUFBRTtnQkFDMUNBO1lBQ0Q7UUFDRDtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7O0dBV0UsR0FDRixhQUFhc0IsZUFBZUMsUUFBUSxFQUFFO1FBQ3JDLE1BQU1DLGVBQWVELFNBQVN0SCxHQUFHLENBQUN3SDtRQUNsQyxJQUFJO1lBQ0gsT0FBTyxNQUFNN0UsUUFBUXlFLElBQUksQ0FBQ0c7UUFDM0IsU0FBVTtZQUNULEtBQUssTUFBTTVHLFdBQVc0RyxhQUFjNUcsUUFBUW9GLFdBQVc7UUFDeEQ7SUFDRDtBQUNEO0FBQ0E7Ozs7O0VBS0UsR0FDRixTQUFTeUIsaUJBQWlCN0csT0FBTztJQUNoQyxPQUFPc0UsVUFBVXlCLEtBQUssQ0FBQy9GLFNBQVM2RSxJQUFJLENBQUMsSUFBTTtZQUFDN0U7U0FBUTtBQUNyRDtBQUNBLHdDQUF3QyxHQUN4Qyx3RkFBd0YsR0FDeEYsU0FBU3NGO0lBQ1IsSUFBSU47SUFDSixJQUFJRTtJQUNKLE1BQU1sRixVQUFVLElBQUlnQyxRQUFRLENBQUM4RSxVQUFVQztRQUN0Qy9CLFVBQVU4QjtRQUNWNUIsU0FBUzZCO0lBQ1Y7SUFDQSxPQUFPO1FBQ04vRztRQUNBZ0Y7UUFDQUU7SUFDRDtBQUNEO0FBQ0EsOEJBQThCLEdBQzlCLFNBQVNLLGVBQWV5QixHQUFHLEVBQUVDLE1BQU07SUFDbEMsT0FBTztXQUFJRDtRQUFLQztLQUFPO0FBQ3hCO0FBQ0EsU0FBU0MsaUJBQWlCRixHQUFHLEVBQUVsRixLQUFLO0lBQ25DLE9BQU87V0FBSWtGLElBQUlHLEtBQUssQ0FBQyxHQUFHckY7V0FBV2tGLElBQUlHLEtBQUssQ0FBQ3JGLFFBQVE7S0FBRztBQUN6RDtBQUNBLFNBQVMwRCxrQkFBa0J3QixHQUFHLEVBQUVDLE1BQU07SUFDckMsTUFBTW5GLFFBQVFrRixJQUFJSSxPQUFPLENBQUNIO0lBQzFCLElBQUluRixVQUFVLENBQUMsR0FBRyxPQUFPb0YsaUJBQWlCRixLQUFLbEY7SUFDL0MsT0FBT2tGO0FBQ1I7QUFFQSxZQUFZO0FBQ1osb0VBQW9FO0FBQ3BFOUcsT0FBT21ILE9BQU8sS0FBS25IO0FBQ25CQSxPQUFPb0gsWUFBWSxLQUFLcEg7QUFDeEI7Ozs7OztBQU1BLEdBQ0EsU0FBU3FILGFBQWFDLEtBQUssRUFBRUgsT0FBTztJQUNuQyxNQUFNSSxLQUFLRDtJQUNYLE1BQU1FLFdBQVdELEVBQUUsQ0FBQ3ZILE9BQU9tSCxPQUFPLENBQUM7SUFDbkNJLEVBQUUsQ0FBQ3ZILE9BQU9tSCxPQUFPLENBQUMsR0FBRztRQUNwQkE7UUFDQUs7SUFDRDtJQUNBLE9BQU9EO0FBQ1I7QUFDQTs7Ozs7O0FBTUEsR0FDQSxTQUFTRSxrQkFBa0JILEtBQUssRUFBRUgsT0FBTztJQUN4QyxNQUFNSSxLQUFLRDtJQUNYLE1BQU1FLFdBQVdELEVBQUUsQ0FBQ3ZILE9BQU9vSCxZQUFZLENBQUM7SUFDeENHLEVBQUUsQ0FBQ3ZILE9BQU9vSCxZQUFZLENBQUMsR0FBRztRQUN6QixNQUFNRDtRQUNOLE1BQU1LO0lBQ1A7SUFDQSxPQUFPRDtBQUNSO0FBRUEsWUFBWTtBQUNaLHVFQUF1RTtBQUN2RSxNQUFNRywrQkFBK0IxSDtBQUNyQyxTQUFTMkgsY0FBY0MsRUFBRTtJQUN4QixJQUFJQyxRQUFRO0lBQ1osT0FBT1IsYUFBYTtRQUFFUztZQUNyQixJQUFJRCxPQUFPLE1BQU0sSUFBSS9JLE1BQU07WUFDM0IsTUFBTWdCLFVBQVUsSUFBSWdDLFFBQVEsQ0FBQ2dEO2dCQUM1QitDLFFBQVFFLFdBQVcsSUFBTWpELFFBQVE0QywrQkFBK0JFO1lBQ2pFO1lBQ0EsT0FBTzlIO1FBQ1I7SUFBRSxHQUFHO1FBQ0osSUFBSStILE9BQU9HLGFBQWFIO0lBQ3pCO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osd0hBQXdIO0FBQ3hILElBQUlJLG1CQUFtQjdLLFdBQVc7SUFBRSxrSEFBaUhHLE9BQU8sRUFBRTJLLE1BQU07UUFDbkssU0FBU0M7WUFDUixJQUFJQyxJQUFJLGNBQWMsT0FBT0Msa0JBQWtCQSxrQkFBa0IsU0FBU0MsR0FBRyxFQUFFQyxHQUFHO2dCQUNqRixJQUFJQyxNQUFNMUo7Z0JBQ1YsT0FBTzBKLElBQUlDLElBQUksR0FBRyxtQkFBbUJELElBQUkxRSxLQUFLLEdBQUd3RSxLQUFLRSxJQUFJRSxVQUFVLEdBQUdILEtBQUtDO1lBQzdFLEdBQUdHLElBQUksQ0FBQyxHQUFHNUssSUFBSSxFQUFFO1lBQ2pCLFNBQVM2SyxNQUFNTixHQUFHLEVBQUVDLEdBQUc7Z0JBQ3RCLElBQUksUUFBUUEsS0FBSztvQkFDaEIsSUFBSWhNLE9BQU9nTSxTQUFTQSxLQUFLLE1BQU0sSUFBSU0sVUFBVTtvQkFDN0MsSUFBSVAsS0FBSyxJQUFJUSxJQUFJUCxHQUFHLENBQUN2SSxPQUFPb0gsWUFBWSxJQUFJcEgsTUFBTSxDQUFDLE1BQU0sQ0FBQyx1QkFBdUI7b0JBQ2pGLElBQUksS0FBSyxNQUFNOEksS0FBTUEsQ0FBQUEsSUFBSVAsR0FBRyxDQUFDdkksT0FBT21ILE9BQU8sSUFBSW5ILE1BQU0sQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUVzSSxHQUFFLEdBQUksSUFBSVMsSUFBSUQ7b0JBQy9GLElBQUksY0FBYyxPQUFPQSxHQUFHLE1BQU0sSUFBSUQsVUFBVTtvQkFDaERFLEtBQU1ELENBQUFBLElBQUksU0FBU0U7d0JBQ2xCLElBQUk7NEJBQ0hELEVBQUU3SyxJQUFJLENBQUNxSzt3QkFDUixFQUFFLE9BQU9VLEtBQUs7NEJBQ2IsT0FBT25ILFFBQVFrRCxNQUFNLENBQUNpRTt3QkFDdkI7b0JBQ0QsSUFBSWxMLEVBQUVtTCxJQUFJLENBQUM7d0JBQ1ZDLEdBQUdaO3dCQUNIYSxHQUFHTjt3QkFDSE8sR0FBR2Y7b0JBQ0o7Z0JBQ0QsT0FBT0EsT0FBT3ZLLEVBQUVtTCxJQUFJLENBQUM7b0JBQ3BCRSxHQUFHYjtvQkFDSGMsR0FBR2Y7Z0JBQ0o7Z0JBQ0EsT0FBT0M7WUFDUjtZQUNBLE9BQU87Z0JBQ05JO2dCQUNBVyxHQUFHVixNQUFNdkssSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDckJnTCxHQUFHVCxNQUFNdkssSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDckIrSyxHQUFHLFNBQVNBO29CQUNYLElBQUlOLEdBQUdDLElBQUksSUFBSSxDQUFDSixDQUFDLEVBQUVZLElBQUk7b0JBQ3ZCLFNBQVM3Rzt3QkFDUixNQUFPb0csSUFBSS9LLEVBQUV5TCxHQUFHLElBQUssSUFBSTs0QkFDeEIsSUFBSSxDQUFDVixFQUFFTyxDQUFDLElBQUksTUFBTUUsR0FBRyxPQUFPQSxJQUFJLEdBQUd4TCxFQUFFbUwsSUFBSSxDQUFDSixJQUFJaEgsUUFBUWdELE9BQU8sR0FBR0gsSUFBSSxDQUFDakM7NEJBQ3JFLElBQUlvRyxFQUFFTSxDQUFDLEVBQUU7Z0NBQ1IsSUFBSWQsTUFBTVEsRUFBRU0sQ0FBQyxDQUFDbEwsSUFBSSxDQUFDNEssRUFBRUssQ0FBQztnQ0FDdEIsSUFBSUwsRUFBRU8sQ0FBQyxFQUFFLE9BQU9FLEtBQUssR0FBR3pILFFBQVFnRCxPQUFPLENBQUN3RCxLQUFLM0QsSUFBSSxDQUFDakMsTUFBTStHOzRCQUN6RCxPQUFPRixLQUFLO3dCQUNiLEVBQUUsT0FBT04sS0FBSzs0QkFDYixPQUFPUSxJQUFJUjt3QkFDWjt3QkFDQSxJQUFJLE1BQU1NLEdBQUcsT0FBT1IsTUFBTUosSUFBSTdHLFFBQVFrRCxNQUFNLENBQUMrRCxLQUFLakgsUUFBUWdELE9BQU87d0JBQ2pFLElBQUlpRSxNQUFNSixHQUFHLE1BQU1JO29CQUNwQjtvQkFDQSxTQUFTVSxJQUFJakIsR0FBRzt3QkFDZixPQUFPTyxJQUFJQSxNQUFNSixJQUFJLElBQUlQLEVBQUVJLEtBQUtPLEtBQUtQLEtBQUs5RjtvQkFDM0M7b0JBQ0EsT0FBT0E7Z0JBQ1I7WUFDRDtRQUNEO1FBQ0F3RixPQUFPM0ssT0FBTyxHQUFHNEssV0FBV0QsT0FBTzNLLE9BQU8sQ0FBQ21CLFVBQVUsR0FBRyxNQUFNd0osT0FBTzNLLE9BQU8sQ0FBQyxVQUFVLEdBQUcySyxPQUFPM0ssT0FBTztJQUN6RztBQUFFO0FBRUYsWUFBWTtBQUNaLHVFQUF1RTtBQUN2RSxJQUFJbU0sb0JBQW9CbkwsUUFBUTBKLG9CQUFvQjtBQUNwRCxTQUFTMEIsaUJBQWlCQyxRQUFRO0lBQ2pDLE1BQU1DLFdBQVdELFFBQVEsQ0FBQzVKLE9BQU84SixhQUFhLENBQUM7SUFDL0MsSUFBSUQsUUFBUSxDQUFDN0osT0FBT29ILFlBQVksQ0FBQyxFQUFFLE9BQU95QztJQUMxQyxPQUFPcEMsa0JBQWtCb0MsVUFBVTtRQUNsQyxNQUFNQSxTQUFTRSxNQUFNO0lBQ3RCO0FBQ0Q7QUFDQTs7QUFFQSxHQUNBLGdCQUFnQkMsZ0JBQWdCSixRQUFRLEVBQUVsSixJQUFJO0lBQzdDLElBQUk7UUFDSCxJQUFJdUosY0FBYyxDQUFDLEdBQUdQLGtCQUFrQlEsT0FBTztRQUMvQyxNQUFNTCxXQUFXSSxZQUFZWixDQUFDLENBQUNNLGlCQUFpQkM7UUFDaEQsTUFBTS9CLFFBQVFvQyxZQUFZWCxDQUFDLENBQUMzQixjQUFjakgsS0FBS3lKLGFBQWE7UUFDNUQsTUFBTUMsZUFBZXZDLE1BQU1DLEtBQUs7UUFDaEMsSUFBSTFIO1FBQ0osTUFBTyxLQUFNO1lBQ1pBLFNBQVMsTUFBTWdFLFVBQVVtQyxJQUFJLENBQUM7Z0JBQUNzRCxTQUFTbkgsSUFBSTtnQkFBSTBIO2FBQWE7WUFDN0QsSUFBSWhLLFdBQVdzSCw4QkFBOEIzRDtZQUM3QyxJQUFJM0QsT0FBT2lLLElBQUksRUFBRSxPQUFPaks7WUFDeEIsTUFBTUEsT0FBT3pCLEtBQUs7WUFDbEJ5QixTQUFTO1FBQ1Y7SUFDRCxFQUFFLE9BQU9rSyxHQUFHO1FBQ1hMLFlBQVl0QixDQUFDLEdBQUcyQjtJQUNqQixTQUFVO1FBQ1QsTUFBTUwsWUFBWWIsQ0FBQztJQUNwQjtBQUNEO0FBQ0E7Ozs7QUFJQSxHQUNBLGdCQUFnQm1CLGNBQWNYLFFBQVEsRUFBRWxKLElBQUk7SUFDM0MsSUFBSTtRQUNILElBQUk4SixhQUFhLENBQUMsR0FBR2Qsa0JBQWtCUSxPQUFPO1FBQzlDLE1BQU1MLFdBQVdXLFdBQVduQixDQUFDLENBQUNNLGlCQUFpQkM7UUFDL0MsSUFBSXhKO1FBQ0osTUFBTXlILFFBQVEyQyxXQUFXbEIsQ0FBQyxDQUFDM0IsY0FBY2pILEtBQUsrSixhQUFhO1FBQzNELElBQUlDLFFBQVFoSyxLQUFLZ0ssS0FBSztRQUN0QixJQUFJTixlQUFlLElBQUl0SSxRQUFRLEtBQU87UUFDdEMsTUFBTyxLQUFNO1lBQ1oxQixTQUFTLE1BQU1nRSxVQUFVbUMsSUFBSSxDQUFDO2dCQUFDc0QsU0FBU25ILElBQUk7Z0JBQUkwSDthQUFhO1lBQzdELElBQUloSyxXQUFXc0gsOEJBQThCM0Q7WUFDN0MsSUFBSTNELE9BQU9pSyxJQUFJLEVBQUUsT0FBT2pLLE9BQU96QixLQUFLO1lBQ3BDLE1BQU15QixPQUFPekIsS0FBSztZQUNsQixJQUFJLEVBQUUrTCxVQUFVLEdBQUdOLGVBQWV2QyxNQUFNQyxLQUFLO1lBQzdDMUgsU0FBUztRQUNWO0lBQ0QsRUFBRSxPQUFPa0ssR0FBRztRQUNYRSxXQUFXN0IsQ0FBQyxHQUFHMkI7SUFDaEIsU0FBVTtRQUNULE1BQU1FLFdBQVdwQixDQUFDO0lBQ25CO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osd0VBQXdFO0FBQ3hFLFNBQVN1QjtJQUNSLElBQUk3RjtJQUNKLElBQUlFO0lBQ0osTUFBTWxGLFVBQVUsSUFBSWdDLFFBQVEsQ0FBQzhJLEtBQUtDO1FBQ2pDL0YsVUFBVThGO1FBQ1Y1RixTQUFTNkY7SUFDVjtJQUNBLE9BQU87UUFDTi9LO1FBQ0FnRjtRQUNBRTtJQUNEO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osNkVBQTZFO0FBQzdFLElBQUk4RixvQkFBb0J2TSxRQUFRMEosb0JBQW9CO0FBQ3BELFNBQVM4QyxzQkFBc0JuQixRQUFRLEVBQUVvQixRQUFRO0lBQ2hELE1BQU1uQixXQUFXRCxRQUFRLENBQUM1SixPQUFPOEosYUFBYSxDQUFDO0lBQy9DLElBQUltQixRQUFRO0lBQ1osU0FBU0M7UUFDUkQsUUFBUTtRQUNSRCxXQUFXLEtBQU87SUFDbkI7SUFDQSxTQUFTRztRQUNSLElBQUlGLFVBQVUsUUFBUTtRQUN0QkEsUUFBUTtRQUNSLE1BQU12SSxPQUFPbUgsU0FBU25ILElBQUk7UUFDMUJBLEtBQUtpQyxJQUFJLENBQUMsQ0FBQ3ZFO1lBQ1YsSUFBSUEsT0FBT2lLLElBQUksRUFBRTtnQkFDaEJZLFFBQVE7Z0JBQ1JELFNBQVM7b0JBQ1JwRyxRQUFRO29CQUNSakcsT0FBT3lCLE9BQU96QixLQUFLO2dCQUNwQjtnQkFDQXVNO2dCQUNBO1lBQ0Q7WUFDQUQsUUFBUTtZQUNSRCxTQUFTO2dCQUNScEcsUUFBUTtnQkFDUmpHLE9BQU95QixPQUFPekIsS0FBSztZQUNwQjtRQUNELEdBQUd3QixLQUFLLENBQUMsQ0FBQ2Q7WUFDVDJMLFNBQVM7Z0JBQ1JwRyxRQUFRO2dCQUNSZCxPQUFPekU7WUFDUjtZQUNBNkw7UUFDRDtJQUNEO0lBQ0EsT0FBTztRQUNOQztRQUNBQyxTQUFTO1lBQ1JGO1lBQ0EsTUFBTXJCLFNBQVNFLE1BQU07UUFDdEI7SUFDRDtBQUNEO0FBQ0E7Ozs7Ozs7Ozs7QUFVQSxHQUNBLFNBQVNzQjtJQUNSLElBQUlKLFFBQVE7SUFDWixJQUFJSyxjQUFjWDtJQUNsQjs7Q0FFQSxHQUNBLE1BQU1ZLFlBQVksRUFBRTtJQUNwQjs7Q0FFQSxHQUNBLE1BQU1DLFlBQVksYUFBYSxHQUFHLElBQUluSjtJQUN0QyxNQUFNb0osU0FBUyxFQUFFO0lBQ2pCLFNBQVNDLGFBQWE5QixRQUFRO1FBQzdCLElBQUlxQixVQUFVLFdBQVc7UUFDekIsTUFBTXBCLFdBQVdrQixzQkFBc0JuQixVQUFVLENBQUN4SjtZQUNqRCxJQUFJNkssVUFBVSxXQUFXO1lBQ3pCLE9BQVE3SyxPQUFPd0UsTUFBTTtnQkFDcEIsS0FBSztvQkFDSjZHLE9BQU92QyxJQUFJLENBQUM7d0JBQUNXO3dCQUFVeko7cUJBQU87b0JBQzlCO2dCQUNELEtBQUs7b0JBQ0pvTCxVQUFVRyxNQUFNLENBQUM5QjtvQkFDakI7Z0JBQ0QsS0FBSztvQkFDSjRCLE9BQU92QyxJQUFJLENBQUM7d0JBQUNXO3dCQUFVeko7cUJBQU87b0JBQzlCb0wsVUFBVUcsTUFBTSxDQUFDOUI7b0JBQ2pCO1lBQ0Y7WUFDQXlCLFlBQVl4RyxPQUFPO1FBQ3BCO1FBQ0EwRyxVQUFVSSxHQUFHLENBQUMvQjtRQUNkQSxTQUFTc0IsSUFBSTtJQUNkO0lBQ0EsT0FBTztRQUNOUyxLQUFJaEMsUUFBUTtZQUNYLE9BQVFxQjtnQkFDUCxLQUFLO29CQUNKTSxVQUFVckMsSUFBSSxDQUFDVTtvQkFDZjtnQkFDRCxLQUFLO29CQUNKOEIsYUFBYTlCO29CQUNiO2dCQUNELEtBQUs7b0JBQVE7WUFDZDtRQUNEO1FBQ0EsT0FBTyxDQUFDNUosT0FBTzhKLGFBQWEsQ0FBQztZQUM1QixJQUFJO2dCQUNILElBQUlHLGNBQWMsQ0FBQyxHQUFHYSxrQkFBa0JaLE9BQU87Z0JBQy9DLElBQUllLFVBQVUsUUFBUSxNQUFNLElBQUluTSxNQUFNO2dCQUN0Q21NLFFBQVE7Z0JBQ1IsTUFBTVksV0FBVzVCLFlBQVlaLENBQUMsQ0FBQzVCLGtCQUFrQixDQUFDLEdBQUc7b0JBQ3BEd0QsUUFBUTtvQkFDUixNQUFNYSxTQUFTLEVBQUU7b0JBQ2pCLE1BQU1oSyxRQUFRQyxHQUFHLENBQUNTLE1BQU05RSxJQUFJLENBQUM4TixVQUFVL0ksTUFBTSxJQUFJdEQsR0FBRyxDQUFDLE9BQU9vSTt3QkFDM0QsSUFBSTs0QkFDSCxNQUFNQSxHQUFHNkQsT0FBTzt3QkFDakIsRUFBRSxPQUFPL0wsT0FBTzs0QkFDZnlNLE9BQU81QyxJQUFJLENBQUM3Sjt3QkFDYjtvQkFDRDtvQkFDQW9NLE9BQU96TixNQUFNLEdBQUc7b0JBQ2hCd04sVUFBVU8sS0FBSztvQkFDZlQsWUFBWXhHLE9BQU87b0JBQ25CLElBQUlnSCxPQUFPOU4sTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJZ08sZUFBZUY7Z0JBQ2pEO2dCQUNBLE1BQU9QLFVBQVV2TixNQUFNLEdBQUcsRUFBRzBOLGFBQWFILFVBQVVVLEtBQUs7Z0JBQ3pELE1BQU9ULFVBQVVqSixJQUFJLEdBQUcsRUFBRztvQkFDMUIsTUFBTStJLFlBQVl4TCxPQUFPO29CQUN6QixNQUFPMkwsT0FBT3pOLE1BQU0sR0FBRyxFQUFHO3dCQUN6QixNQUFNLENBQUM2TCxVQUFVekosT0FBTyxHQUFHcUwsT0FBT1EsS0FBSzt3QkFDdkMsT0FBUTdMLE9BQU93RSxNQUFNOzRCQUNwQixLQUFLO2dDQUNKLE1BQU14RSxPQUFPekIsS0FBSztnQ0FDbEJrTCxTQUFTc0IsSUFBSTtnQ0FDYjs0QkFDRCxLQUFLO2dDQUFTLE1BQU0vSyxPQUFPMEQsS0FBSzt3QkFDakM7b0JBQ0Q7b0JBQ0F3SCxjQUFjWDtnQkFDZjtZQUNELEVBQUUsT0FBT0wsR0FBRztnQkFDWEwsWUFBWXRCLENBQUMsR0FBRzJCO1lBQ2pCLFNBQVU7Z0JBQ1QsTUFBTUwsWUFBWWIsQ0FBQztZQUNwQjtRQUNEO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWiw0RUFBNEU7QUFDNUU7Ozs7O0FBS0EsR0FDQSxTQUFTOEMsbUJBQW1CdEMsUUFBUTtJQUNuQyxNQUFNQyxXQUFXRCxRQUFRLENBQUM1SixPQUFPOEosYUFBYSxDQUFDO0lBQy9DLE9BQU8sSUFBSXFDLGVBQWU7UUFDekIsTUFBTUM7WUFDTCxNQUFNdkMsU0FBU0UsTUFBTTtRQUN0QjtRQUNBLE1BQU1vQixNQUFLa0IsVUFBVTtZQUNwQixNQUFNak0sU0FBUyxNQUFNeUosU0FBU25ILElBQUk7WUFDbEMsSUFBSXRDLE9BQU9pSyxJQUFJLEVBQUU7Z0JBQ2hCZ0MsV0FBV0MsS0FBSztnQkFDaEI7WUFDRDtZQUNBRCxXQUFXRSxPQUFPLENBQUNuTSxPQUFPekIsS0FBSztRQUNoQztJQUNEO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osa0VBQWtFO0FBQ2xFLElBQUk2TixvQkFBb0JqTyxRQUFRMEosb0JBQW9CO0FBQ3BELE1BQU13RSxXQUFXek0sT0FBTztBQUN4Qjs7O0FBR0EsR0FDQSxnQkFBZ0IwTSxTQUFTOUMsUUFBUSxFQUFFK0MsY0FBYztJQUNoRCxJQUFJO1FBQ0gsSUFBSTFDLGNBQWMsQ0FBQyxHQUFHdUMsa0JBQWtCdEMsT0FBTztRQUMvQyxNQUFNTCxXQUFXSSxZQUFZWixDQUFDLENBQUNNLGlCQUFpQkM7UUFDaEQsSUFBSXhKO1FBQ0osSUFBSXdNLGNBQWMvQyxTQUFTbkgsSUFBSTtRQUMvQixNQUFPLEtBQU0sSUFBSTtZQUNoQixJQUFJOEgsYUFBYSxDQUFDLEdBQUdnQyxrQkFBa0J0QyxPQUFPO1lBQzlDLE1BQU0yQyxjQUFjckMsV0FBV2xCLENBQUMsQ0FBQzNCLGNBQWNnRjtZQUMvQ3ZNLFNBQVMsTUFBTWdFLFVBQVVtQyxJQUFJLENBQUM7Z0JBQUNxRztnQkFBYUMsWUFBWS9FLEtBQUs7YUFBRztZQUNoRSxJQUFJMUgsV0FBV3NILDhCQUE4QjtnQkFDNUMsTUFBTStFO2dCQUNOO1lBQ0Q7WUFDQSxJQUFJck0sT0FBT2lLLElBQUksRUFBRSxPQUFPakssT0FBT3pCLEtBQUs7WUFDcENpTyxjQUFjL0MsU0FBU25ILElBQUk7WUFDM0IsTUFBTXRDLE9BQU96QixLQUFLO1lBQ2xCeUIsU0FBUztRQUNWLEVBQUUsT0FBT2tLLEdBQUc7WUFDWEUsV0FBVzdCLENBQUMsR0FBRzJCO1FBQ2hCLFNBQVU7WUFDVEUsV0FBV3BCLENBQUM7UUFDYjtJQUNELEVBQUUsT0FBT2tCLEdBQUc7UUFDWEwsWUFBWXRCLENBQUMsR0FBRzJCO0lBQ2pCLFNBQVU7UUFDVCxNQUFNTCxZQUFZYixDQUFDO0lBQ3BCO0FBQ0Q7QUFFQSxZQUFZO0FBQ1oseURBQXlEO0FBQ3pELElBQUkwRCxvQkFBb0J2TyxRQUFRMEosb0JBQW9CO0FBQ3BELFNBQVM4RSxjQUFjcE8sS0FBSztJQUMzQixPQUFPcEMsT0FBT1csU0FBUyxDQUFDOFAsUUFBUSxDQUFDOU8sSUFBSSxDQUFDUyxXQUFXO0FBQ2xEO0FBQ0EsTUFBTXNPLDJCQUEyQjtBQUNqQyxNQUFNQyxrQ0FBa0M7QUFDeEMsTUFBTUMsMkJBQTJCO0FBQ2pDLE1BQU1DLDBCQUEwQjtBQUNoQyxNQUFNQywrQkFBK0I7QUFDckMsTUFBTUMsOEJBQThCO0FBQ3BDLE1BQU1DLDhCQUE4QjtBQUNwQyxTQUFTQyxVQUFVN08sS0FBSztJQUN2QixPQUFPLENBQUN6Qyw2REFBUUEsQ0FBQ3lDLFVBQVUxQywrREFBVUEsQ0FBQzBDLE1BQUssS0FBTSxPQUFPQSxPQUFPLENBQUMsT0FBTyxLQUFLLGNBQWMsT0FBT0EsT0FBTyxDQUFDLFFBQVEsS0FBSztBQUN2SDtBQUNBLElBQUk4TyxnQkFBZ0IsY0FBYzNPO0lBQ2pDd0YsWUFBWXhELElBQUksQ0FBRTtRQUNqQixLQUFLLENBQUMsZ0NBQWdDQSxLQUFLMUIsSUFBSSxDQUFDO1FBQ2hELElBQUksQ0FBQzBCLElBQUksR0FBR0E7SUFDYjtBQUNEO0FBQ0EsZ0JBQWdCNE0sMEJBQTBCaE4sSUFBSTtJQUM3QyxNQUFNLEVBQUVpTixJQUFJLEVBQUUsR0FBR2pOO0lBQ2pCLElBQUlrTixVQUFVO0lBQ2QsTUFBTUMsY0FBYztJQUNwQixNQUFNQyxrQkFBa0J6QztJQUN4QixTQUFTMEMsY0FBY0MsUUFBUTtRQUM5QixNQUFNQyxNQUFNTDtRQUNaLE1BQU1NLGFBQWFGLFNBQVNDO1FBQzVCSCxnQkFBZ0JsQyxHQUFHLENBQUNzQztRQUNwQixPQUFPRDtJQUNSO0lBQ0EsU0FBU0UsY0FBY3JPLE9BQU8sRUFBRWdCLElBQUk7UUFDbkMsT0FBT2lOLGNBQWMsZ0JBQWlCRSxHQUFHO1lBQ3hDLE1BQU1uSyxRQUFRc0ssY0FBY3ROO1lBQzVCLElBQUlnRCxPQUFPO2dCQUNWaEUsUUFBUUssS0FBSyxDQUFDLENBQUNkO29CQUNkcUIsS0FBSzJOLE9BQU8sR0FBRzt3QkFDZHZLLE9BQU96RTt3QkFDUHlCO29CQUNEO2dCQUNEO2dCQUNBaEIsVUFBVWdDLFFBQVFrRCxNQUFNLENBQUNsQjtZQUMxQjtZQUNBLElBQUk7Z0JBQ0gsTUFBTXBCLE9BQU8sTUFBTTVDO2dCQUNuQixNQUFNO29CQUNMbU87b0JBQ0FkO29CQUNBbUIsT0FBTzVMLE1BQU01QjtpQkFDYjtZQUNGLEVBQUUsT0FBT3pCLE9BQU87Z0JBQ2ZxQixLQUFLMk4sT0FBTyxHQUFHO29CQUNkdkssT0FBT3pFO29CQUNQeUI7Z0JBQ0Q7Z0JBQ0EsTUFBTTtvQkFDTG1OO29CQUNBYjtvQkFDQTFNLEtBQUs2TixXQUFXLEdBQUc7d0JBQ2xCekssT0FBT3pFO3dCQUNQeUI7b0JBQ0Q7aUJBQ0E7WUFDRjtRQUNEO0lBQ0Q7SUFDQSxTQUFTME4sb0JBQW9CTixVQUFVLEVBQUVwTixJQUFJO1FBQzVDLE9BQU9pTixjQUFjLGdCQUFpQkUsR0FBRztZQUN4QyxJQUFJO2dCQUNILElBQUloRSxjQUFjLENBQUMsR0FBRzZDLGtCQUFrQjVDLE9BQU87Z0JBQy9DLE1BQU1wRyxRQUFRc0ssY0FBY3ROO2dCQUM1QixJQUFJZ0QsT0FBTyxNQUFNQTtnQkFDakIsTUFBTStGLFdBQVdJLFlBQVlaLENBQUMsQ0FBQ00saUJBQWlCdUU7Z0JBQ2hELElBQUk7b0JBQ0gsTUFBTyxLQUFNO3dCQUNaLE1BQU14TCxPQUFPLE1BQU1tSCxTQUFTbkgsSUFBSTt3QkFDaEMsSUFBSUEsS0FBSzJILElBQUksRUFBRTs0QkFDZCxNQUFNO2dDQUNMNEQ7Z0NBQ0FaO2dDQUNBaUIsT0FBTzVMLEtBQUsvRCxLQUFLLEVBQUVtQzs2QkFDbkI7NEJBQ0Q7d0JBQ0Q7d0JBQ0EsTUFBTTs0QkFDTG1OOzRCQUNBWDs0QkFDQWdCLE9BQU81TCxLQUFLL0QsS0FBSyxFQUFFbUM7eUJBQ25CO29CQUNGO2dCQUNELEVBQUUsT0FBT3pCLE9BQU87b0JBQ2ZxQixLQUFLMk4sT0FBTyxHQUFHO3dCQUNkdkssT0FBT3pFO3dCQUNQeUI7b0JBQ0Q7b0JBQ0EsTUFBTTt3QkFDTG1OO3dCQUNBVjt3QkFDQTdNLEtBQUs2TixXQUFXLEdBQUc7NEJBQ2xCekssT0FBT3pFOzRCQUNQeUI7d0JBQ0Q7cUJBQ0E7Z0JBQ0Y7WUFDRCxFQUFFLE9BQU93SixHQUFHO2dCQUNYTCxZQUFZdEIsQ0FBQyxHQUFHMkI7WUFDakIsU0FBVTtnQkFDVCxNQUFNTCxZQUFZYixDQUFDO1lBQ3BCO1FBQ0Q7SUFDRDtJQUNBLFNBQVNnRixjQUFjdE4sSUFBSTtRQUMxQixJQUFJSixLQUFLK04sUUFBUSxJQUFJM04sS0FBSzlDLE1BQU0sR0FBRzBDLEtBQUsrTixRQUFRLEVBQUUsT0FBTyxJQUFJaEIsY0FBYzNNO1FBQzNFLE9BQU87SUFDUjtJQUNBLFNBQVM0TixZQUFZL1AsS0FBSyxFQUFFbUMsSUFBSTtRQUMvQixJQUFJME0sVUFBVTdPLFFBQVEsT0FBTztZQUFDc087WUFBMEJrQixjQUFjeFAsT0FBT21DO1NBQU07UUFDbkYsSUFBSTlFLG9FQUFlQSxDQUFDMkMsUUFBUTtZQUMzQixJQUFJK0IsS0FBSytOLFFBQVEsSUFBSTNOLEtBQUs5QyxNQUFNLElBQUkwQyxLQUFLK04sUUFBUSxFQUFFLE1BQU0sSUFBSTNQLE1BQU07WUFDbkUsT0FBTztnQkFBQ29PO2dCQUFpQ3NCLG9CQUFvQjdQLE9BQU9tQzthQUFNO1FBQzNFO1FBQ0EsT0FBTztJQUNSO0lBQ0EsU0FBU3dOLE9BQU8zUCxLQUFLLEVBQUVtQyxJQUFJO1FBQzFCLElBQUluQyxVQUFVLEtBQUssR0FBRyxPQUFPO1lBQUMsRUFBRTtTQUFDO1FBQ2pDLE1BQU1nUSxNQUFNRCxZQUFZL1AsT0FBT21DO1FBQy9CLElBQUk2TixLQUFLLE9BQU87WUFBQztnQkFBQ2Q7YUFBWTtZQUFFO2dCQUFDO21CQUFTYzthQUFJO1NBQUM7UUFDL0MsSUFBSSxDQUFDNUIsY0FBY3BPLFFBQVEsT0FBTztZQUFDO2dCQUFDQTthQUFNO1NBQUM7UUFDM0MsTUFBTWlRLFNBQVMsQ0FBQztRQUNoQixNQUFNQyxjQUFjLEVBQUU7UUFDdEIsS0FBSyxNQUFNLENBQUM1USxLQUFLNlEsS0FBSyxJQUFJdlMsT0FBT3lDLE9BQU8sQ0FBQ0wsT0FBUTtZQUNoRCxNQUFNb1EsY0FBY0wsWUFBWUksTUFBTTttQkFBSWhPO2dCQUFNN0M7YUFBSTtZQUNwRCxJQUFJLENBQUM4USxhQUFhO2dCQUNqQkgsTUFBTSxDQUFDM1EsSUFBSSxHQUFHNlE7Z0JBQ2Q7WUFDRDtZQUNBRixNQUFNLENBQUMzUSxJQUFJLEdBQUc0UDtZQUNkZ0IsWUFBWTNGLElBQUksQ0FBQztnQkFBQ2pMO21CQUFROFE7YUFBWTtRQUN2QztRQUNBLE9BQU87WUFBQztnQkFBQ0g7YUFBTztlQUFLQztTQUFZO0lBQ2xDO0lBQ0EsTUFBTUcsVUFBVSxDQUFDO0lBQ2pCLEtBQUssTUFBTSxDQUFDL1EsS0FBSzZRLEtBQUssSUFBSXZTLE9BQU95QyxPQUFPLENBQUMyTyxNQUFPcUIsT0FBTyxDQUFDL1EsSUFBSSxHQUFHcVEsT0FBT1EsTUFBTTtRQUFDN1E7S0FBSTtJQUNqRixNQUFNK1E7SUFDTixJQUFJcEYsV0FBV2tFO0lBQ2YsSUFBSXBOLEtBQUt1TyxNQUFNLEVBQUVyRixXQUFXOEMsU0FBU29CLGlCQUFpQnBOLEtBQUt1TyxNQUFNO0lBQ2pFLFdBQVcsTUFBTXRRLFNBQVNpTCxTQUFVLE1BQU1qTDtBQUMzQztBQUNBOzs7QUFHQSxHQUNBLFNBQVN1USxvQkFBb0J4TyxJQUFJO0lBQ2hDLElBQUl5TyxTQUFTakQsbUJBQW1Cd0IsMEJBQTBCaE47SUFDMUQsTUFBTSxFQUFFME8sU0FBUyxFQUFFLEdBQUcxTztJQUN0QixJQUFJME8sV0FBV0QsU0FBU0EsT0FBT0UsV0FBVyxDQUFDLElBQUlDLGdCQUFnQjtRQUFFQyxXQUFVQyxLQUFLLEVBQUVuRCxVQUFVO1lBQzNGLElBQUltRCxVQUFVL0MsVUFBVUosV0FBV0UsT0FBTyxDQUFDRTtpQkFDdENKLFdBQVdFLE9BQU8sQ0FBQzZDLFVBQVVJO1FBQ25DO0lBQUU7SUFDRixPQUFPTCxPQUFPRSxXQUFXLENBQUMsSUFBSUMsZ0JBQWdCO1FBQUVDLFdBQVVDLEtBQUssRUFBRW5ELFVBQVU7WUFDMUUsSUFBSW1ELFVBQVUvQyxVQUFVSixXQUFXRSxPQUFPLENBQUM7aUJBQ3RDRixXQUFXRSxPQUFPLENBQUM3TSxLQUFLK1AsU0FBUyxDQUFDRCxTQUFTO1FBQ2pEO0lBQUUsSUFBSUgsV0FBVyxDQUFDLElBQUlLO0FBQ3ZCO0FBQ0EsSUFBSUMsYUFBYSxjQUFjN1E7SUFDOUJ3RixZQUFZcUosSUFBSSxDQUFFO1FBQ2pCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtJQUNiO0FBQ0Q7QUFDQSxNQUFNaUMsNEJBQTRCLENBQUNDO0lBQ2xDLE9BQU87UUFBRUM7WUFDUixNQUFNWCxTQUFTLElBQUloRCxlQUFlO2dCQUFFckUsT0FBTXVFLFVBQVU7b0JBQ25Ed0QsT0FBT0UsRUFBRSxDQUFDLFFBQVEsQ0FBQ1A7d0JBQ2xCbkQsV0FBV0UsT0FBTyxDQUFDaUQ7b0JBQ3BCO29CQUNBSyxPQUFPRSxFQUFFLENBQUMsT0FBTzt3QkFDaEIxRCxXQUFXQyxLQUFLO29CQUNqQjtvQkFDQXVELE9BQU9FLEVBQUUsQ0FBQyxTQUFTLENBQUNqTTt3QkFDbkJ1SSxXQUFXdkksS0FBSyxDQUFDQTtvQkFDbEI7Z0JBQ0Q7WUFBRTtZQUNGLE9BQU9xTCxPQUFPVyxTQUFTO1FBQ3hCO0lBQUU7QUFDSDtBQUNBLFNBQVNFLHNCQUFzQnRTLElBQUk7SUFDbEMsTUFBTXVTLFNBQVMsZUFBZXZTLE9BQU9BLEtBQUtvUyxTQUFTLEtBQUtGLDBCQUEwQmxTLE1BQU1vUyxTQUFTO0lBQ2pHLElBQUlJLGdCQUFnQjtJQUNwQixPQUFPLElBQUkvRCxlQUFlO1FBQ3pCLE1BQU1oQixNQUFLa0IsVUFBVTtZQUNwQixNQUFNLEVBQUVoQyxJQUFJLEVBQUUxTCxLQUFLLEVBQUUsR0FBRyxNQUFNc1IsT0FBTy9QLElBQUk7WUFDekMsSUFBSW1LLE1BQU1nQyxXQUFXQyxLQUFLO2lCQUNyQkQsV0FBV0UsT0FBTyxDQUFDNU47UUFDekI7UUFDQXlOO1lBQ0MsT0FBTzZELE9BQU83RCxNQUFNO1FBQ3JCO0lBQ0QsR0FBR2lELFdBQVcsQ0FBQyxJQUFJYyxxQkFBcUJkLFdBQVcsQ0FBQyxJQUFJQyxnQkFBZ0I7UUFBRUMsV0FBVUMsS0FBSyxFQUFFbkQsVUFBVTtZQUNwRzZELGlCQUFpQlY7WUFDakIsTUFBTVksUUFBUUYsY0FBY25QLEtBQUssQ0FBQztZQUNsQ21QLGdCQUFnQkUsTUFBTTVHLEdBQUcsTUFBTTtZQUMvQixLQUFLLE1BQU02RyxRQUFRRCxNQUFPL0QsV0FBV0UsT0FBTyxDQUFDOEQ7UUFDOUM7SUFBRTtBQUNIO0FBQ0EsU0FBU0MscUJBQXFCNVMsSUFBSTtJQUNqQyxNQUFNeVIsU0FBU2Esc0JBQXNCdFM7SUFDckMsSUFBSTZTLFdBQVc7SUFDZixPQUFPcEIsT0FBT0UsV0FBVyxDQUFDLElBQUlDLGdCQUFnQjtRQUFFQyxXQUFVaUIsSUFBSSxFQUFFbkUsVUFBVTtZQUN6RSxJQUFJLENBQUNrRSxVQUFVO2dCQUNkLE1BQU1FLE9BQU8vUSxLQUFLQyxLQUFLLENBQUM2UTtnQkFDeEJuRSxXQUFXRSxPQUFPLENBQUNrRTtnQkFDbkJGLFdBQVc7WUFDWixPQUFPO2dCQUNOLE1BQU1mLFFBQVE5UCxLQUFLQyxLQUFLLENBQUM2UTtnQkFDekJuRSxXQUFXRSxPQUFPLENBQUNpRDtZQUNwQjtRQUNEO0lBQUU7QUFDSDtBQUNBOztBQUVBLEdBQ0EsU0FBU2tCLHFCQUFxQkMsZUFBZTtJQUM1QyxNQUFNQyxnQkFBZ0IsYUFBYSxHQUFHLElBQUlDO0lBQzFDOztDQUVBLEdBQ0EsU0FBU0M7UUFDUixPQUFPdE8sTUFBTTlFLElBQUksQ0FBQ2tULGNBQWNuTyxNQUFNLElBQUlzTyxLQUFLLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsTUFBTTtJQUNoRTtJQUNBOztDQUVBLEdBQ0EsU0FBU0M7UUFDUixJQUFJQztRQUNKLE1BQU1oQyxTQUFTLElBQUloRCxlQUFlO1lBQUVyRSxPQUFNdUUsVUFBVTtnQkFDbkQ4RSxxQkFBcUI5RTtZQUN0QjtRQUFFO1FBQ0YsTUFBTStFLG1CQUFtQjtZQUN4QjdFLFNBQVMsQ0FBQ3BELElBQU1nSSxtQkFBbUI1RSxPQUFPLENBQUNwRDtZQUMzQ21ELE9BQU87Z0JBQ042RSxtQkFBbUI3RSxLQUFLO2dCQUN4QlA7Z0JBQ0EsSUFBSStFLFdBQVdILGdCQUFnQlUsS0FBSztZQUNyQztZQUNBSixRQUFRO1lBQ1JLLG1CQUFtQjtnQkFDbEIsTUFBTXJCLFNBQVNkLE9BQU9XLFNBQVM7Z0JBQy9CLE9BQU96SSxhQUFhNEksUUFBUTtvQkFDM0JBLE9BQU9zQixXQUFXO29CQUNsQkgsaUJBQWlCOUUsS0FBSztnQkFDdkI7WUFDRDtZQUNBeEksT0FBTyxDQUFDaUI7Z0JBQ1BvTSxtQkFBbUJyTixLQUFLLENBQUNpQjtnQkFDekJnSDtZQUNEO1FBQ0Q7UUFDQSxTQUFTQTtZQUNSeFAsT0FBT2dKLE1BQU0sQ0FBQzZMLGtCQUFrQjtnQkFDL0JILFFBQVE7Z0JBQ1IzRSxPQUFPLEtBQU87Z0JBQ2RDLFNBQVMsS0FBTztnQkFDaEIrRSxtQkFBbUI7Z0JBQ25CeE4sT0FBTyxLQUFPO1lBQ2Y7UUFDRDtRQUNBLE9BQU9zTjtJQUNSO0lBQ0E7O0NBRUEsR0FDQSxTQUFTSSxZQUFZQyxPQUFPO1FBQzNCLElBQUlULElBQUlKLGNBQWN6UyxHQUFHLENBQUNzVDtRQUMxQixJQUFJLENBQUNULEdBQUc7WUFDUEEsSUFBSUU7WUFDSk4sY0FBYzFLLEdBQUcsQ0FBQ3VMLFNBQVNUO1FBQzVCO1FBQ0EsT0FBT0E7SUFDUjtJQUNBOztDQUVBLEdBQ0EsU0FBU1UsVUFBVTNNLE1BQU07UUFDeEIsS0FBSyxNQUFNc0gsY0FBY3VFLGNBQWNuTyxNQUFNLEdBQUk0SixXQUFXdkksS0FBSyxDQUFDaUI7SUFDbkU7SUFDQSxPQUFPO1FBQ055TTtRQUNBVjtRQUNBWTtJQUNEO0FBQ0Q7QUFDQTs7O0FBR0EsR0FDQSxlQUFlQyxvQkFBb0JqUixJQUFJO0lBQ3RDLE1BQU0sRUFBRWdCLGNBQWMsQ0FBQ3lILElBQU1BLENBQUMsRUFBRSxHQUFHekk7SUFDbkMsSUFBSW1QLFNBQVNTLHFCQUFxQjVQLEtBQUtoRCxJQUFJO0lBQzNDLElBQUlnRSxhQUFhbU8sU0FBU0EsT0FBT1IsV0FBVyxDQUFDLElBQUlDLGdCQUFnQjtRQUFFQyxXQUFVQyxLQUFLLEVBQUVuRCxVQUFVO1lBQzdGQSxXQUFXRSxPQUFPLENBQUM3SyxZQUFZOE47UUFDaEM7SUFBRTtJQUNGLElBQUlvQyxlQUFlakg7SUFDbkIsTUFBTWtILGdCQUFnQm5CLHFCQUFxQmhRLEtBQUtpUSxlQUFlO0lBQy9ELFNBQVNtQixzQkFBc0JuVCxLQUFLO1FBQ25DLE1BQU0sQ0FBQ29ULE9BQU83UCxNQUFNdVAsUUFBUSxHQUFHOVM7UUFDL0IsTUFBTTBOLGFBQWF3RixjQUFjTCxXQUFXLENBQUNDO1FBQzdDLE9BQVF2UDtZQUNQLEtBQUsrSztnQkFBMEIsT0FBTzlRLHdEQUFHQSxDQUFDO29CQUN6QyxJQUFJO3dCQUNILElBQUlxTyxhQUFhLENBQUMsR0FBR3NDLGtCQUFrQjVDLE9BQU87d0JBQzlDLE1BQU0rRixTQUFTekYsV0FBV2xCLENBQUMsQ0FBQytDLFdBQVdpRixpQkFBaUI7d0JBQ3hELE1BQU0sRUFBRTNTLE9BQU9xVCxPQUFPLEVBQUUsR0FBRyxNQUFNL0IsT0FBTy9QLElBQUk7d0JBQzVDLE1BQU0sQ0FBQytSLFVBQVVyTixRQUFRK0ksS0FBSyxHQUFHcUU7d0JBQ2pDLE9BQVFwTjs0QkFDUCxLQUFLdUk7Z0NBQTBCLE9BQU8rRSxPQUFPdkU7NEJBQzdDLEtBQUtQO2dDQUF5QixNQUFNMU0sS0FBSzZOLFdBQVcsR0FBRztvQ0FBRXpLLE9BQU82SjtnQ0FBSyxNQUFNLElBQUlnQyxXQUFXaEM7d0JBQzNGO29CQUNELEVBQUUsT0FBT3JELEdBQUc7d0JBQ1hFLFdBQVc3QixDQUFDLEdBQUcyQjtvQkFDaEIsU0FBVTt3QkFDVEUsV0FBV3BCLENBQUM7b0JBQ2I7Z0JBQ0Q7WUFDQSxLQUFLOEQ7Z0JBQWlDLE9BQU8vUSx3REFBR0EsQ0FBQztvQkFDaEQsSUFBSTt3QkFDSCxJQUFJZ1csYUFBYSxDQUFDLEdBQUdyRixrQkFBa0I1QyxPQUFPO3dCQUM5QyxNQUFNK0YsU0FBU2tDLFdBQVc3SSxDQUFDLENBQUMrQyxXQUFXaUYsaUJBQWlCO3dCQUN4RCxNQUFPLEtBQU07NEJBQ1osTUFBTSxFQUFFM1MsT0FBT3FULE9BQU8sRUFBRSxHQUFHLE1BQU0vQixPQUFPL1AsSUFBSTs0QkFDNUMsTUFBTSxDQUFDK1IsVUFBVXJOLFFBQVErSSxLQUFLLEdBQUdxRTs0QkFDakMsT0FBUXBOO2dDQUNQLEtBQUswSTtvQ0FDSixNQUFNNEUsT0FBT3ZFO29DQUNiO2dDQUNELEtBQUtOO29DQUE4QixPQUFPNkUsT0FBT3ZFO2dDQUNqRCxLQUFLSjtvQ0FBNkIsTUFBTTdNLEtBQUs2TixXQUFXLEdBQUc7d0NBQUV6SyxPQUFPNko7b0NBQUssTUFBTSxJQUFJZ0MsV0FBV2hDOzRCQUMvRjt3QkFDRDtvQkFDRCxFQUFFLE9BQU9yRCxHQUFHO3dCQUNYNkgsV0FBV3hKLENBQUMsR0FBRzJCO29CQUNoQixTQUFVO3dCQUNUNkgsV0FBVy9JLENBQUM7b0JBQ2I7Z0JBQ0Q7UUFDRDtJQUNEO0lBQ0EsU0FBUzhJLE9BQU92VCxLQUFLO1FBQ3BCLE1BQU0sQ0FBQyxDQUFDZ1AsS0FBSyxFQUFFLEdBQUd5RSxXQUFXLEdBQUd6VDtRQUNoQyxLQUFLLE1BQU1xVCxXQUFXSSxXQUFZO1lBQ2pDLE1BQU0sQ0FBQ25VLElBQUksR0FBRytUO1lBQ2QsTUFBTUssVUFBVVAsc0JBQXNCRTtZQUN0QyxJQUFJL1QsUUFBUSxNQUFNLE9BQU9vVTtZQUN6QjFFLElBQUksQ0FBQzFQLElBQUksR0FBR29VO1FBQ2I7UUFDQSxPQUFPMUU7SUFDUjtJQUNBLE1BQU0yRSxlQUFlLENBQUN2TjtRQUNyQjZNLGNBQWM1TSxPQUFPRDtRQUNyQjhNLGNBQWNILFNBQVMsQ0FBQzNNO0lBQ3pCO0lBQ0E4SyxPQUFPMEMsTUFBTSxDQUFDLElBQUlDLGVBQWU7UUFDaENDLE9BQU1DLFdBQVc7WUFDaEIsSUFBSWQsY0FBYztnQkFDakIsTUFBTW5CLE9BQU9pQztnQkFDYixLQUFLLE1BQU0sQ0FBQ3pVLEtBQUtVLE1BQU0sSUFBSXBDLE9BQU95QyxPQUFPLENBQUMwVCxhQUFjO29CQUN2RCxNQUFNN1QsU0FBU3FULE9BQU92VDtvQkFDdEI4UixJQUFJLENBQUN4UyxJQUFJLEdBQUdZO2dCQUNiO2dCQUNBK1MsYUFBYTlNLE9BQU8sQ0FBQzJMO2dCQUNyQm1CLGVBQWU7Z0JBQ2Y7WUFDRDtZQUNBLE1BQU1wQyxRQUFRa0Q7WUFDZCxNQUFNLENBQUN6RSxJQUFJLEdBQUd1QjtZQUNkLE1BQU1uRCxhQUFhd0YsY0FBY0wsV0FBVyxDQUFDdkQ7WUFDN0M1QixXQUFXRSxPQUFPLENBQUNpRDtRQUNwQjtRQUNBbEQsT0FBTyxJQUFNZ0csYUFBYSxJQUFJeFQsTUFBTTtRQUNwQ3VTLE9BQU9pQjtJQUNSLElBQUk7UUFBRXZQLFFBQVFyQyxLQUFLaVEsZUFBZSxDQUFDNU4sTUFBTTtJQUFDLEdBQUc1QyxLQUFLLENBQUMsQ0FBQzJEO1FBQ25EcEQsS0FBSzJOLE9BQU8sR0FBRztZQUFFdks7UUFBTTtRQUN2QndPLGFBQWF4TztJQUNkO0lBQ0EsT0FBTztRQUFDLE1BQU04TixhQUFhOVIsT0FBTztRQUFFK1I7S0FBYztBQUNuRDtBQUVBLFlBQVk7QUFDWix1REFBdUQ7QUFDdkQsSUFBSWMsa0JBQWtCcFUsUUFBUTBKLG9CQUFvQjtBQUNsRCxNQUFNMkssYUFBYTtBQUNuQixNQUFNQyx5QkFBeUI7QUFDL0IsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLGVBQWU7QUFDckI7OztBQUdBLEdBQ0EsU0FBU0Msa0JBQWtCdFMsSUFBSTtJQUM5QixNQUFNLEVBQUUwTyxZQUFZclQseURBQVEsRUFBRSxHQUFHMkU7SUFDakMsTUFBTXVTLE9BQU87UUFDWkMsU0FBU3hTLEtBQUt1UyxJQUFJLEVBQUVDLFdBQVc7UUFDL0JDLFlBQVl6UyxLQUFLdVMsSUFBSSxFQUFFRSxjQUFjO0lBQ3RDO0lBQ0EsTUFBTUMsU0FBUzFTLEtBQUswUyxNQUFNLElBQUksQ0FBQztJQUMvQixJQUFJSCxLQUFLQyxPQUFPLElBQUlFLE9BQU9DLDBCQUEwQixJQUFJSixLQUFLRSxVQUFVLEdBQUdDLE9BQU9DLDBCQUEwQixFQUFFLE1BQU0sSUFBSXZVLE1BQU0sQ0FBQyxpSEFBaUgsRUFBRW1VLEtBQUtFLFVBQVUsQ0FBQyxvQ0FBb0MsRUFBRUMsT0FBT0MsMEJBQTBCLENBQUMsQ0FBQztJQUMzVSxnQkFBZ0JDO1FBQ2YsTUFBTTtZQUNMQyxPQUFPVDtZQUNQbkYsTUFBTWpPLEtBQUsrUCxTQUFTLENBQUMyRDtRQUN0QjtRQUNBLElBQUl4SixXQUFXbEosS0FBS2lOLElBQUk7UUFDeEIsSUFBSWpOLEtBQUs4UyxxQkFBcUIsRUFBRTVKLFdBQVdXLGNBQWNYLFVBQVU7WUFDbEVjLE9BQU87WUFDUEQsZUFBZTtRQUNoQjtRQUNBLElBQUkvSixLQUFLeUosYUFBYSxJQUFJekosS0FBS3lKLGFBQWEsR0FBRyxLQUFLekosS0FBS3lKLGFBQWEsS0FBS3NKLFVBQVU3SixXQUFXSSxnQkFBZ0JKLFVBQVU7WUFBRU8sZUFBZXpKLEtBQUt5SixhQUFhO1FBQUM7UUFDOUosSUFBSThJLEtBQUtDLE9BQU8sSUFBSUQsS0FBS0UsVUFBVSxLQUFLTSxZQUFZUixLQUFLRSxVQUFVLEdBQUcsR0FBR3ZKLFdBQVc4QyxTQUFTOUMsVUFBVXFKLEtBQUtFLFVBQVU7UUFDdEgsSUFBSXhVO1FBQ0osSUFBSTZRO1FBQ0osV0FBVzdRLFNBQVNpTCxTQUFVO1lBQzdCLElBQUlqTCxVQUFVOE4sVUFBVTtnQkFDdkIsTUFBTTtvQkFDTDhHLE9BQU9YO29CQUNQakYsTUFBTTtnQkFDUDtnQkFDQTtZQUNEO1lBQ0E2QixRQUFRM1Qsd0VBQWlCQSxDQUFDOEMsU0FBUztnQkFDbEMrVSxJQUFJL1UsS0FBSyxDQUFDLEVBQUU7Z0JBQ1pnUCxNQUFNaFAsS0FBSyxDQUFDLEVBQUU7WUFDZixJQUFJO2dCQUFFZ1AsTUFBTWhQO1lBQU07WUFDbEI2USxNQUFNN0IsSUFBSSxHQUFHak8sS0FBSytQLFNBQVMsQ0FBQ0wsVUFBVUksTUFBTTdCLElBQUk7WUFDaEQsTUFBTTZCO1lBQ043USxRQUFRO1lBQ1I2USxRQUFRO1FBQ1Q7SUFDRDtJQUNBLGdCQUFnQm1FO1FBQ2YsSUFBSTtZQUNILE9BQU9MO1lBQ1AsTUFBTTtnQkFDTEMsT0FBT1I7Z0JBQ1BwRixNQUFNO1lBQ1A7UUFDRCxFQUFFLE9BQU90TyxPQUFPO1lBQ2YsSUFBSXdFLGFBQWF4RSxRQUFRO1lBQ3pCLE1BQU15RSxRQUFRbEksOEVBQXVCQSxDQUFDeUQ7WUFDdEMsTUFBTXNPLE9BQU9qTixLQUFLNk4sV0FBVyxHQUFHO2dCQUFFeks7WUFBTSxNQUFNO1lBQzlDLE1BQU07Z0JBQ0x5UCxPQUFPVjtnQkFDUGxGLE1BQU1qTyxLQUFLK1AsU0FBUyxDQUFDTCxVQUFVekI7WUFDaEM7UUFDRDtJQUNEO0lBQ0EsTUFBTXdCLFNBQVNqRCxtQkFBbUJ5SDtJQUNsQyxPQUFPeEUsT0FBT0UsV0FBVyxDQUFDLElBQUlDLGdCQUFnQjtRQUFFQyxXQUFVQyxLQUFLLEVBQUVuRCxVQUFVO1lBQzFFLElBQUksV0FBV21ELE9BQU9uRCxXQUFXRSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUVpRCxNQUFNK0QsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNsRSxJQUFJLFVBQVUvRCxPQUFPbkQsV0FBV0UsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFaUQsTUFBTTdCLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDL0QsSUFBSSxRQUFRNkIsT0FBT25ELFdBQVdFLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRWlELE1BQU1rRSxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3pELElBQUksYUFBYWxFLE9BQU9uRCxXQUFXRSxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUVpRCxNQUFNb0UsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNqRXZILFdBQVdFLE9BQU8sQ0FBQztRQUNwQjtJQUFFLElBQUk4QyxXQUFXLENBQUMsSUFBSUs7QUFDdkI7QUFDQSxlQUFlbUUsWUFBWW5ULElBQUk7SUFDOUIsSUFBSTtRQUNILElBQUl1SixjQUFjLENBQUMsR0FBRzBJLGdCQUFnQnpJLE9BQU87UUFDN0MsTUFBTTRKLGlCQUFpQjdKLFlBQVlYLENBQUMsQ0FBQzNCLGNBQWNqSCxLQUFLcVQsU0FBUztRQUNqRSxNQUFNbkosTUFBTSxNQUFNeEcsVUFBVW1DLElBQUksQ0FBQztZQUFDN0YsS0FBS1osT0FBTztZQUFFZ1UsZUFBZWhNLEtBQUs7U0FBRztRQUN2RSxJQUFJOEMsUUFBUWxELDhCQUE4QixPQUFPLE1BQU1oSCxLQUFLc1QsU0FBUztRQUNyRSxPQUFPcEo7SUFDUixFQUFFLE9BQU9OLEdBQUc7UUFDWEwsWUFBWXRCLENBQUMsR0FBRzJCO0lBQ2pCLFNBQVU7UUFDVEwsWUFBWWIsQ0FBQztJQUNkO0FBQ0Q7QUFDQTs7QUFFQSxHQUNBLFNBQVM2SyxrQkFBa0J2VCxJQUFJO0lBQzlCLE1BQU0sRUFBRWdCLGNBQWMsQ0FBQ3lILElBQU1BLENBQUMsRUFBRSxHQUFHekk7SUFDbkMsSUFBSXdULGdCQUFnQixDQUFDO0lBQ3JCLE1BQU1uUixTQUFTckMsS0FBS3FDLE1BQU07SUFDMUIsSUFBSW9SLE1BQU07SUFDVixNQUFNQyxlQUFlLElBQU0sSUFBSWpJLGVBQWU7WUFDN0MsTUFBTXJFLE9BQU11RSxVQUFVO2dCQUNyQixNQUFNLENBQUNySixLQUFLcVIsS0FBSyxHQUFHLE1BQU12UyxRQUFRQyxHQUFHLENBQUM7b0JBQUNyQixLQUFLc0MsR0FBRztvQkFBSXRDLEtBQUsyVCxJQUFJO2lCQUFHO2dCQUMvRCxNQUFNQyxjQUFjSCxNQUFNLElBQUl6VCxLQUFLNlQsV0FBVyxDQUFDdlIsS0FBS3FSO2dCQUNwRGhJLFdBQVdFLE9BQU8sQ0FBQztvQkFDbEJySyxNQUFNO29CQUNOb1MsYUFBYUg7b0JBQ2JaLE9BQU87Z0JBQ1I7Z0JBQ0FlLFlBQVlFLGdCQUFnQixDQUFDMUIsaUJBQWlCLENBQUMyQjtvQkFDOUMsTUFBTUMsTUFBTUQ7b0JBQ1osTUFBTUUsVUFBVWpWLEtBQUtDLEtBQUssQ0FBQytVLElBQUkvRyxJQUFJO29CQUNuQ3VHLGdCQUFnQlM7b0JBQ2hCdEksV0FBV0UsT0FBTyxDQUFDO3dCQUNsQnJLLE1BQU07d0JBQ055Uzt3QkFDQUw7b0JBQ0Q7Z0JBQ0Q7Z0JBQ0FBLFlBQVlFLGdCQUFnQixDQUFDM0Isd0JBQXdCLENBQUM0QjtvQkFDckQsTUFBTUMsTUFBTUQ7b0JBQ1pwSSxXQUFXRSxPQUFPLENBQUM7d0JBQ2xCckssTUFBTTt3QkFDTjRCLE9BQU9wQyxZQUFZaEMsS0FBS0MsS0FBSyxDQUFDK1UsSUFBSS9HLElBQUk7d0JBQ3RDMkc7b0JBQ0Q7Z0JBQ0Q7Z0JBQ0FBLFlBQVlFLGdCQUFnQixDQUFDNUIsWUFBWTtvQkFDeEN2RyxXQUFXRSxPQUFPLENBQUM7d0JBQ2xCckssTUFBTTt3QkFDTm9TO29CQUNEO2dCQUNEO2dCQUNBQSxZQUFZRSxnQkFBZ0IsQ0FBQ3pCLGNBQWM7b0JBQzFDdUIsWUFBWWhJLEtBQUs7b0JBQ2pCRCxXQUFXQyxLQUFLO29CQUNoQjZILE1BQU07Z0JBQ1A7Z0JBQ0FHLFlBQVlFLGdCQUFnQixDQUFDLFNBQVMsQ0FBQ2pCO29CQUN0QyxJQUFJZSxZQUFZTSxVQUFVLEtBQUtOLFlBQVlPLE1BQU0sRUFBRXhJLFdBQVd2SSxLQUFLLENBQUN5UDt5QkFDL0RsSCxXQUFXRSxPQUFPLENBQUM7d0JBQ3ZCckssTUFBTTt3QkFDTm9TO3dCQUNBZjtvQkFDRDtnQkFDRDtnQkFDQWUsWUFBWUUsZ0JBQWdCLENBQUMsV0FBVyxDQUFDQztvQkFDeEMsTUFBTUMsTUFBTUQ7b0JBQ1osTUFBTWpGLFFBQVE5TixZQUFZaEMsS0FBS0MsS0FBSyxDQUFDK1UsSUFBSS9HLElBQUk7b0JBQzdDLE1BQU1tSCxNQUFNO3dCQUFFbkgsTUFBTTZCO29CQUFNO29CQUMxQixJQUFJa0YsSUFBSXZTLFdBQVcsRUFBRTJTLElBQUlwQixFQUFFLEdBQUdnQixJQUFJdlMsV0FBVztvQkFDN0NrSyxXQUFXRSxPQUFPLENBQUM7d0JBQ2xCckssTUFBTTt3QkFDTnlMLE1BQU1tSDt3QkFDTlI7b0JBQ0Q7Z0JBQ0Q7Z0JBQ0EsTUFBTVMsVUFBVTtvQkFDZixJQUFJO3dCQUNIVCxZQUFZaEksS0FBSzt3QkFDakJELFdBQVdDLEtBQUs7b0JBQ2pCLEVBQUUsT0FBTSxDQUFDO2dCQUNWO2dCQUNBLElBQUl2SixPQUFPaVMsT0FBTyxFQUFFRDtxQkFDZmhTLE9BQU95UixnQkFBZ0IsQ0FBQyxTQUFTTztZQUN2QztZQUNBM0k7Z0JBQ0MrSCxLQUFLN0g7WUFDTjtRQUNEO0lBQ0EsTUFBTTJJLG9CQUFvQjtRQUN6QixJQUFJOUYsU0FBU2lGO1FBQ2IsSUFBSW5FLFNBQVNkLE9BQU9XLFNBQVM7UUFDN0IsZUFBZTNJO1lBQ2QsTUFBTThJLE9BQU83RCxNQUFNO1lBQ25CK0gsTUFBTTtRQUNQO1FBQ0EsT0FBTzFNLGtCQUFrQjtZQUN4QnZIO2dCQUNDLE9BQU8rUCxPQUFPL1AsSUFBSTtZQUNuQjtZQUNBLE1BQU1nVjtnQkFDTCxNQUFNL047Z0JBQ05nSSxTQUFTaUY7Z0JBQ1RuRSxTQUFTZCxPQUFPVyxTQUFTO1lBQzFCO1FBQ0QsR0FBRzNJO0lBQ0o7SUFDQSxPQUFPaEwsd0RBQUdBLENBQUM7UUFDVixJQUFJO1lBQ0gsSUFBSXFPLGFBQWEsQ0FBQyxHQUFHbUksZ0JBQWdCekksT0FBTztZQUM1QyxNQUFNaUYsU0FBUzNFLFdBQVduQixDQUFDLENBQUM0TDtZQUM1QixNQUFPLEtBQU07Z0JBQ1osSUFBSW5WLFVBQVVxUCxPQUFPalAsSUFBSTtnQkFDekIsTUFBTTZULFlBQVlHLGNBQWNiLDBCQUEwQjtnQkFDMUQsSUFBSVUsV0FBV2pVLFVBQVUrVCxZQUFZO29CQUNwQy9UO29CQUNBaVU7b0JBQ0FDLFdBQVc7d0JBQ1YsTUFBTXBKLE1BQU07NEJBQ1hqTSxPQUFPO2dDQUNOdUQsTUFBTTtnQ0FDTjBGLElBQUltTTtnQ0FDSk8sYUFBYUg7NEJBQ2Q7NEJBQ0E5SixNQUFNO3dCQUNQO3dCQUNBLE1BQU04RSxPQUFPK0YsUUFBUTt3QkFDckIsT0FBT3RLO29CQUNSO2dCQUNEO2dCQUNBLE1BQU14SyxTQUFTLE1BQU1OO2dCQUNyQixJQUFJTSxPQUFPaUssSUFBSSxFQUFFLE9BQU9qSyxPQUFPekIsS0FBSztnQkFDcEMsTUFBTXlCLE9BQU96QixLQUFLO1lBQ25CO1FBQ0QsRUFBRSxPQUFPMkwsR0FBRztZQUNYRSxXQUFXN0IsQ0FBQyxHQUFHMkI7UUFDaEIsU0FBVTtZQUNULE1BQU1FLFdBQVdwQixDQUFDO1FBQ25CO0lBQ0Q7QUFDRDtBQUNBLE1BQU0rTCxhQUFhO0lBQ2xCLGdCQUFnQjtJQUNoQixpQkFBaUI7SUFDakIscUJBQXFCO0lBQ3JCQyxZQUFZO0FBQ2I7QUFFQSxZQUFZO0FBQ1osaUVBQWlFO0FBQ2pFLFNBQVNDLHFCQUFxQjVMLEdBQUc7SUFDaEMsT0FBT3ROLHdEQUFHQSxDQUFDO1FBQ1YsTUFBTXNOO0lBQ1A7QUFDRDtBQUNBLE1BQU02TCwyQkFBMkI7SUFDaENDLFVBQVU7UUFBQztLQUFPO0lBQ2xCQyxPQUFPO1FBQUM7S0FBTTtJQUNkQyxjQUFjO1FBQUM7S0FBTTtBQUN0QjtBQUNBLE1BQU1DLGdEQUFnRDtJQUNyREgsVUFBVTtRQUFDO0tBQU87SUFDbEJDLE9BQU87UUFBQztRQUFPO0tBQU87SUFDdEJDLGNBQWM7UUFBQztRQUFPO0tBQU87QUFDOUI7QUFDQSxTQUFTRSxhQUFhQyxRQUFRO0lBQzdCLE1BQU0sRUFBRUMsR0FBRyxFQUFFalQsSUFBSSxFQUFFa1QsWUFBWSxFQUFFQyxpQkFBaUIsRUFBRWpLLFNBQVMsRUFBRSxFQUFFdEwsT0FBTyxFQUFFLEdBQUdvVjtJQUM3RSxJQUFJaFIsU0FBU21SLG9CQUFvQnRhLDhFQUFpQkEsQ0FBQ3NhLHFCQUFxQjtJQUN4RSxNQUFNQyxrQkFBa0IsQ0FBQ0Q7SUFDekIsTUFBTXBJLE9BQU9xSSxrQkFBa0IsRUFBRSxHQUFHeFQsTUFBTTZELE9BQU8sQ0FBQzBQLHFCQUFxQkEsb0JBQW9CO1FBQUNBO0tBQWtCO0lBQzlHLE1BQU1FLE9BQU9ILGVBQWU7UUFDM0JEO1FBQ0FqVDtRQUNBL0IsT0FBTytCLE1BQU1mLE1BQU0xQyxJQUFJLENBQUNqQixPQUFTQSxLQUFLNEMsSUFBSTtRQUMxQzZNO1FBQ0E3QjtRQUNBa0s7UUFDQTlULE1BQU1VLE1BQU1mLE1BQU00QixLQUFLLENBQUN2RixPQUFTQSxLQUFLOEQsU0FBUyxFQUFFVixLQUFLWSxPQUFPRixXQUFXVixLQUFLWSxRQUFRO0lBQ3RGLE1BQU0sQ0FBQztJQUNQLElBQUkrVCxLQUFLelYsT0FBTyxFQUFFO1FBQ2pCLElBQUl5VixLQUFLelYsT0FBTyxZQUFZMFYsU0FBUyxLQUFLLE1BQU0sQ0FBQ2pZLEtBQUtVLE1BQU0sSUFBSXNYLEtBQUt6VixPQUFPLENBQUN4QixPQUFPLEdBQUl3QixRQUFRMlYsTUFBTSxDQUFDbFksS0FBS1U7YUFFN0c7O0VBRUMsR0FDQSxLQUFLLE1BQU0sQ0FBQ1YsS0FBS1UsTUFBTSxJQUFJcEMsT0FBT3lDLE9BQU8sQ0FBQ2lYLEtBQUt6VixPQUFPLEVBQUcsSUFBSWdDLE1BQU02RCxPQUFPLENBQUMxSCxRQUFRLEtBQUssTUFBTXdLLEtBQUt4SyxNQUFPNkIsUUFBUTJWLE1BQU0sQ0FBQ2xZLEtBQUtrTDthQUN6SCxJQUFJLE9BQU94SyxVQUFVLFVBQVU2QixRQUFRMEYsR0FBRyxDQUFDakksS0FBS1U7SUFDdEQ7SUFDQSxJQUFJc1gsS0FBS3JSLE1BQU0sRUFBRUEsU0FBU3FSLEtBQUtyUixNQUFNO0lBQ3JDLE9BQU87UUFBRUE7SUFBTztBQUNqQjtBQUNBLFNBQVN3UixrQkFBa0IvVyxLQUFLLEVBQUVnWCxTQUFTO0lBQzFDLE1BQU0sRUFBRWhWLE1BQU0sRUFBRWQsR0FBRyxFQUFFOE4sT0FBTyxFQUFFLEdBQUdnSSxVQUFVM1YsSUFBSTtJQUMvQyxNQUFNb0QsUUFBUWxJLDhFQUF1QkEsQ0FBQ3lEO0lBQ3RDZ1AsVUFBVTtRQUNUdks7UUFDQWhELE1BQU11VixVQUFVdlYsSUFBSTtRQUNwQlcsT0FBTzRVLFVBQVU1VSxLQUFLO1FBQ3RCb1UsS0FBS1EsVUFBVVIsR0FBRztRQUNsQjNULE1BQU1tVSxVQUFVblUsSUFBSTtRQUNwQjNCO0lBQ0Q7SUFDQSxNQUFNd1Ysb0JBQW9CO1FBQUVqUyxPQUFPdEksMEVBQWFBLENBQUM7WUFDaEQ4YSxRQUFRalYsT0FBT0MsSUFBSSxDQUFDQyxPQUFPO1lBQzNCdUM7WUFDQTVCLE1BQU1tVSxVQUFVblUsSUFBSTtZQUNwQnBCLE1BQU11VixVQUFVdlYsSUFBSTtZQUNwQlcsT0FBTzRVLFVBQVU1VSxLQUFLO1lBQ3RCb1UsS0FBS1EsVUFBVVIsR0FBRztRQUNuQjtJQUFHO0lBQ0gsTUFBTVUsa0JBQWtCemEsNEVBQXFCQSxDQUFDdUYsT0FBT0MsSUFBSSxDQUFDQyxPQUFPLEVBQUV3VTtJQUNuRSxNQUFNMVMsT0FBTzNELEtBQUsrUCxTQUFTLENBQUM4RztJQUM1QixPQUFPO1FBQ056UztRQUNBaVM7UUFDQTFTO0lBQ0Q7QUFDRDtBQUNBOzs7O0FBSUEsR0FDQSxTQUFTbVQsYUFBYXJOLENBQUM7SUFDdEIsSUFBSSxDQUFDak4sNkRBQVFBLENBQUNpTixJQUFJLE9BQU87SUFDekIsSUFBSW5OLG9FQUFlQSxDQUFDbU4sSUFBSSxPQUFPO0lBQy9CLE9BQU81TSxPQUFPa0csTUFBTSxDQUFDMEcsR0FBR3NOLElBQUksQ0FBQ2pKLGNBQWNqUixPQUFPa0csTUFBTSxDQUFDMEcsR0FBR3NOLElBQUksQ0FBQ3phLGdFQUFlQTtBQUNqRjtBQUNBLGVBQWUwYSxnQkFBZ0JoVyxJQUFJO0lBQ2xDLE1BQU0sRUFBRVcsTUFBTSxFQUFFZCxHQUFHLEVBQUUsR0FBR0c7SUFDeEIsTUFBTUYsVUFBVSxJQUFJMFYsUUFBUTtRQUFDO1lBQUM7WUFBUTtTQUFjO0tBQUM7SUFDckQsTUFBTUksU0FBU2pWLE9BQU9DLElBQUksQ0FBQ0MsT0FBTztJQUNsQyxNQUFNeUIsTUFBTSxJQUFJMlQsSUFBSXBXLElBQUl5QyxHQUFHO0lBQzNCLElBQUl6QyxJQUFJVyxNQUFNLEtBQUssUUFBUSxPQUFPLElBQUkwVixTQUFTLE1BQU07UUFBRWhTLFFBQVE7SUFBSTtJQUNuRSxNQUFNaVMsZ0JBQWdCblcsS0FBS21XLGFBQWEsSUFBSW5XLEtBQUtvVyxRQUFRLEVBQUU1RCxXQUFXO0lBQ3RFLE1BQU02RCxzQkFBc0IsQ0FBQ3JXLEtBQUtxVyxtQkFBbUIsSUFBSSxLQUFJLEtBQU14VyxJQUFJVyxNQUFNLEtBQUs7SUFDbEYsTUFBTThWLFlBQVksTUFBTTdhLHdEQUFHQSxDQUFDO1FBQzNCLElBQUk7WUFDSCxPQUFPO2dCQUFDLEtBQUs7Z0JBQUcsTUFBTXlILGVBQWU7b0JBQ3BDckQ7b0JBQ0FPLE1BQU1tVyxtQkFBbUJ2VyxLQUFLSSxJQUFJO29CQUNsQ087b0JBQ0FULGNBQWNvQyxJQUFJcEMsWUFBWTtvQkFDOUJKLFNBQVNFLEtBQUtILEdBQUcsQ0FBQ0MsT0FBTztvQkFDekJ3QztnQkFDRDthQUFHO1FBQ0osRUFBRSxPQUFPM0QsT0FBTztZQUNmLE9BQU87Z0JBQUN6RCw4RUFBdUJBLENBQUN5RDtnQkFBUSxLQUFLO2FBQUU7UUFDaEQ7SUFDRDtJQUNBLE1BQU02WCxhQUFhL2Esd0RBQUdBLENBQUM7UUFDdEIsSUFBSWlFLFNBQVMsS0FBSztRQUNsQixPQUFPO1lBQ04rVyxrQkFBa0I7Z0JBQ2pCLElBQUksQ0FBQy9XLFFBQVEsT0FBTyxLQUFLO2dCQUN6QixPQUFPQSxNQUFNLENBQUMsRUFBRTtZQUNqQjtZQUNBekIsT0FBTztnQkFDTixNQUFNLENBQUM4SyxLQUFLb00sSUFBSSxHQUFHelY7Z0JBQ25CLElBQUlxSixLQUFLLE1BQU1BO2dCQUNmLE9BQU9vTTtZQUNSO1lBQ0FyWixRQUFRLE9BQU9vRztnQkFDZCxJQUFJeEMsUUFBUSxNQUFNLElBQUl0QixNQUFNO2dCQUM1QixJQUFJO29CQUNILE1BQU0rVyxNQUFNLE1BQU1uVixLQUFLMFcsYUFBYSxDQUFDO3dCQUFFeFU7b0JBQUs7b0JBQzVDeEMsU0FBUzt3QkFBQyxLQUFLO3dCQUFHeVY7cUJBQUk7Z0JBQ3ZCLEVBQUUsT0FBT3hXLE9BQU87b0JBQ2ZlLFNBQVM7d0JBQUN4RSw4RUFBdUJBLENBQUN5RDt3QkFBUSxLQUFLO3FCQUFFO2dCQUNsRDtZQUNEO1FBQ0Q7SUFDRDtJQUNBLE1BQU1nWSxlQUFlTixzQkFBc0JyQixnREFBZ0RKO0lBQzNGOztDQUVBLEdBQ0EsTUFBTWdDLGVBQWUvVyxJQUFJQyxPQUFPLENBQUNyQyxHQUFHLENBQUMsbUJBQW1CO0lBQ3hELE1BQU1vWixrQkFBa0JqQixPQUFPa0IsR0FBRyxFQUFFdEUsV0FBVztJQUMvQyxJQUFJO1FBQ0gsTUFBTSxDQUFDdUUsV0FBVzdVLEtBQUssR0FBR29VO1FBQzFCLElBQUlTLFdBQVcsTUFBTUE7UUFDckIsSUFBSTdVLEtBQUtqQyxXQUFXLElBQUksQ0FBQ2tXLGVBQWUsTUFBTSxJQUFJbmIsNERBQVNBLENBQUM7WUFDM0Q0RCxNQUFNO1lBQ05DLFNBQVMsQ0FBQyxxQ0FBcUMsQ0FBQztRQUNqRDtRQUNBLG1DQUFtQyxHQUNuQyxJQUFJK1gsZ0JBQWdCLENBQUMxVSxLQUFLakMsV0FBVyxFQUFFLE1BQU0sSUFBSWpGLDREQUFTQSxDQUFDO1lBQzFENkQsU0FBUyxDQUFDLDREQUE0RCxDQUFDO1lBQ3ZFRCxNQUFNO1FBQ1A7UUFDQSxNQUFNNFgsV0FBVzFhLE1BQU0sQ0FBQ29HO1FBQ3hCLE1BQU04VSxXQUFXOVUsS0FBS2YsS0FBSyxDQUFDMUMsR0FBRyxDQUFDLE9BQU9qQjtZQUN0QyxNQUFNeVosT0FBT3paLEtBQUs4RCxTQUFTO1lBQzNCLElBQUk7Z0JBQ0gsSUFBSXRCLEtBQUtvRCxLQUFLLEVBQUUsTUFBTXBELEtBQUtvRCxLQUFLO2dCQUNoQyxJQUFJLENBQUM2VCxNQUFNLE1BQU0sSUFBSWpjLDREQUFTQSxDQUFDO29CQUM5QjRELE1BQU07b0JBQ05DLFNBQVMsQ0FBQyw0QkFBNEIsRUFBRXJCLEtBQUs0QyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNyRDtnQkFDQSxJQUFJLENBQUN1VyxZQUFZLENBQUNNLEtBQUtyVyxJQUFJLENBQUNZLElBQUksQ0FBQyxDQUFDMFYsUUFBUSxDQUFDclgsSUFBSVcsTUFBTSxHQUFHLE1BQU0sSUFBSXhGLDREQUFTQSxDQUFDO29CQUMzRTRELE1BQU07b0JBQ05DLFNBQVMsQ0FBQyxZQUFZLEVBQUVnQixJQUFJVyxNQUFNLENBQUMsWUFBWSxFQUFFeVcsS0FBS3JXLElBQUksQ0FBQ1ksSUFBSSxDQUFDLG9CQUFvQixFQUFFaEUsS0FBSzRDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ25HO2dCQUNBLElBQUk2VyxLQUFLclcsSUFBSSxDQUFDWSxJQUFJLEtBQUssZ0JBQWdCO29CQUN0QyxtQ0FBbUMsR0FDbkMsSUFBSVUsS0FBS2pDLFdBQVcsRUFBRSxNQUFNLElBQUlqRiw0REFBU0EsQ0FBQzt3QkFDekM0RCxNQUFNO3dCQUNOQyxTQUFTLENBQUMsK0JBQStCLENBQUM7b0JBQzNDO2dCQUNEO2dCQUNBLE1BQU1vTyxPQUFPLE1BQU1nSyxLQUFLO29CQUN2QjdXLE1BQU01QyxLQUFLNEMsSUFBSTtvQkFDZm1CLGFBQWEvRCxLQUFLK0QsV0FBVztvQkFDN0I0VCxLQUFLcUIsV0FBV3ZZLEtBQUs7b0JBQ3JCdUQsTUFBTXlWLEtBQUtyVyxJQUFJLENBQUNZLElBQUk7b0JBQ3BCYSxRQUFRckMsS0FBS0gsR0FBRyxDQUFDd0MsTUFBTTtnQkFDeEI7Z0JBQ0EsT0FBTztvQkFBQyxLQUFLO29CQUFHO3dCQUFFNEs7b0JBQUs7aUJBQUU7WUFDMUIsRUFBRSxPQUFPdE8sT0FBTztnQkFDZixNQUFNeUUsUUFBUWxJLDhFQUF1QkEsQ0FBQ3lEO2dCQUN0QyxNQUFNb0MsUUFBUXZELEtBQUtrQyxNQUFNO2dCQUN6Qk0sS0FBSzJOLE9BQU8sR0FBRztvQkFDZHZLO29CQUNBaEQsTUFBTTVDLEtBQUs0QyxJQUFJO29CQUNmVztvQkFDQW9VLEtBQUtxQixXQUFXQyxnQkFBZ0I7b0JBQ2hDalYsTUFBTWhFLEtBQUs4RCxTQUFTLEVBQUVWLEtBQUtZLFFBQVE7b0JBQ25DM0IsS0FBS0csS0FBS0gsR0FBRztnQkFDZDtnQkFDQSxPQUFPO29CQUFDdUQ7b0JBQU8sS0FBSztpQkFBRTtZQUN2QjtRQUNEO1FBQ0EsSUFBSSxDQUFDbEIsS0FBS2pDLFdBQVcsRUFBRTtZQUN0QixNQUFNLENBQUN6QyxLQUFLLEdBQUcwRSxLQUFLZixLQUFLO1lBQ3pCLE1BQU0sQ0FBQ2lDLE9BQU8xRCxPQUFPLEdBQUcsTUFBTXNYLFFBQVEsQ0FBQyxFQUFFO1lBQ3pDLE9BQVE5VSxLQUFLVixJQUFJO2dCQUNoQixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFBUzt3QkFDYjFCLFFBQVEwRixHQUFHLENBQUMsZ0JBQWdCO3dCQUM1QixJQUFJc1EsYUFBYXBXLFFBQVF1TixPQUFPLE1BQU0sSUFBSWpTLDREQUFTQSxDQUFDOzRCQUNuRDRELE1BQU07NEJBQ05DLFNBQVM7d0JBQ1Y7d0JBQ0EsTUFBTXFMLE1BQU05RyxRQUFROzRCQUFFQSxPQUFPdEksMEVBQWFBLENBQUM7Z0NBQzFDOGE7Z0NBQ0FULEtBQUtxQixXQUFXQyxnQkFBZ0I7Z0NBQ2hDclQ7Z0NBQ0FyQyxPQUFPdkQsS0FBS2tDLE1BQU07Z0NBQ2xCVSxNQUFNNUMsS0FBSzRDLElBQUk7Z0NBQ2ZvQixNQUFNVSxLQUFLVixJQUFJOzRCQUNoQjt3QkFBRyxJQUFJOzRCQUFFOUIsUUFBUTtnQ0FBRXVOLE1BQU12TixPQUFPdU4sSUFBSTs0QkFBQzt3QkFBRTt3QkFDdkMsTUFBTWtLLGlCQUFpQmxDLGFBQWE7NEJBQ25DRSxLQUFLcUIsV0FBV0MsZ0JBQWdCOzRCQUNoQ3ZVOzRCQUNBa1QsY0FBY3BWLEtBQUtvVixZQUFZOzRCQUMvQmhLLFFBQVFoSSxRQUFRO2dDQUFDQTs2QkFBTSxHQUFHLEVBQUU7NEJBQzVCdEQ7NEJBQ0F1VixtQkFBbUI7Z0NBQUNuTDs2QkFBSTt3QkFDekI7d0JBQ0EsT0FBTyxJQUFJZ00sU0FBU2xYLEtBQUsrUCxTQUFTLENBQUMzVCw0RUFBcUJBLENBQUN3YSxRQUFRMUwsT0FBTzs0QkFDdkVoRyxRQUFRaVQsZUFBZWpULE1BQU07NEJBQzdCcEU7d0JBQ0Q7b0JBQ0Q7Z0JBQ0EsS0FBSztvQkFBZ0I7d0JBQ3BCLE1BQU1vSixXQUFXek4sd0RBQUdBLENBQUM7NEJBQ3BCLElBQUkySCxPQUFPLE9BQU91UixxQkFBcUJ2Ujs0QkFDdkMsSUFBSSxDQUFDeVQsaUJBQWlCLE9BQU9sQyxxQkFBcUIsSUFBSTNaLDREQUFTQSxDQUFDO2dDQUMvRDRELE1BQU07Z0NBQ05DLFNBQVM7NEJBQ1Y7NEJBQ0EsSUFBSSxDQUFDbkQsc0VBQVlBLENBQUNnRSxPQUFPdU4sSUFBSSxLQUFLLENBQUMzUixvRUFBZUEsQ0FBQ29FLE9BQU91TixJQUFJLEdBQUcsT0FBTzBILHFCQUFxQixJQUFJM1osNERBQVNBLENBQUM7Z0NBQzFHNkQsU0FBUyxDQUFDLGFBQWEsRUFBRXJCLEtBQUs0QyxJQUFJLENBQUMsaURBQWlELENBQUM7Z0NBQ3JGeEIsTUFBTTs0QkFDUDs0QkFDQSxNQUFNd1ksaUJBQWlCMWIsc0VBQVlBLENBQUNnRSxPQUFPdU4sSUFBSSxJQUFJdFIsbUZBQXlCQSxDQUFDK0QsT0FBT3VOLElBQUksRUFBRWpOLEtBQUtILEdBQUcsQ0FBQ3dDLE1BQU0sSUFBSTNDLE9BQU91TixJQUFJOzRCQUN4SCxPQUFPbUs7d0JBQ1I7d0JBQ0EsTUFBTTNJLFNBQVM2RCxrQkFBa0I7NEJBQ2hDLEdBQUdzRCxPQUFPa0IsR0FBRzs0QkFDYjdKLE1BQU0vRDs0QkFDTndGLFdBQVcsQ0FBQ2pHLElBQU1tTixPQUFPOVUsV0FBVyxDQUFDdVcsTUFBTSxDQUFDM0ksU0FBUyxDQUFDakc7NEJBQ3REb0YsYUFBWThILFNBQVM7Z0NBQ3BCLE1BQU0yQixVQUFVcGMsOEVBQXVCQSxDQUFDeWEsVUFBVXZTLEtBQUs7Z0NBQ3ZELE1BQU1yQyxRQUFRdkQsTUFBTWtDO2dDQUNwQixNQUFNVSxPQUFPNUMsTUFBTTRDO2dDQUNuQixNQUFNb0IsT0FBT2hFLE1BQU04RCxXQUFXVixLQUFLWSxRQUFRO2dDQUMzQ3hCLEtBQUsyTixPQUFPLEdBQUc7b0NBQ2R2SyxPQUFPa1U7b0NBQ1BsWDtvQ0FDQVc7b0NBQ0FvVSxLQUFLcUIsV0FBV0MsZ0JBQWdCO29DQUNoQzVXLEtBQUtHLEtBQUtILEdBQUc7b0NBQ2IyQjtnQ0FDRDtnQ0FDQSxNQUFNK1YsUUFBUXpjLDBFQUFhQSxDQUFDO29DQUMzQjhhO29DQUNBVCxLQUFLcUIsV0FBV0MsZ0JBQWdCO29DQUNoQ3JULE9BQU9rVTtvQ0FDUHZXO29DQUNBWDtvQ0FDQW9CO2dDQUNEO2dDQUNBLE9BQU8rVjs0QkFDUjt3QkFDRDt3QkFDQSxLQUFLLE1BQU0sQ0FBQ2hhLEtBQUtVLE1BQU0sSUFBSXBDLE9BQU95QyxPQUFPLENBQUNtVyxZQUFhM1UsUUFBUTBGLEdBQUcsQ0FBQ2pJLEtBQUtVO3dCQUN4RSxNQUFNa1osaUJBQWlCbEMsYUFBYTs0QkFDbkNFLEtBQUtxQixXQUFXQyxnQkFBZ0I7NEJBQ2hDdlU7NEJBQ0FrVCxjQUFjcFYsS0FBS29WLFlBQVk7NEJBQy9CaEssUUFBUSxFQUFFOzRCQUNWdEw7NEJBQ0F1VixtQkFBbUI7d0JBQ3BCO3dCQUNBLE9BQU8sSUFBSWEsU0FBU3pILFFBQVE7NEJBQzNCM087NEJBQ0FvRSxRQUFRaVQsZUFBZWpULE1BQU07d0JBQzlCO29CQUNEO1lBQ0Q7UUFDRDtRQUNBLElBQUloQyxLQUFLQyxNQUFNLEtBQUsscUJBQXFCO1lBQ3hDckMsUUFBUTBGLEdBQUcsQ0FBQyxnQkFBZ0I7WUFDNUIxRixRQUFRMEYsR0FBRyxDQUFDLHFCQUFxQjtZQUNqQyxNQUFNMlIsaUJBQWlCbEMsYUFBYTtnQkFDbkNFLEtBQUtxQixXQUFXQyxnQkFBZ0I7Z0JBQ2hDdlU7Z0JBQ0FrVCxjQUFjcFYsS0FBS29WLFlBQVk7Z0JBQy9CaEssUUFBUSxFQUFFO2dCQUNWdEw7Z0JBQ0F1VixtQkFBbUI7WUFDcEI7WUFDQSxNQUFNNUcsU0FBU0Qsb0JBQW9CO2dCQUNsQyxHQUFHb0gsT0FBTzRCLEtBQUs7Z0JBQ2Z6SixVQUFVZ0Y7Z0JBQ1Y5RixNQUFNK0osU0FBU3ZZLEdBQUcsQ0FBQyxPQUFPeUw7b0JBQ3pCLE1BQU0sQ0FBQzlHLE9BQU8xRCxPQUFPLEdBQUcsTUFBTXdLO29CQUM5QixNQUFNMU0sT0FBTzBFLEtBQUtmLEtBQUssQ0FBQyxFQUFFO29CQUMxQixJQUFJaUMsT0FBTyxPQUFPO3dCQUFFQSxPQUFPdEksMEVBQWFBLENBQUM7NEJBQ3hDOGE7NEJBQ0FULEtBQUtxQixXQUFXQyxnQkFBZ0I7NEJBQ2hDclQ7NEJBQ0FyQyxPQUFPdkQsS0FBS2tDLE1BQU07NEJBQ2xCVSxNQUFNNUMsS0FBSzRDLElBQUk7NEJBQ2ZvQixNQUFNaEUsS0FBSzhELFNBQVMsRUFBRVYsS0FBS1ksUUFBUTt3QkFDcEM7b0JBQUc7b0JBQ0g7OztLQUdBLEdBQ0EsTUFBTTBILFdBQVd4TixzRUFBWUEsQ0FBQ2dFLE9BQU91TixJQUFJLElBQUl0UixtRkFBeUJBLENBQUMrRCxPQUFPdU4sSUFBSSxFQUFFak4sS0FBS0gsR0FBRyxDQUFDd0MsTUFBTSxJQUFJakIsUUFBUWdELE9BQU8sQ0FBQzFFLE9BQU91TixJQUFJO29CQUNsSSxPQUFPO3dCQUFFdk4sUUFBUTBCLFFBQVFnRCxPQUFPLENBQUM7NEJBQUU2SSxNQUFNL0Q7d0JBQVM7b0JBQUc7Z0JBQ3REO2dCQUNBd0YsV0FBV2tILE9BQU85VSxXQUFXLENBQUN1VyxNQUFNLENBQUMzSSxTQUFTO2dCQUM5Q2YsU0FBUyxDQUFDaFA7b0JBQ1RxQixLQUFLMk4sT0FBTyxHQUFHO3dCQUNkdkssT0FBT2xJLDhFQUF1QkEsQ0FBQ3lEO3dCQUMvQnlCLE1BQU0sS0FBSzt3QkFDWFcsT0FBTyxLQUFLO3dCQUNab1UsS0FBS3FCLFdBQVdDLGdCQUFnQjt3QkFDaEM1VyxLQUFLRyxLQUFLSCxHQUFHO3dCQUNiMkIsTUFBTVUsTUFBTVYsUUFBUTtvQkFDckI7Z0JBQ0Q7Z0JBQ0FxTSxhQUFZOEgsU0FBUztvQkFDcEIsTUFBTW5ZLE9BQU8wRSxNQUFNZixLQUFLLENBQUN3VSxVQUFVdlYsSUFBSSxDQUFDLEVBQUUsQ0FBQztvQkFDM0MsTUFBTWdELFFBQVFsSSw4RUFBdUJBLENBQUN5YSxVQUFVdlMsS0FBSztvQkFDckQsTUFBTXJDLFFBQVF2RCxNQUFNa0M7b0JBQ3BCLE1BQU1VLE9BQU81QyxNQUFNNEM7b0JBQ25CLE1BQU1vQixPQUFPaEUsTUFBTThELFdBQVdWLEtBQUtZLFFBQVE7b0JBQzNDLE1BQU0rVixRQUFRemMsMEVBQWFBLENBQUM7d0JBQzNCOGE7d0JBQ0FULEtBQUtxQixXQUFXQyxnQkFBZ0I7d0JBQ2hDclQ7d0JBQ0FyQzt3QkFDQVg7d0JBQ0FvQjtvQkFDRDtvQkFDQSxPQUFPK1Y7Z0JBQ1I7WUFDRDtZQUNBLE9BQU8sSUFBSXJCLFNBQVN6SCxRQUFRO2dCQUMzQjNPO2dCQUNBb0UsUUFBUWlULGVBQWVqVCxNQUFNO1lBQzlCO1FBQ0Q7UUFDQTs7Ozs7RUFLQSxHQUNBcEUsUUFBUTBGLEdBQUcsQ0FBQyxnQkFBZ0I7UUFDNUIsTUFBTWlTLFVBQVUsQ0FBQyxNQUFNclcsUUFBUUMsR0FBRyxDQUFDMlYsU0FBUSxFQUFHdlksR0FBRyxDQUFDLENBQUN5TDtZQUNsRCxNQUFNLENBQUM5RyxPQUFPMUQsT0FBTyxHQUFHd0s7WUFDeEIsSUFBSTlHLE9BQU8sT0FBTzhHO1lBQ2xCLElBQUk0TCxhQUFhcFcsT0FBT3VOLElBQUksR0FBRyxPQUFPO2dCQUFDLElBQUlqUyw0REFBU0EsQ0FBQztvQkFDcEQ0RCxNQUFNO29CQUNOQyxTQUFTO2dCQUNWO2dCQUFJLEtBQUs7YUFBRTtZQUNYLE9BQU9xTDtRQUNSO1FBQ0EsTUFBTXdOLHNCQUFzQkQsUUFBUWhaLEdBQUcsQ0FBQyxDQUFDLENBQUMyRSxPQUFPMUQsT0FBTyxFQUFFd0I7WUFDekQsTUFBTTFELE9BQU8wRSxLQUFLZixLQUFLLENBQUNELE1BQU07WUFDOUIsSUFBSWtDLE9BQU8sT0FBTztnQkFBRUEsT0FBT3RJLDBFQUFhQSxDQUFDO29CQUN4QzhhO29CQUNBVCxLQUFLcUIsV0FBV0MsZ0JBQWdCO29CQUNoQ3JUO29CQUNBckMsT0FBT3ZELEtBQUtrQyxNQUFNO29CQUNsQlUsTUFBTTVDLEtBQUs0QyxJQUFJO29CQUNmb0IsTUFBTWhFLEtBQUs4RCxTQUFTLEVBQUVWLEtBQUtZLFFBQVE7Z0JBQ3BDO1lBQUc7WUFDSCxPQUFPO2dCQUFFOUIsUUFBUTtvQkFBRXVOLE1BQU12TixPQUFPdU4sSUFBSTtnQkFBQztZQUFFO1FBQ3hDO1FBQ0EsTUFBTTdCLFNBQVNxTSxRQUFRaFosR0FBRyxDQUFDLENBQUMsQ0FBQzJFLE1BQU0sR0FBS0EsT0FBTzdFLE1BQU0sQ0FBQ3FEO1FBQ3RELE1BQU0rVixlQUFlMUMsYUFBYTtZQUNqQ0UsS0FBS3FCLFdBQVdDLGdCQUFnQjtZQUNoQ3ZVO1lBQ0FrVCxjQUFjcFYsS0FBS29WLFlBQVk7WUFDL0JDLG1CQUFtQnFDO1lBQ25CdE07WUFDQXRMO1FBQ0Q7UUFDQSxPQUFPLElBQUlvVyxTQUFTbFgsS0FBSytQLFNBQVMsQ0FBQzNULDRFQUFxQkEsQ0FBQ3dhLFFBQVE4Qix1QkFBdUI7WUFDdkZ4VCxRQUFReVQsYUFBYXpULE1BQU07WUFDM0JwRTtRQUNEO0lBQ0QsRUFBRSxPQUFPbkIsT0FBTztRQUNmLE1BQU0sQ0FBQ2laLFlBQVkxVixLQUFLLEdBQUdvVTtRQUMzQixNQUFNbkIsTUFBTXFCLFdBQVdDLGdCQUFnQjtRQUN2QyxNQUFNLEVBQUVyVCxLQUFLLEVBQUVpUyxpQkFBaUIsRUFBRTFTLElBQUksRUFBRSxHQUFHK1Msa0JBQWtCL1csT0FBTztZQUNuRXFCO1lBQ0FtVixLQUFLcUIsV0FBV0MsZ0JBQWdCO1lBQ2hDalYsTUFBTVUsTUFBTVYsUUFBUTtRQUNyQjtRQUNBLE1BQU1tVyxlQUFlMUMsYUFBYTtZQUNqQ0U7WUFDQWpUO1lBQ0FrVCxjQUFjcFYsS0FBS29WLFlBQVk7WUFDL0JDO1lBQ0FqSyxRQUFRO2dCQUFDaEk7YUFBTTtZQUNmdEQ7UUFDRDtRQUNBLE9BQU8sSUFBSW9XLFNBQVN2VCxNQUFNO1lBQ3pCdUIsUUFBUXlULGFBQWF6VCxNQUFNO1lBQzNCcEU7UUFDRDtJQUNEO0FBQ0Q7QUFFQSxZQUFZO0FBQzZYLENBQ3pZLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvcmVzb2x2ZVJlc3BvbnNlLURQYllnSkRELm1qcz82YmVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEVycm9yU2hhcGUsIGdldEhUVFBTdGF0dXNDb2RlIH0gZnJvbSBcIi4vZ2V0RXJyb3JTaGFwZS1EeVlpbDRhVC5tanNcIjtcbmltcG9ydCB7IFRSUENFcnJvciwgZ2V0UHJvY2VkdXJlQXRQYXRoLCBnZXRUUlBDRXJyb3JGcm9tVW5rbm93biwgaXNUcmFja2VkRW52ZWxvcGUsIHRyYW5zZm9ybVRSUENSZXNwb25zZSB9IGZyb20gXCIuL3RyYWNrZWQtR0VXUG9MMEMubWpzXCI7XG5pbXBvcnQgeyBpZGVudGl0eSwgaXNBc3luY0l0ZXJhYmxlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcnVuIH0gZnJvbSBcIi4vdXRpbHMtQkhaSmNCUnYubWpzXCI7XG5pbXBvcnQgeyBpc09ic2VydmFibGUsIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUgfSBmcm9tIFwiLi9vYnNlcnZhYmxlLUIxb3JMSEhJLm1qc1wiO1xuXG4vLyNyZWdpb24gcm9sbGRvd246cnVudGltZVxudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuXHRpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBrZXlzID0gX19nZXRPd25Qcm9wTmFtZXMoZnJvbSksIGkgPSAwLCBuID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IG47IGkrKykge1xuXHRcdGtleSA9IGtleXNbaV07XG5cdFx0aWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdCkgX19kZWZQcm9wKHRvLCBrZXksIHtcblx0XHRcdGdldDogKChrKSA9PiBmcm9tW2tdKS5iaW5kKG51bGwsIGtleSksXG5cdFx0XHRlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZVxuXHRcdH0pO1xuXHR9XG5cdHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwge1xuXHR2YWx1ZTogbW9kLFxuXHRlbnVtZXJhYmxlOiB0cnVlXG59KSA6IHRhcmdldCwgbW9kKSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9wYXJzZUNvbm5lY3Rpb25QYXJhbXMudHNcbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21Vbmtub3duKHBhcnNlZCkge1xuXHR0cnkge1xuXHRcdGlmIChwYXJzZWQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXHRcdGlmICghaXNPYmplY3QocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb2JqZWN0XCIpO1xuXHRcdGNvbnN0IG5vblN0cmluZ1ZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHBhcnNlZCkuZmlsdGVyKChbX2tleSwgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpO1xuXHRcdGlmIChub25TdHJpbmdWYWx1ZXMubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBjb25uZWN0aW9uUGFyYW1zIHRvIGJlIHN0cmluZyB2YWx1ZXMuIEdvdCAke25vblN0cmluZ1ZhbHVlcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fTogJHt0eXBlb2YgdmFsdWV9YCkuam9pbihcIiwgXCIpfWApO1xuXHRcdHJldHVybiBwYXJzZWQ7XG5cdH0gY2F0Y2ggKGNhdXNlKSB7XG5cdFx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRjb2RlOiBcIlBBUlNFX0VSUk9SXCIsXG5cdFx0XHRtZXNzYWdlOiBcIkludmFsaWQgY29ubmVjdGlvbiBwYXJhbXMgc2hhcGVcIixcblx0XHRcdGNhdXNlXG5cdFx0fSk7XG5cdH1cbn1cbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoc3RyKSB7XG5cdGxldCBwYXJzZWQ7XG5cdHRyeSB7XG5cdFx0cGFyc2VkID0gSlNPTi5wYXJzZShzdHIpO1xuXHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJQQVJTRV9FUlJPUlwiLFxuXHRcdFx0bWVzc2FnZTogXCJOb3QgSlNPTi1wYXJzYWJsZSBxdWVyeSBwYXJhbXNcIixcblx0XHRcdGNhdXNlXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21Vbmtub3duKHBhcnNlZCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9jb250ZW50VHlwZS50c1xuLyoqXG4qIE1lbW9pemUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vIGFyZ3VtZW50c1xuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBtZW1vKGZuKSB7XG5cdGxldCBwcm9taXNlID0gbnVsbDtcblx0Y29uc3Qgc3ltID0gU3ltYm9sLmZvcihcIkB0cnBjL3NlcnZlci9odHRwL21lbW9cIik7XG5cdGxldCB2YWx1ZSA9IHN5bTtcblx0cmV0dXJuIHtcblx0XHRyZWFkOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRpZiAodmFsdWUgIT09IHN5bSkgcmV0dXJuIHZhbHVlO1xuXHRcdFx0cHJvbWlzZSA/Pz0gZm4oKS5jYXRjaCgoY2F1c2UpID0+IHtcblx0XHRcdFx0aWYgKGNhdXNlIGluc3RhbmNlb2YgVFJQQ0Vycm9yKSB0aHJvdyBjYXVzZTtcblx0XHRcdFx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVzZS5tZXNzYWdlIDogXCJJbnZhbGlkIGlucHV0XCIsXG5cdFx0XHRcdFx0Y2F1c2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcblx0XHRcdHByb21pc2UgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0sXG5cdFx0cmVzdWx0OiAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHN5bSA/IHZhbHVlIDogdm9pZCAwO1xuXHRcdH1cblx0fTtcbn1cbmNvbnN0IGpzb25Db250ZW50VHlwZUhhbmRsZXIgPSB7XG5cdGlzTWF0Y2gocmVxKSB7XG5cdFx0cmV0dXJuICEhcmVxLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpPy5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0fSxcblx0YXN5bmMgcGFyc2Uob3B0cykge1xuXHRcdGNvbnN0IHsgcmVxIH0gPSBvcHRzO1xuXHRcdGNvbnN0IGlzQmF0Y2hDYWxsID0gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwiYmF0Y2hcIikgPT09IFwiMVwiO1xuXHRcdGNvbnN0IHBhdGhzID0gaXNCYXRjaENhbGwgPyBvcHRzLnBhdGguc3BsaXQoXCIsXCIpIDogW29wdHMucGF0aF07XG5cdFx0Y29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG5cdFx0XHRsZXQgaW5wdXRzID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJlcS5tZXRob2QgPT09IFwiR0VUXCIpIHtcblx0XHRcdFx0Y29uc3QgcXVlcnlJbnB1dCA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldChcImlucHV0XCIpO1xuXHRcdFx0XHRpZiAocXVlcnlJbnB1dCkgaW5wdXRzID0gSlNPTi5wYXJzZShxdWVyeUlucHV0KTtcblx0XHRcdH0gZWxzZSBpbnB1dHMgPSBhd2FpdCByZXEuanNvbigpO1xuXHRcdFx0aWYgKGlucHV0cyA9PT0gdm9pZCAwKSByZXR1cm4ge307XG5cdFx0XHRpZiAoIWlzQmF0Y2hDYWxsKSByZXR1cm4geyAwOiBvcHRzLnJvdXRlci5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIuaW5wdXQuZGVzZXJpYWxpemUoaW5wdXRzKSB9O1xuXHRcdFx0aWYgKCFpc09iamVjdChpbnB1dHMpKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0XHRtZXNzYWdlOiBcIlxcXCJpbnB1dFxcXCIgbmVlZHMgdG8gYmUgYW4gb2JqZWN0IHdoZW4gZG9pbmcgYSBiYXRjaCBjYWxsXCJcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3QgYWNjID0ge307XG5cdFx0XHRmb3IgKGNvbnN0IGluZGV4IG9mIHBhdGhzLmtleXMoKSkge1xuXHRcdFx0XHRjb25zdCBpbnB1dCA9IGlucHV0c1tpbmRleF07XG5cdFx0XHRcdGlmIChpbnB1dCAhPT0gdm9pZCAwKSBhY2NbaW5kZXhdID0gb3B0cy5yb3V0ZXIuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyLmlucHV0LmRlc2VyaWFsaXplKGlucHV0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSk7XG5cdFx0Y29uc3QgY2FsbHMgPSBhd2FpdCBQcm9taXNlLmFsbChwYXRocy5tYXAoYXN5bmMgKHBhdGgsIGluZGV4KSA9PiB7XG5cdFx0XHRjb25zdCBwcm9jZWR1cmUgPSBhd2FpdCBnZXRQcm9jZWR1cmVBdFBhdGgob3B0cy5yb3V0ZXIsIHBhdGgpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0cHJvY2VkdXJlLFxuXHRcdFx0XHRnZXRSYXdJbnB1dDogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0cyA9IGF3YWl0IGdldElucHV0cy5yZWFkKCk7XG5cdFx0XHRcdFx0bGV0IGlucHV0ID0gaW5wdXRzW2luZGV4XTtcblx0XHRcdFx0XHRpZiAocHJvY2VkdXJlPy5fZGVmLnR5cGUgPT09IFwic3Vic2NyaXB0aW9uXCIpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxhc3RFdmVudElkID0gb3B0cy5oZWFkZXJzLmdldChcImxhc3QtZXZlbnQtaWRcIikgPz8gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwibGFzdEV2ZW50SWRcIikgPz8gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwiTGFzdC1FdmVudC1JZFwiKTtcblx0XHRcdFx0XHRcdGlmIChsYXN0RXZlbnRJZCkgaWYgKGlzT2JqZWN0KGlucHV0KSkgaW5wdXQgPSB7XG5cdFx0XHRcdFx0XHRcdC4uLmlucHV0LFxuXHRcdFx0XHRcdFx0XHRsYXN0RXZlbnRJZFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGVsc2UgaW5wdXQgPz89IHsgbGFzdEV2ZW50SWQgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXN1bHQ6ICgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0SW5wdXRzLnJlc3VsdCgpPy5baW5kZXhdO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0pKTtcblx0XHRjb25zdCB0eXBlcyA9IG5ldyBTZXQoY2FsbHMubWFwKChjYWxsKSA9PiBjYWxsLnByb2NlZHVyZT8uX2RlZi50eXBlKS5maWx0ZXIoQm9vbGVhbikpO1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cblx0XHRpZiAodHlwZXMuc2l6ZSA+IDEpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0bWVzc2FnZTogYENhbm5vdCBtaXggcHJvY2VkdXJlIHR5cGVzIGluIGNhbGw6ICR7QXJyYXkuZnJvbSh0eXBlcykuam9pbihcIiwgXCIpfWBcblx0XHR9KTtcblx0XHRjb25zdCB0eXBlID0gdHlwZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlID8/IFwidW5rbm93blwiO1xuXHRcdGNvbnN0IGNvbm5lY3Rpb25QYXJhbXNTdHIgPSBvcHRzLnNlYXJjaFBhcmFtcy5nZXQoXCJjb25uZWN0aW9uUGFyYW1zXCIpO1xuXHRcdGNvbnN0IGluZm8gPSB7XG5cdFx0XHRpc0JhdGNoQ2FsbCxcblx0XHRcdGFjY2VwdDogcmVxLmhlYWRlcnMuZ2V0KFwidHJwYy1hY2NlcHRcIiksXG5cdFx0XHRjYWxscyxcblx0XHRcdHR5cGUsXG5cdFx0XHRjb25uZWN0aW9uUGFyYW1zOiBjb25uZWN0aW9uUGFyYW1zU3RyID09PSBudWxsID8gbnVsbCA6IHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoY29ubmVjdGlvblBhcmFtc1N0ciksXG5cdFx0XHRzaWduYWw6IHJlcS5zaWduYWwsXG5cdFx0XHR1cmw6IG9wdHMudXJsXG5cdFx0fTtcblx0XHRyZXR1cm4gaW5mbztcblx0fVxufTtcbmNvbnN0IGZvcm1EYXRhQ29udGVudFR5cGVIYW5kbGVyID0ge1xuXHRpc01hdGNoKHJlcSkge1xuXHRcdHJldHVybiAhIXJlcS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKT8uc3RhcnRzV2l0aChcIm11bHRpcGFydC9mb3JtLWRhdGFcIik7XG5cdH0sXG5cdGFzeW5jIHBhcnNlKG9wdHMpIHtcblx0XHRjb25zdCB7IHJlcSB9ID0gb3B0cztcblx0XHRpZiAocmVxLm1ldGhvZCAhPT0gXCJQT1NUXCIpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0bWVzc2FnZTogXCJPbmx5IFBPU1QgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZCBmb3IgbXVsdGlwYXJ0L2Zvcm0tZGF0YSByZXF1ZXN0c1wiXG5cdFx0fSk7XG5cdFx0Y29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG5cdFx0XHRjb25zdCBmZCA9IGF3YWl0IHJlcS5mb3JtRGF0YSgpO1xuXHRcdFx0cmV0dXJuIGZkO1xuXHRcdH0pO1xuXHRcdGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgb3B0cy5wYXRoKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWNjZXB0OiBudWxsLFxuXHRcdFx0Y2FsbHM6IFt7XG5cdFx0XHRcdHBhdGg6IG9wdHMucGF0aCxcblx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGdldElucHV0cy5yZWFkLFxuXHRcdFx0XHRyZXN1bHQ6IGdldElucHV0cy5yZXN1bHQsXG5cdFx0XHRcdHByb2NlZHVyZVxuXHRcdFx0fV0sXG5cdFx0XHRpc0JhdGNoQ2FsbDogZmFsc2UsXG5cdFx0XHR0eXBlOiBcIm11dGF0aW9uXCIsXG5cdFx0XHRjb25uZWN0aW9uUGFyYW1zOiBudWxsLFxuXHRcdFx0c2lnbmFsOiByZXEuc2lnbmFsLFxuXHRcdFx0dXJsOiBvcHRzLnVybFxuXHRcdH07XG5cdH1cbn07XG5jb25zdCBvY3RldFN0cmVhbUNvbnRlbnRUeXBlSGFuZGxlciA9IHtcblx0aXNNYXRjaChyZXEpIHtcblx0XHRyZXR1cm4gISFyZXEuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG5cdH0sXG5cdGFzeW5jIHBhcnNlKG9wdHMpIHtcblx0XHRjb25zdCB7IHJlcSB9ID0gb3B0cztcblx0XHRpZiAocmVxLm1ldGhvZCAhPT0gXCJQT1NUXCIpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0bWVzc2FnZTogXCJPbmx5IFBPU1QgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZCBmb3IgYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIHJlcXVlc3RzXCJcblx0XHR9KTtcblx0XHRjb25zdCBnZXRJbnB1dHMgPSBtZW1vKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiByZXEuYm9keTtcblx0XHR9KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2FsbHM6IFt7XG5cdFx0XHRcdHBhdGg6IG9wdHMucGF0aCxcblx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGdldElucHV0cy5yZWFkLFxuXHRcdFx0XHRyZXN1bHQ6IGdldElucHV0cy5yZXN1bHQsXG5cdFx0XHRcdHByb2NlZHVyZTogYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKG9wdHMucm91dGVyLCBvcHRzLnBhdGgpXG5cdFx0XHR9XSxcblx0XHRcdGlzQmF0Y2hDYWxsOiBmYWxzZSxcblx0XHRcdGFjY2VwdDogbnVsbCxcblx0XHRcdHR5cGU6IFwibXV0YXRpb25cIixcblx0XHRcdGNvbm5lY3Rpb25QYXJhbXM6IG51bGwsXG5cdFx0XHRzaWduYWw6IHJlcS5zaWduYWwsXG5cdFx0XHR1cmw6IG9wdHMudXJsXG5cdFx0fTtcblx0fVxufTtcbmNvbnN0IGhhbmRsZXJzID0gW1xuXHRqc29uQ29udGVudFR5cGVIYW5kbGVyLFxuXHRmb3JtRGF0YUNvbnRlbnRUeXBlSGFuZGxlcixcblx0b2N0ZXRTdHJlYW1Db250ZW50VHlwZUhhbmRsZXJcbl07XG5mdW5jdGlvbiBnZXRDb250ZW50VHlwZUhhbmRsZXIocmVxKSB7XG5cdGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVycy5maW5kKChoYW5kbGVyJDEpID0+IGhhbmRsZXIkMS5pc01hdGNoKHJlcSkpO1xuXHRpZiAoaGFuZGxlcikgcmV0dXJuIGhhbmRsZXI7XG5cdGlmICghaGFuZGxlciAmJiByZXEubWV0aG9kID09PSBcIkdFVFwiKSByZXR1cm4ganNvbkNvbnRlbnRUeXBlSGFuZGxlcjtcblx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0Y29kZTogXCJVTlNVUFBPUlRFRF9NRURJQV9UWVBFXCIsXG5cdFx0bWVzc2FnZTogcmVxLmhlYWRlcnMuaGFzKFwiY29udGVudC10eXBlXCIpID8gYFVuc3VwcG9ydGVkIGNvbnRlbnQtdHlwZSBcIiR7cmVxLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpfWAgOiBcIk1pc3NpbmcgY29udGVudC10eXBlIGhlYWRlclwiXG5cdH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVxdWVzdEluZm8ob3B0cykge1xuXHRjb25zdCBoYW5kbGVyID0gZ2V0Q29udGVudFR5cGVIYW5kbGVyKG9wdHMucmVxKTtcblx0cmV0dXJuIGF3YWl0IGhhbmRsZXIucGFyc2Uob3B0cyk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9hYm9ydEVycm9yLnRzXG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyb3IpIHtcblx0cmV0dXJuIGlzT2JqZWN0KGVycm9yKSAmJiBlcnJvcltcIm5hbWVcIl0gPT09IFwiQWJvcnRFcnJvclwiO1xufVxuZnVuY3Rpb24gdGhyb3dBYm9ydEVycm9yKG1lc3NhZ2UgPSBcIkFib3J0RXJyb3JcIikge1xuXHR0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKG1lc3NhZ2UsIFwiQWJvcnRFcnJvclwiKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3ZlbmRvci91bnByb21pc2UvdW5wcm9taXNlLnRzXG4vKiogTWVtb3J5IHNhZmUgKHdlYWttYXBwZWQpIGNhY2hlIG9mIHRoZSBQcm94eVByb21pc2UgZm9yIGVhY2ggUHJvbWlzZSxcbiogd2hpY2ggaXMgcmV0YWluZWQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgb3JpZ2luYWwgUHJvbWlzZS5cbiovXG5jb25zdCBzdWJzY3JpYmFibGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuLyoqIEEgTk9PUCBmdW5jdGlvbiBhbGxvd2luZyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIGZvciBzZXR0bGVkXG4qIFN1YnNjcmliZWRQcm9taXNlcyAoc2V0dGxlZCBwcm9taXNlcyBhcmUgbm90IHN1YnNjcmliZWQgLSB0aGV5IHJlc29sdmVcbiogaW1tZWRpYXRlbHkpLiAqL1xuY29uc3QgTk9PUCA9ICgpID0+IHt9O1xuLyoqXG4qIEV2ZXJ5IGBQcm9taXNlPFQ+YCBjYW4gYmUgc2hhZG93ZWQgYnkgYSBzaW5nbGUgYFByb3h5UHJvbWlzZTxUPmAuIEl0IGlzXG4qIGNyZWF0ZWQgb25jZSwgY2FjaGVkIGFuZCByZXVzZWQgdGhyb3VnaG91dCB0aGUgbGlmZXRpbWUgb2YgdGhlIFByb21pc2UuIEdldCBhXG4qIFByb21pc2UncyBQcm94eVByb21pc2UgdXNpbmcgYFVucHJvbWlzZS5wcm94eShwcm9taXNlKWAuXG4qXG4qIFRoZSBgUHJveHlQcm9taXNlPFQ+YCBhdHRhY2hlcyBoYW5kbGVycyB0byB0aGUgb3JpZ2luYWwgYFByb21pc2U8VD5gXG4qIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYCBqdXN0IG9uY2UuIFByb21pc2VzIGRlcml2ZWQgZnJvbSBpdCB1c2UgYVxuKiBzdWJzY3JpcHRpb24tIChhbmQgdW5zdWJzY3JpcHRpb24tKSBiYXNlZCBtZWNoYW5pc20gdGhhdCBtb25pdG9ycyB0aGVzZVxuKiBoYW5kbGVycy5cbipcbiogRXZlcnkgdGltZSB5b3UgY2FsbCBgLnN1YnNjcmliZSgpYCwgYC50aGVuKClgIGAuY2F0Y2goKWAgb3IgYC5maW5hbGx5KClgIG9uIGFcbiogYFByb3h5UHJvbWlzZTxUPmAgaXQgcmV0dXJucyBhIGBTdWJzY3JpYmVkUHJvbWlzZTxUPmAgaGF2aW5nIGFuIGFkZGl0aW9uYWxcbiogYHVuc3Vic2NyaWJlKClgIG1ldGhvZC4gQ2FsbGluZyBgdW5zdWJzY3JpYmUoKWAgZGV0YWNoZXMgcmVmZXJlbmNlIGNoYWluc1xuKiBmcm9tIHRoZSBvcmlnaW5hbCwgcG90ZW50aWFsbHkgbG9uZy1saXZlZCBQcm9taXNlLCBlbGltaW5hdGluZyBtZW1vcnkgbGVha3MuXG4qXG4qIFRoaXMgYXBwcm9hY2ggY2FuIGVsaW1pbmF0ZSB0aGUgbWVtb3J5IGxlYWtzIHRoYXQgb3RoZXJ3aXNlIGNvbWUgYWJvdXQgZnJvbVxuKiByZXBlYXRlZCBgcmFjZSgpYCBvciBgYW55KClgIGNhbGxzIGludm9raW5nIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYCBtdWx0aXBsZVxuKiB0aW1lcyBvbiB0aGUgc2FtZSBsb25nLWxpdmVkIG5hdGl2ZSBQcm9taXNlIChzdWJzY3JpcHRpb25zIHdoaWNoIGNhbiBuZXZlciBiZVxuKiBjbGVhbmVkIHVwKS5cbipcbiogYFVucHJvbWlzZS5yYWNlKHByb21pc2VzKWAgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgYFByb21pc2UucmFjZWBcbiogYXZvaWRpbmcgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgbG9uZy1saXZlZCB1bnNldHRsZWQgUHJvbWlzZXMuXG4qXG4qIGBVbnByb21pc2UuYW55KHByb21pc2VzKWAgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgYFByb21pc2UuYW55YFxuKiBhdm9pZGluZyBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyBsb25nLWxpdmVkIHVuc2V0dGxlZCBQcm9taXNlcy5cbipcbiogYFVucHJvbWlzZS5yZXNvbHZlKHByb21pc2UpYCByZXR1cm5zIGFuIGVwaGVtZXJhbCBgU3Vic2NyaWJlZFByb21pc2U8VD5gIGZvclxuKiBhbnkgZ2l2ZW4gYFByb21pc2U8VD5gIGZhY2lsaXRhdGluZyBhcmJpdHJhcnkgYXN5bmMvYXdhaXQgcGF0dGVybnMuIEJlaGluZFxuKiB0aGUgc2NlbmVzLCBgcmVzb2x2ZWAgaXMgaW1wbGVtZW50ZWQgc2ltcGx5IGFzXG4qIGBVbnByb21pc2UucHJveHkocHJvbWlzZSkuc3Vic2NyaWJlKClgLiBEb24ndCBmb3JnZXQgdG8gY2FsbCBgLnVuc3Vic2NyaWJlKClgXG4qIHRvIHRpZHkgdXAhXG4qXG4qL1xudmFyIFVucHJvbWlzZSA9IGNsYXNzIFVucHJvbWlzZSB7XG5cdC8qKiBJTlNUQU5DRSBJTVBMRU1FTlRBVElPTiAqL1xuXHQvKiogVGhlIHByb21pc2Ugc2hhZG93ZWQgYnkgdGhpcyBVbnByb21pc2U8VD4gICovXG5cdHByb21pc2U7XG5cdC8qKiBQcm9taXNlcyBleHBlY3RpbmcgZXZlbnR1YWwgc2V0dGxlbWVudCAodW5sZXNzIHVuc3Vic2NyaWJlZCBmaXJzdCkuIFRoaXMgbGlzdCBpcyBkZWxldGVkXG5cdCogYWZ0ZXIgdGhlIG9yaWdpbmFsIHByb21pc2Ugc2V0dGxlcyAtIG5vIGZ1cnRoZXIgbm90aWZpY2F0aW9ucyB3aWxsIGJlIGlzc3VlZC4gKi9cblx0c3Vic2NyaWJlcnMgPSBbXTtcblx0LyoqIFRoZSBQcm9taXNlJ3Mgc2V0dGxlbWVudCAocmVjb3JkZWQgd2hlbiBpdCBmdWxmaWxzIG9yIHJlamVjdHMpLiBUaGlzIGlzIGNvbnN1bHRlZCB3aGVuXG5cdCogY2FsbGluZyAuc3Vic2NyaWJlKCkgLnRoZW4oKSAuY2F0Y2goKSAuZmluYWxseSgpIHRvIHNlZSBpZiBhbiBpbW1lZGlhdGVseS1yZXNvbHZpbmcgUHJvbWlzZVxuXHQqIGNhbiBiZSByZXR1cm5lZCwgYW5kIHRoZXJlZm9yZSBzdWJzY3JpcHRpb24gY2FuIGJlIGJ5cGFzc2VkLiAqL1xuXHRzZXR0bGVtZW50ID0gbnVsbDtcblx0Y29uc3RydWN0b3IoYXJnKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoYXJnKTtcblx0XHRlbHNlIHRoaXMucHJvbWlzZSA9IGFyZztcblx0XHRjb25zdCB0aGVuUmV0dXJuID0gdGhpcy5wcm9taXNlLnRoZW4oKHZhbHVlKSA9PiB7XG5cdFx0XHRjb25zdCB7IHN1YnNjcmliZXJzIH0gPSB0aGlzO1xuXHRcdFx0dGhpcy5zdWJzY3JpYmVycyA9IG51bGw7XG5cdFx0XHR0aGlzLnNldHRsZW1lbnQgPSB7XG5cdFx0XHRcdHN0YXR1czogXCJmdWxmaWxsZWRcIixcblx0XHRcdFx0dmFsdWVcblx0XHRcdH07XG5cdFx0XHRzdWJzY3JpYmVycz8uZm9yRWFjaCgoeyByZXNvbHZlIH0pID0+IHtcblx0XHRcdFx0cmVzb2x2ZSh2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRpZiAoXCJjYXRjaFwiIGluIHRoZW5SZXR1cm4pIHRoZW5SZXR1cm4uY2F0Y2goKHJlYXNvbikgPT4ge1xuXHRcdFx0Y29uc3QgeyBzdWJzY3JpYmVycyB9ID0gdGhpcztcblx0XHRcdHRoaXMuc3Vic2NyaWJlcnMgPSBudWxsO1xuXHRcdFx0dGhpcy5zZXR0bGVtZW50ID0ge1xuXHRcdFx0XHRzdGF0dXM6IFwicmVqZWN0ZWRcIixcblx0XHRcdFx0cmVhc29uXG5cdFx0XHR9O1xuXHRcdFx0c3Vic2NyaWJlcnM/LmZvckVhY2goKHsgcmVqZWN0IH0pID0+IHtcblx0XHRcdFx0cmVqZWN0KHJlYXNvbik7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXHQvKiogQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IG1pdGlnYXRlcyB1bmNvbnRyb2xsZWQgc3Vic2NyaXB0aW9uIHRvIGEgbG9uZy1saXZlZFxuXHQqIFByb21pc2UgdmlhIC50aGVuKCkgYW5kIC5jYXRjaCgpIC0gb3RoZXJ3aXNlIGEgc291cmNlIG9mIG1lbW9yeSBsZWFrcy5cblx0KlxuXHQqIFRoZSByZXR1cm5lZCBwcm9taXNlIGhhcyBhbiBgdW5zdWJzY3JpYmUoKWAgbWV0aG9kIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2hlblxuXHQqIHRoZSBQcm9taXNlIGlzIG5vIGxvbmdlciBiZWluZyB0cmFja2VkIGJ5IGFwcGxpY2F0aW9uIGxvZ2ljLCBhbmQgd2hpY2hcblx0KiBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm8gcmVmZXJlbmNlIGNoYWluIGZyb20gdGhlIG9yaWdpbmFsIHByb21pc2UgdG8gdGhlXG5cdCogbmV3IG9uZSwgYW5kIHRoZXJlZm9yZSBubyBtZW1vcnkgbGVhay5cblx0KlxuXHQqIElmIG9yaWdpbmFsIHByb21pc2UgaGFzIG5vdCB5ZXQgc2V0dGxlZCwgdGhpcyBhZGRzIGEgbmV3IHVuaXF1ZSBwcm9taXNlXG5cdCogdGhhdCBsaXN0ZW5zIHRvIHRoZW4vY2F0Y2ggZXZlbnRzLCBhbG9uZyB3aXRoIGFuIGB1bnN1YnNjcmliZSgpYCBtZXRob2QgdG9cblx0KiBkZXRhY2ggaXQuXG5cdCpcblx0KiBJZiBvcmlnaW5hbCBwcm9taXNlIGhhcyBzZXR0bGVkLCB0aGVuIGNyZWF0ZXMgYSBuZXcgUHJvbWlzZS5yZXNvbHZlKCkgb3Jcblx0KiBQcm9taXNlLnJlamVjdCgpIGFuZCBwcm92aWRlZCB1bnN1YnNjcmliZSBpcyBhIG5vb3AuXG5cdCpcblx0KiBJZiB5b3UgY2FsbCBgdW5zdWJzY3JpYmUoKWAgYmVmb3JlIHRoZSByZXR1cm5lZCBQcm9taXNlIGhhcyBzZXR0bGVkLCBpdFxuXHQqIHdpbGwgbmV2ZXIgc2V0dGxlLlxuXHQqL1xuXHRzdWJzY3JpYmUoKSB7XG5cdFx0bGV0IHByb21pc2U7XG5cdFx0bGV0IHVuc3Vic2NyaWJlO1xuXHRcdGNvbnN0IHsgc2V0dGxlbWVudCB9ID0gdGhpcztcblx0XHRpZiAoc2V0dGxlbWVudCA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKHRoaXMuc3Vic2NyaWJlcnMgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIlVucHJvbWlzZSBzZXR0bGVkIGJ1dCBzdGlsbCBoYXMgc3Vic2NyaWJlcnNcIik7XG5cdFx0XHRjb25zdCBzdWJzY3JpYmVyID0gd2l0aFJlc29sdmVycygpO1xuXHRcdFx0dGhpcy5zdWJzY3JpYmVycyA9IGxpc3RXaXRoTWVtYmVyKHRoaXMuc3Vic2NyaWJlcnMsIHN1YnNjcmliZXIpO1xuXHRcdFx0cHJvbWlzZSA9IHN1YnNjcmliZXIucHJvbWlzZTtcblx0XHRcdHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuXHRcdFx0XHRpZiAodGhpcy5zdWJzY3JpYmVycyAhPT0gbnVsbCkgdGhpcy5zdWJzY3JpYmVycyA9IGxpc3RXaXRob3V0TWVtYmVyKHRoaXMuc3Vic2NyaWJlcnMsIHN1YnNjcmliZXIpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgeyBzdGF0dXMgfSA9IHNldHRsZW1lbnQ7XG5cdFx0XHRpZiAoc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHNldHRsZW1lbnQudmFsdWUpO1xuXHRcdFx0ZWxzZSBwcm9taXNlID0gUHJvbWlzZS5yZWplY3Qoc2V0dGxlbWVudC5yZWFzb24pO1xuXHRcdFx0dW5zdWJzY3JpYmUgPSBOT09QO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7IHVuc3Vic2NyaWJlIH0pO1xuXHR9XG5cdC8qKiBTVEFOREFSRCBQUk9NSVNFIE1FVEhPRFMgKGJ1dCByZXR1cm5pbmcgYSBTdWJzY3JpYmVkUHJvbWlzZSkgKi9cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLnN1YnNjcmliZSgpO1xuXHRcdGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IHN1YnNjcmliZWQ7XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oc3Vic2NyaWJlZC50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSwgeyB1bnN1YnNjcmliZSB9KTtcblx0fVxuXHRjYXRjaChvbnJlamVjdGVkKSB7XG5cdFx0Y29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG5cdFx0Y29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLmNhdGNoKG9ucmVqZWN0ZWQpLCB7IHVuc3Vic2NyaWJlIH0pO1xuXHR9XG5cdGZpbmFsbHkob25maW5hbGx5KSB7XG5cdFx0Y29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG5cdFx0Y29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLmZpbmFsbHkob25maW5hbGx5KSwgeyB1bnN1YnNjcmliZSB9KTtcblx0fVxuXHQvKiogVE9TVFJJTkcgU1VQUE9SVCAqL1xuXHRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9IFwiVW5wcm9taXNlXCI7XG5cdC8qKiBVbnByb21pc2UgU1RBVElDIE1FVEhPRFMgKi9cblx0LyoqIENyZWF0ZSBvciBSZXRyaWV2ZSB0aGUgcHJveHkgVW5wcm9taXNlIChhIHJlLXVzZWQgVW5wcm9taXNlIGZvciB0aGUgVk0gbGlmZXRpbWVcblx0KiBvZiB0aGUgcHJvdmlkZWQgUHJvbWlzZSByZWZlcmVuY2UpICovXG5cdHN0YXRpYyBwcm94eShwcm9taXNlKSB7XG5cdFx0Y29uc3QgY2FjaGVkID0gVW5wcm9taXNlLmdldFN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSk7XG5cdFx0cmV0dXJuIHR5cGVvZiBjYWNoZWQgIT09IFwidW5kZWZpbmVkXCIgPyBjYWNoZWQgOiBVbnByb21pc2UuY3JlYXRlU3Vic2NyaWJhYmxlUHJvbWlzZShwcm9taXNlKTtcblx0fVxuXHQvKiogQ3JlYXRlIGFuZCBzdG9yZSBhbiBVbnByb21pc2Uga2V5ZWQgYnkgYW4gb3JpZ2luYWwgUHJvbWlzZS4gKi9cblx0c3RhdGljIGNyZWF0ZVN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSkge1xuXHRcdGNvbnN0IGNyZWF0ZWQgPSBuZXcgVW5wcm9taXNlKHByb21pc2UpO1xuXHRcdHN1YnNjcmliYWJsZUNhY2hlLnNldChwcm9taXNlLCBjcmVhdGVkKTtcblx0XHRzdWJzY3JpYmFibGVDYWNoZS5zZXQoY3JlYXRlZCwgY3JlYXRlZCk7XG5cdFx0cmV0dXJuIGNyZWF0ZWQ7XG5cdH1cblx0LyoqIFJldHJpZXZlIGEgcHJldmlvdXNseS1jcmVhdGVkIFVucHJvbWlzZSBrZXllZCBieSBhbiBvcmlnaW5hbCBQcm9taXNlLiAqL1xuXHRzdGF0aWMgZ2V0U3Vic2NyaWJhYmxlUHJvbWlzZShwcm9taXNlKSB7XG5cdFx0cmV0dXJuIHN1YnNjcmliYWJsZUNhY2hlLmdldChwcm9taXNlKTtcblx0fVxuXHQvKiogUHJvbWlzZSBTVEFUSUMgTUVUSE9EUyAqL1xuXHQvKiogTG9va3VwIHRoZSBVbnByb21pc2UgZm9yIHRoaXMgcHJvbWlzZSwgYW5kIGRlcml2ZSBhIFN1YnNjcmliZWRQcm9taXNlIGZyb21cblx0KiBpdCAodGhhdCBjYW4gYmUgbGF0ZXIgdW5zdWJzY3JpYmVkIHRvIGVsaW1pbmF0ZSBNZW1vcnkgbGVha3MpICovXG5cdHN0YXRpYyByZXNvbHZlKHZhbHVlKSB7XG5cdFx0Y29uc3QgcHJvbWlzZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcInRoZW5cIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuXHRcdHJldHVybiBVbnByb21pc2UucHJveHkocHJvbWlzZSkuc3Vic2NyaWJlKCk7XG5cdH1cblx0c3RhdGljIGFzeW5jIGFueSh2YWx1ZXMpIHtcblx0XHRjb25zdCB2YWx1ZXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFsuLi52YWx1ZXNdO1xuXHRcdGNvbnN0IHN1YnNjcmliZWRQcm9taXNlcyA9IHZhbHVlc0FycmF5Lm1hcChVbnByb21pc2UucmVzb2x2ZSk7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBhd2FpdCBQcm9taXNlLmFueShzdWJzY3JpYmVkUHJvbWlzZXMpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzdWJzY3JpYmVkUHJvbWlzZXMuZm9yRWFjaCgoeyB1bnN1YnNjcmliZSB9KSA9PiB7XG5cdFx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0c3RhdGljIGFzeW5jIHJhY2UodmFsdWVzKSB7XG5cdFx0Y29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbLi4udmFsdWVzXTtcblx0XHRjb25zdCBzdWJzY3JpYmVkUHJvbWlzZXMgPSB2YWx1ZXNBcnJheS5tYXAoVW5wcm9taXNlLnJlc29sdmUpO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKHN1YnNjcmliZWRQcm9taXNlcyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHN1YnNjcmliZWRQcm9taXNlcy5mb3JFYWNoKCh7IHVuc3Vic2NyaWJlIH0pID0+IHtcblx0XHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHQvKiogQ3JlYXRlIGEgcmFjZSBvZiBTdWJzY3JpYmVkUHJvbWlzZXMgdGhhdCB3aWxsIGZ1bGZpbCB0byBhIHNpbmdsZSB3aW5uaW5nXG5cdCogUHJvbWlzZSAoaW4gYSAxLVR1cGxlKS4gRWxpbWluYXRlcyBtZW1vcnkgbGVha3MgZnJvbSBsb25nLWxpdmVkIHByb21pc2VzXG5cdCogYWNjdW11bGF0aW5nIC50aGVuKCkgYW5kIC5jYXRjaCgpIHN1YnNjcmliZXJzLiBBbGxvd3Mgc2ltcGxlIGxvZ2ljIHRvXG5cdCogY29uc3VtZSB0aGUgcmVzdWx0LCBsaWtlLi4uXG5cdCogYGBgdHNcblx0KiBjb25zdCBbIHdpbm5lciBdID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoWyBwcm9taXNlQSwgcHJvbWlzZUIgXSk7XG5cdCogaWYod2lubmVyID09PSBwcm9taXNlQil7XG5cdCogICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlQjtcblx0KiAgIC8vIGRvIHRoZSB0aGluZ1xuXHQqIH1cblx0KiBgYGBcblx0KiAqL1xuXHRzdGF0aWMgYXN5bmMgcmFjZVJlZmVyZW5jZXMocHJvbWlzZXMpIHtcblx0XHRjb25zdCBzZWxmUHJvbWlzZXMgPSBwcm9taXNlcy5tYXAocmVzb2x2ZVNlbGZUdXBsZSk7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2Uoc2VsZlByb21pc2VzKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0Zm9yIChjb25zdCBwcm9taXNlIG9mIHNlbGZQcm9taXNlcykgcHJvbWlzZS51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0fVxufTtcbi8qKiBQcm9taXNlcyBhIDEtdHVwbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgcHJvbWlzZSB3aGVuIGl0IHJlc29sdmVzLiBBbGxvd3NcbiogYXdhaXRpbmcgdGhlIGV2ZW50dWFsIFByb21pc2UgKioqcmVmZXJlbmNlKioqIChlYXN5IHRvIGRlc3RydWN0dXJlIGFuZFxuKiBleGFjdGx5IGNvbXBhcmUgd2l0aCA9PT0pLiBBdm9pZHMgcmVzb2x2aW5nIHRvIHRoZSBQcm9taXNlICoqKnZhbHVlKioqICh3aGljaFxuKiBtYXkgYmUgYW1iaWd1b3VzIGFuZCB0aGVyZWZvcmUgaGFyZCB0byBpZGVudGlmeSBhcyB0aGUgd2lubmVyIG9mIGEgcmFjZSkuXG4qIFlvdSBjYW4gY2FsbCB1bnN1YnNjcmliZSBvbiB0aGUgUHJvbWlzZSB0byBtaXRpZ2F0ZSBtZW1vcnkgbGVha3MuXG4qICovXG5mdW5jdGlvbiByZXNvbHZlU2VsZlR1cGxlKHByb21pc2UpIHtcblx0cmV0dXJuIFVucHJvbWlzZS5wcm94eShwcm9taXNlKS50aGVuKCgpID0+IFtwcm9taXNlXSk7XG59XG4vKiogVkVORE9SRUQgKEZ1dHVyZSkgUFJPTUlTRSBVVElMSVRJRVMgKi9cbi8qKiBSZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS13aXRoLXJlc29sdmVycyAqL1xuZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcblx0bGV0IHJlc29sdmU7XG5cdGxldCByZWplY3Q7XG5cdGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcblx0XHRyZXNvbHZlID0gX3Jlc29sdmU7XG5cdFx0cmVqZWN0ID0gX3JlamVjdDtcblx0fSk7XG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZSxcblx0XHRyZXNvbHZlLFxuXHRcdHJlamVjdFxuXHR9O1xufVxuLyoqIElNTVVUQUJMRSBMSVNUIE9QRVJBVElPTlMgKi9cbmZ1bmN0aW9uIGxpc3RXaXRoTWVtYmVyKGFyciwgbWVtYmVyKSB7XG5cdHJldHVybiBbLi4uYXJyLCBtZW1iZXJdO1xufVxuZnVuY3Rpb24gbGlzdFdpdGhvdXRJbmRleChhcnIsIGluZGV4KSB7XG5cdHJldHVybiBbLi4uYXJyLnNsaWNlKDAsIGluZGV4KSwgLi4uYXJyLnNsaWNlKGluZGV4ICsgMSldO1xufVxuZnVuY3Rpb24gbGlzdFdpdGhvdXRNZW1iZXIoYXJyLCBtZW1iZXIpIHtcblx0Y29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihtZW1iZXIpO1xuXHRpZiAoaW5kZXggIT09IC0xKSByZXR1cm4gbGlzdFdpdGhvdXRJbmRleChhcnIsIGluZGV4KTtcblx0cmV0dXJuIGFycjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdXRpbHMvZGlzcG9zYWJsZS50c1xuU3ltYm9sLmRpc3Bvc2UgPz89IFN5bWJvbCgpO1xuU3ltYm9sLmFzeW5jRGlzcG9zZSA/Pz0gU3ltYm9sKCk7XG4vKipcbiogVGFrZXMgYSB2YWx1ZSBhbmQgYSBkaXNwb3NlIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG9iamVjdCB0aGF0IGltcGxlbWVudHMgdGhlIERpc3Bvc2FibGUgaW50ZXJmYWNlLlxuKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIHRoZSBvcmlnaW5hbCB2YWx1ZSBhdWdtZW50ZWQgd2l0aCBhIFN5bWJvbC5kaXNwb3NlIG1ldGhvZC5cbiogQHBhcmFtIHRoaW5nIFRoZSB2YWx1ZSB0byBtYWtlIGRpc3Bvc2FibGVcbiogQHBhcmFtIGRpc3Bvc2UgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRpc3Bvc2luZyB0aGUgcmVzb3VyY2VcbiogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmRpc3Bvc2UgbWV0aG9kIGFkZGVkXG4qL1xuZnVuY3Rpb24gbWFrZVJlc291cmNlKHRoaW5nLCBkaXNwb3NlKSB7XG5cdGNvbnN0IGl0ID0gdGhpbmc7XG5cdGNvbnN0IGV4aXN0aW5nID0gaXRbU3ltYm9sLmRpc3Bvc2VdO1xuXHRpdFtTeW1ib2wuZGlzcG9zZV0gPSAoKSA9PiB7XG5cdFx0ZGlzcG9zZSgpO1xuXHRcdGV4aXN0aW5nPy4oKTtcblx0fTtcblx0cmV0dXJuIGl0O1xufVxuLyoqXG4qIFRha2VzIGEgdmFsdWUgYW5kIGFuIGFzeW5jIGRpc3Bvc2UgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgQXN5bmNEaXNwb3NhYmxlIGludGVyZmFjZS5cbiogVGhlIHJldHVybmVkIG9iamVjdCBpcyB0aGUgb3JpZ2luYWwgdmFsdWUgYXVnbWVudGVkIHdpdGggYSBTeW1ib2wuYXN5bmNEaXNwb3NlIG1ldGhvZC5cbiogQHBhcmFtIHRoaW5nIFRoZSB2YWx1ZSB0byBtYWtlIGFzeW5jIGRpc3Bvc2FibGVcbiogQHBhcmFtIGRpc3Bvc2UgQXN5bmMgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRpc3Bvc2luZyB0aGUgcmVzb3VyY2VcbiogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmFzeW5jRGlzcG9zZSBtZXRob2QgYWRkZWRcbiovXG5mdW5jdGlvbiBtYWtlQXN5bmNSZXNvdXJjZSh0aGluZywgZGlzcG9zZSkge1xuXHRjb25zdCBpdCA9IHRoaW5nO1xuXHRjb25zdCBleGlzdGluZyA9IGl0W1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuXHRpdFtTeW1ib2wuYXN5bmNEaXNwb3NlXSA9IGFzeW5jICgpID0+IHtcblx0XHRhd2FpdCBkaXNwb3NlKCk7XG5cdFx0YXdhaXQgZXhpc3Rpbmc/LigpO1xuXHR9O1xuXHRyZXR1cm4gaXQ7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL3RpbWVyUmVzb3VyY2UudHNcbmNvbnN0IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIHRpbWVyUmVzb3VyY2UobXMpIHtcblx0bGV0IHRpbWVyID0gbnVsbDtcblx0cmV0dXJuIG1ha2VSZXNvdXJjZSh7IHN0YXJ0KCkge1xuXHRcdGlmICh0aW1lcikgdGhyb3cgbmV3IEVycm9yKFwiVGltZXIgYWxyZWFkeSBzdGFydGVkXCIpO1xuXHRcdGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCksIG1zKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fSB9LCAoKSA9PiB7XG5cdFx0aWYgKHRpbWVyKSBjbGVhclRpbWVvdXQodGltZXIpO1xuXHR9KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdXNpbmdDdHguanNcbnZhciByZXF1aXJlX3VzaW5nQ3R4ID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdXNpbmdDdHguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcblx0ZnVuY3Rpb24gX3VzaW5nQ3R4KCkge1xuXHRcdHZhciByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbihyJDEsIGUkMSkge1xuXHRcdFx0dmFyIG4kMSA9IEVycm9yKCk7XG5cdFx0XHRyZXR1cm4gbiQxLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBuJDEuZXJyb3IgPSByJDEsIG4kMS5zdXBwcmVzc2VkID0gZSQxLCBuJDE7XG5cdFx0fSwgZSA9IHt9LCBuID0gW107XG5cdFx0ZnVuY3Rpb24gdXNpbmcociQxLCBlJDEpIHtcblx0XHRcdGlmIChudWxsICE9IGUkMSkge1xuXHRcdFx0XHRpZiAoT2JqZWN0KGUkMSkgIT09IGUkMSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVzaW5nIGRlY2xhcmF0aW9ucyBjYW4gb25seSBiZSB1c2VkIHdpdGggb2JqZWN0cywgZnVuY3Rpb25zLCBudWxsLCBvciB1bmRlZmluZWQuXCIpO1xuXHRcdFx0XHRpZiAociQxKSB2YXIgbyA9IGUkMVtTeW1ib2wuYXN5bmNEaXNwb3NlIHx8IFN5bWJvbFtcImZvclwiXShcIlN5bWJvbC5hc3luY0Rpc3Bvc2VcIildO1xuXHRcdFx0XHRpZiAodm9pZCAwID09PSBvICYmIChvID0gZSQxW1N5bWJvbC5kaXNwb3NlIHx8IFN5bWJvbFtcImZvclwiXShcIlN5bWJvbC5kaXNwb3NlXCIpXSwgciQxKSkgdmFyIHQgPSBvO1xuXHRcdFx0XHRpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBkaXNwb3NhYmxlLlwiKTtcblx0XHRcdFx0dCAmJiAobyA9IGZ1bmN0aW9uIG8kMSgpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dC5jYWxsKGUkMSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAociQyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QociQyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pLCBuLnB1c2goe1xuXHRcdFx0XHRcdHY6IGUkMSxcblx0XHRcdFx0XHRkOiBvLFxuXHRcdFx0XHRcdGE6IHIkMVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSByJDEgJiYgbi5wdXNoKHtcblx0XHRcdFx0ZDogZSQxLFxuXHRcdFx0XHRhOiByJDFcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGUkMTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGUsXG5cdFx0XHR1OiB1c2luZy5iaW5kKG51bGwsICExKSxcblx0XHRcdGE6IHVzaW5nLmJpbmQobnVsbCwgITApLFxuXHRcdFx0ZDogZnVuY3Rpb24gZCgpIHtcblx0XHRcdFx0dmFyIG8sIHQgPSB0aGlzLmUsIHMgPSAwO1xuXHRcdFx0XHRmdW5jdGlvbiBuZXh0KCkge1xuXHRcdFx0XHRcdGZvciAoOyBvID0gbi5wb3AoKTspIHRyeSB7XG5cdFx0XHRcdFx0XHRpZiAoIW8uYSAmJiAxID09PSBzKSByZXR1cm4gcyA9IDAsIG4ucHVzaChvKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihuZXh0KTtcblx0XHRcdFx0XHRcdGlmIChvLmQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHIkMSA9IG8uZC5jYWxsKG8udik7XG5cdFx0XHRcdFx0XHRcdGlmIChvLmEpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyJDEpLnRoZW4obmV4dCwgZXJyKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBzIHw9IDE7XG5cdFx0XHRcdFx0fSBjYXRjaCAociQyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyKHIkMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgxID09PSBzKSByZXR1cm4gdCAhPT0gZSA/IFByb21pc2UucmVqZWN0KHQpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdFx0aWYgKHQgIT09IGUpIHRocm93IHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gZXJyKG4kMSkge1xuXHRcdFx0XHRcdHJldHVybiB0ID0gdCAhPT0gZSA/IG5ldyByKG4kMSwgdCkgOiBuJDEsIG5leHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbmV4dCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBfdXNpbmdDdHgsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2FzeW5jSXRlcmFibGUudHNcbnZhciBpbXBvcnRfdXNpbmdDdHgkNCA9IF9fdG9FU00ocmVxdWlyZV91c2luZ0N0eCgpLCAxKTtcbmZ1bmN0aW9uIGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUpIHtcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblx0aWYgKGl0ZXJhdG9yW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKSByZXR1cm4gaXRlcmF0b3I7XG5cdHJldHVybiBtYWtlQXN5bmNSZXNvdXJjZShpdGVyYXRvciwgYXN5bmMgKCkgPT4ge1xuXHRcdGF3YWl0IGl0ZXJhdG9yLnJldHVybj8uKCk7XG5cdH0pO1xufVxuLyoqXG4qIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvbiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IGF1dG9tYXRpY2FsbHkgYWJvcnRzIGFmdGVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4qL1xuYXN5bmMgZnVuY3Rpb24qIHdpdGhNYXhEdXJhdGlvbihpdGVyYWJsZSwgb3B0cykge1xuXHR0cnkge1xuXHRcdHZhciBfdXNpbmdDdHgkMSA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkNC5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4JDEuYShpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKSk7XG5cdFx0Y29uc3QgdGltZXIgPSBfdXNpbmdDdHgkMS51KHRpbWVyUmVzb3VyY2Uob3B0cy5tYXhEdXJhdGlvbk1zKSk7XG5cdFx0Y29uc3QgdGltZXJQcm9taXNlID0gdGltZXIuc3RhcnQoKTtcblx0XHRsZXQgcmVzdWx0O1xuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRyZXN1bHQgPSBhd2FpdCBVbnByb21pc2UucmFjZShbaXRlcmF0b3IubmV4dCgpLCB0aW1lclByb21pc2VdKTtcblx0XHRcdGlmIChyZXN1bHQgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHRocm93QWJvcnRFcnJvcigpO1xuXHRcdFx0aWYgKHJlc3VsdC5kb25lKSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0cmVzdWx0ID0gbnVsbDtcblx0XHR9XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0fSBmaW5hbGx5IHtcblx0XHRhd2FpdCBfdXNpbmdDdHgkMS5kKCk7XG5cdH1cbn1cbi8qKlxuKiBEZXJpdmVzIGEgbmV3IHtAbGluayBBc3luY0dlbmVyYXRvcn0gYmFzZWQgb2Yge0BsaW5rIGl0ZXJhYmxlfSwgdGhhdCB5aWVsZHMgaXRzIGZpcnN0XG4qIHtAbGluayBjb3VudH0gdmFsdWVzLiBUaGVuLCBhIGdyYWNlIHBlcmlvZCBvZiB7QGxpbmsgZ3JhY2VQZXJpb2RNc30gaXMgc3RhcnRlZCBpbiB3aGljaCBmdXJ0aGVyXG4qIHZhbHVlcyBtYXkgc3RpbGwgY29tZSB0aHJvdWdoLiBBZnRlciB0aGlzIHBlcmlvZCwgdGhlIGdlbmVyYXRvciBhYm9ydHMuXG4qL1xuYXN5bmMgZnVuY3Rpb24qIHRha2VXaXRoR3JhY2UoaXRlcmFibGUsIG9wdHMpIHtcblx0dHJ5IHtcblx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkNC5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4My5hKGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUpKTtcblx0XHRsZXQgcmVzdWx0O1xuXHRcdGNvbnN0IHRpbWVyID0gX3VzaW5nQ3R4My51KHRpbWVyUmVzb3VyY2Uob3B0cy5ncmFjZVBlcmlvZE1zKSk7XG5cdFx0bGV0IGNvdW50ID0gb3B0cy5jb3VudDtcblx0XHRsZXQgdGltZXJQcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge30pO1xuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRyZXN1bHQgPSBhd2FpdCBVbnByb21pc2UucmFjZShbaXRlcmF0b3IubmV4dCgpLCB0aW1lclByb21pc2VdKTtcblx0XHRcdGlmIChyZXN1bHQgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHRocm93QWJvcnRFcnJvcigpO1xuXHRcdFx0aWYgKHJlc3VsdC5kb25lKSByZXR1cm4gcmVzdWx0LnZhbHVlO1xuXHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0aWYgKC0tY291bnQgPT09IDApIHRpbWVyUHJvbWlzZSA9IHRpbWVyLnN0YXJ0KCk7XG5cdFx0XHRyZXN1bHQgPSBudWxsO1xuXHRcdH1cblx0fSBjYXRjaCAoXykge1xuXHRcdF91c2luZ0N0eDMuZSA9IF87XG5cdH0gZmluYWxseSB7XG5cdFx0YXdhaXQgX3VzaW5nQ3R4My5kKCk7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdXRpbHMvY3JlYXRlRGVmZXJyZWQudHNcbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkKCkge1xuXHRsZXQgcmVzb2x2ZTtcblx0bGV0IHJlamVjdDtcblx0Y29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdHJlc29sdmUgPSByZXM7XG5cdFx0cmVqZWN0ID0gcmVqO1xuXHR9KTtcblx0cmV0dXJuIHtcblx0XHRwcm9taXNlLFxuXHRcdHJlc29sdmUsXG5cdFx0cmVqZWN0XG5cdH07XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL21lcmdlQXN5bmNJdGVyYWJsZXMudHNcbnZhciBpbXBvcnRfdXNpbmdDdHgkMyA9IF9fdG9FU00ocmVxdWlyZV91c2luZ0N0eCgpLCAxKTtcbmZ1bmN0aW9uIGNyZWF0ZU1hbmFnZWRJdGVyYXRvcihpdGVyYWJsZSwgb25SZXN1bHQpIHtcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblx0bGV0IHN0YXRlID0gXCJpZGxlXCI7XG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0c3RhdGUgPSBcImRvbmVcIjtcblx0XHRvblJlc3VsdCA9ICgpID0+IHt9O1xuXHR9XG5cdGZ1bmN0aW9uIHB1bGwoKSB7XG5cdFx0aWYgKHN0YXRlICE9PSBcImlkbGVcIikgcmV0dXJuO1xuXHRcdHN0YXRlID0gXCJwZW5kaW5nXCI7XG5cdFx0Y29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRuZXh0LnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0aWYgKHJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdHN0YXRlID0gXCJkb25lXCI7XG5cdFx0XHRcdG9uUmVzdWx0KHtcblx0XHRcdFx0XHRzdGF0dXM6IFwicmV0dXJuXCIsXG5cdFx0XHRcdFx0dmFsdWU6IHJlc3VsdC52YWx1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzdGF0ZSA9IFwiaWRsZVwiO1xuXHRcdFx0b25SZXN1bHQoe1xuXHRcdFx0XHRzdGF0dXM6IFwieWllbGRcIixcblx0XHRcdFx0dmFsdWU6IHJlc3VsdC52YWx1ZVxuXHRcdFx0fSk7XG5cdFx0fSkuY2F0Y2goKGNhdXNlKSA9PiB7XG5cdFx0XHRvblJlc3VsdCh7XG5cdFx0XHRcdHN0YXR1czogXCJlcnJvclwiLFxuXHRcdFx0XHRlcnJvcjogY2F1c2Vcblx0XHRcdH0pO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0cHVsbCxcblx0XHRkZXN0cm95OiBhc3luYyAoKSA9PiB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRhd2FpdCBpdGVyYXRvci5yZXR1cm4/LigpO1xuXHRcdH1cblx0fTtcbn1cbi8qKlxuKiBDcmVhdGVzIGEgbmV3IGFzeW5jIGl0ZXJhYmxlIHRoYXQgbWVyZ2VzIG11bHRpcGxlIGFzeW5jIGl0ZXJhYmxlcyBpbnRvIGEgc2luZ2xlIHN0cmVhbS5cbiogVmFsdWVzIGZyb20gdGhlIGlucHV0IGl0ZXJhYmxlcyBhcmUgeWllbGRlZCBpbiB0aGUgb3JkZXIgdGhleSByZXNvbHZlLCBzaW1pbGFyIHRvIFByb21pc2UucmFjZSgpLlxuKlxuKiBOZXcgaXRlcmFibGVzIGNhbiBiZSBhZGRlZCBkeW5hbWljYWxseSB1c2luZyB0aGUgcmV0dXJuZWQge0BsaW5rIE1lcmdlZEFzeW5jSXRlcmFibGVzLmFkZH0gbWV0aG9kLCBldmVuIGFmdGVyIGl0ZXJhdGlvbiBoYXMgc3RhcnRlZC5cbipcbiogSWYgYW55IG9mIHRoZSBpbnB1dCBpdGVyYWJsZXMgdGhyb3dzIGFuIGVycm9yLCB0aGF0IGVycm9yIHdpbGwgYmUgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBtZXJnZWQgc3RyZWFtLlxuKiBPdGhlciBpdGVyYWJsZXMgd2lsbCBub3QgY29udGludWUgdG8gYmUgcHJvY2Vzc2VkLlxuKlxuKiBAdGVtcGxhdGUgVFlpZWxkIFRoZSB0eXBlIG9mIHZhbHVlcyB5aWVsZGVkIGJ5IHRoZSBpbnB1dCBpdGVyYWJsZXNcbiovXG5mdW5jdGlvbiBtZXJnZUFzeW5jSXRlcmFibGVzKCkge1xuXHRsZXQgc3RhdGUgPSBcImlkbGVcIjtcblx0bGV0IGZsdXNoU2lnbmFsID0gY3JlYXRlRGVmZXJyZWQoKTtcblx0LyoqXG5cdCogdXNlZCB3aGlsZSB7QGxpbmsgc3RhdGV9IGlzIGBpZGxlYFxuXHQqL1xuXHRjb25zdCBpdGVyYWJsZXMgPSBbXTtcblx0LyoqXG5cdCogdXNlZCB3aGlsZSB7QGxpbmsgc3RhdGV9IGlzIGBwZW5kaW5nYFxuXHQqL1xuXHRjb25zdCBpdGVyYXRvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuXHRjb25zdCBidWZmZXIgPSBbXTtcblx0ZnVuY3Rpb24gaW5pdEl0ZXJhYmxlKGl0ZXJhYmxlKSB7XG5cdFx0aWYgKHN0YXRlICE9PSBcInBlbmRpbmdcIikgcmV0dXJuO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gY3JlYXRlTWFuYWdlZEl0ZXJhdG9yKGl0ZXJhYmxlLCAocmVzdWx0KSA9PiB7XG5cdFx0XHRpZiAoc3RhdGUgIT09IFwicGVuZGluZ1wiKSByZXR1cm47XG5cdFx0XHRzd2l0Y2ggKHJlc3VsdC5zdGF0dXMpIHtcblx0XHRcdFx0Y2FzZSBcInlpZWxkXCI6XG5cdFx0XHRcdFx0YnVmZmVyLnB1c2goW2l0ZXJhdG9yLCByZXN1bHRdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJldHVyblwiOlxuXHRcdFx0XHRcdGl0ZXJhdG9ycy5kZWxldGUoaXRlcmF0b3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZXJyb3JcIjpcblx0XHRcdFx0XHRidWZmZXIucHVzaChbaXRlcmF0b3IsIHJlc3VsdF0pO1xuXHRcdFx0XHRcdGl0ZXJhdG9ycy5kZWxldGUoaXRlcmF0b3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Zmx1c2hTaWduYWwucmVzb2x2ZSgpO1xuXHRcdH0pO1xuXHRcdGl0ZXJhdG9ycy5hZGQoaXRlcmF0b3IpO1xuXHRcdGl0ZXJhdG9yLnB1bGwoKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGFkZChpdGVyYWJsZSkge1xuXHRcdFx0c3dpdGNoIChzdGF0ZSkge1xuXHRcdFx0XHRjYXNlIFwiaWRsZVwiOlxuXHRcdFx0XHRcdGl0ZXJhYmxlcy5wdXNoKGl0ZXJhYmxlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInBlbmRpbmdcIjpcblx0XHRcdFx0XHRpbml0SXRlcmFibGUoaXRlcmFibGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZG9uZVwiOiBicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eCQzLmRlZmF1bHQpKCk7XG5cdFx0XHRcdGlmIChzdGF0ZSAhPT0gXCJpZGxlXCIpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpdGVyYXRlIHR3aWNlXCIpO1xuXHRcdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiO1xuXHRcdFx0XHRjb25zdCBfZmluYWxseSA9IF91c2luZ0N0eCQxLmEobWFrZUFzeW5jUmVzb3VyY2Uoe30sIGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRzdGF0ZSA9IFwiZG9uZVwiO1xuXHRcdFx0XHRcdGNvbnN0IGVycm9ycyA9IFtdO1xuXHRcdFx0XHRcdGF3YWl0IFByb21pc2UuYWxsKEFycmF5LmZyb20oaXRlcmF0b3JzLnZhbHVlcygpKS5tYXAoYXN5bmMgKGl0KSA9PiB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCBpdC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRcdFx0XHRlcnJvcnMucHVzaChjYXVzZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdGJ1ZmZlci5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdGl0ZXJhdG9ycy5jbGVhcigpO1xuXHRcdFx0XHRcdGZsdXNoU2lnbmFsLnJlc29sdmUoKTtcblx0XHRcdFx0XHRpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpO1xuXHRcdFx0XHR9KSk7XG5cdFx0XHRcdHdoaWxlIChpdGVyYWJsZXMubGVuZ3RoID4gMCkgaW5pdEl0ZXJhYmxlKGl0ZXJhYmxlcy5zaGlmdCgpKTtcblx0XHRcdFx0d2hpbGUgKGl0ZXJhdG9ycy5zaXplID4gMCkge1xuXHRcdFx0XHRcdGF3YWl0IGZsdXNoU2lnbmFsLnByb21pc2U7XG5cdFx0XHRcdFx0d2hpbGUgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBbaXRlcmF0b3IsIHJlc3VsdF0gPSBidWZmZXIuc2hpZnQoKTtcblx0XHRcdFx0XHRcdHN3aXRjaCAocmVzdWx0LnN0YXR1cykge1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwieWllbGRcIjpcblx0XHRcdFx0XHRcdFx0XHR5aWVsZCByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0aXRlcmF0b3IucHVsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwiZXJyb3JcIjogdGhyb3cgcmVzdWx0LmVycm9yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmbHVzaFNpZ25hbCA9IGNyZWF0ZURlZmVycmVkKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0X3VzaW5nQ3R4JDEuZSA9IF87XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRhd2FpdCBfdXNpbmdDdHgkMS5kKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20udHNcbi8qKlxuKiBDcmVhdGVzIGEgUmVhZGFibGVTdHJlYW0gZnJvbSBhbiBBc3luY0l0ZXJhYmxlLlxuKlxuKiBAcGFyYW0gaXRlcmFibGUgLSBUaGUgc291cmNlIEFzeW5jSXRlcmFibGUgdG8gc3RyZWFtIGZyb21cbiogQHJldHVybnMgQSBSZWFkYWJsZVN0cmVhbSB0aGF0IHlpZWxkcyB2YWx1ZXMgZnJvbSB0aGUgQXN5bmNJdGVyYWJsZVxuKi9cbmZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtRnJvbShpdGVyYWJsZSkge1xuXHRjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuXHRyZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRhc3luYyBjYW5jZWwoKSB7XG5cdFx0XHRhd2FpdCBpdGVyYXRvci5yZXR1cm4/LigpO1xuXHRcdH0sXG5cdFx0YXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy93aXRoUGluZy50c1xudmFyIGltcG9ydF91c2luZ0N0eCQyID0gX190b0VTTShyZXF1aXJlX3VzaW5nQ3R4KCksIDEpO1xuY29uc3QgUElOR19TWU0gPSBTeW1ib2woXCJwaW5nXCIpO1xuLyoqXG4qIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvZiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IHlpZWxkcyB7QGxpbmsgUElOR19TWU19XG4qIHdoZW5ldmVyIG5vIHZhbHVlIGhhcyBiZWVuIHlpZWxkZWQgZm9yIHtAbGluayBwaW5nSW50ZXJ2YWxNc30uXG4qL1xuYXN5bmMgZnVuY3Rpb24qIHdpdGhQaW5nKGl0ZXJhYmxlLCBwaW5nSW50ZXJ2YWxNcykge1xuXHR0cnkge1xuXHRcdHZhciBfdXNpbmdDdHgkMSA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMi5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4JDEuYShpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKSk7XG5cdFx0bGV0IHJlc3VsdDtcblx0XHRsZXQgbmV4dFByb21pc2UgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0d2hpbGUgKHRydWUpIHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMi5kZWZhdWx0KSgpO1xuXHRcdFx0Y29uc3QgcGluZ1Byb21pc2UgPSBfdXNpbmdDdHgzLnUodGltZXJSZXNvdXJjZShwaW5nSW50ZXJ2YWxNcykpO1xuXHRcdFx0cmVzdWx0ID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW25leHRQcm9taXNlLCBwaW5nUHJvbWlzZS5zdGFydCgpXSk7XG5cdFx0XHRpZiAocmVzdWx0ID09PSBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0KSB7XG5cdFx0XHRcdHlpZWxkIFBJTkdfU1lNO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChyZXN1bHQuZG9uZSkgcmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdG5leHRQcm9taXNlID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0cmVzdWx0ID0gbnVsbDtcblx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRfdXNpbmdDdHgzLmUgPSBfO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRfdXNpbmdDdHgzLmQoKTtcblx0XHR9XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0fSBmaW5hbGx5IHtcblx0XHRhd2FpdCBfdXNpbmdDdHgkMS5kKCk7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vanNvbmwudHNcbnZhciBpbXBvcnRfdXNpbmdDdHgkMSA9IF9fdG9FU00ocmVxdWlyZV91c2luZ0N0eCgpLCAxKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5jb25zdCBDSFVOS19WQUxVRV9UWVBFX1BST01JU0UgPSAwO1xuY29uc3QgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRSA9IDE7XG5jb25zdCBQUk9NSVNFX1NUQVRVU19GVUxGSUxMRUQgPSAwO1xuY29uc3QgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQgPSAxO1xuY29uc3QgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1JFVFVSTiA9IDA7XG5jb25zdCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQgPSAxO1xuY29uc3QgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SID0gMjtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBpc0Z1bmN0aW9uKHZhbHVlKSkgJiYgdHlwZW9mIHZhbHVlPy5bXCJ0aGVuXCJdID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlPy5bXCJjYXRjaFwiXSA9PT0gXCJmdW5jdGlvblwiO1xufVxudmFyIE1heERlcHRoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IocGF0aCkge1xuXHRcdHN1cGVyKFwiTWF4IGRlcHRoIHJlYWNoZWQgYXQgcGF0aDogXCIgKyBwYXRoLmpvaW4oXCIuXCIpKTtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHR9XG59O1xuYXN5bmMgZnVuY3Rpb24qIGNyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIob3B0cykge1xuXHRjb25zdCB7IGRhdGEgfSA9IG9wdHM7XG5cdGxldCBjb3VudGVyID0gMDtcblx0Y29uc3QgcGxhY2Vob2xkZXIgPSAwO1xuXHRjb25zdCBtZXJnZWRJdGVyYWJsZXMgPSBtZXJnZUFzeW5jSXRlcmFibGVzKCk7XG5cdGZ1bmN0aW9uIHJlZ2lzdGVyQXN5bmMoY2FsbGJhY2spIHtcblx0XHRjb25zdCBpZHggPSBjb3VudGVyKys7XG5cdFx0Y29uc3QgaXRlcmFibGUkMSA9IGNhbGxiYWNrKGlkeCk7XG5cdFx0bWVyZ2VkSXRlcmFibGVzLmFkZChpdGVyYWJsZSQxKTtcblx0XHRyZXR1cm4gaWR4O1xuXHR9XG5cdGZ1bmN0aW9uIGVuY29kZVByb21pc2UocHJvbWlzZSwgcGF0aCkge1xuXHRcdHJldHVybiByZWdpc3RlckFzeW5jKGFzeW5jIGZ1bmN0aW9uKiAoaWR4KSB7XG5cdFx0XHRjb25zdCBlcnJvciA9IGNoZWNrTWF4RGVwdGgocGF0aCk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0cHJvbWlzZS5jYXRjaCgoY2F1c2UpID0+IHtcblx0XHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgbmV4dCA9IGF3YWl0IHByb21pc2U7XG5cdFx0XHRcdHlpZWxkIFtcblx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0UFJPTUlTRV9TVEFUVVNfRlVMRklMTEVELFxuXHRcdFx0XHRcdGVuY29kZShuZXh0LCBwYXRoKVxuXHRcdFx0XHRdO1xuXHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0b3B0cy5vbkVycm9yPy4oe1xuXHRcdFx0XHRcdGVycm9yOiBjYXVzZSxcblx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFBST01JU0VfU1RBVFVTX1JFSkVDVEVELFxuXHRcdFx0XHRcdG9wdHMuZm9ybWF0RXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRmdW5jdGlvbiBlbmNvZGVBc3luY0l0ZXJhYmxlKGl0ZXJhYmxlJDEsIHBhdGgpIHtcblx0XHRyZXR1cm4gcmVnaXN0ZXJBc3luYyhhc3luYyBmdW5jdGlvbiogKGlkeCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eCQxLmRlZmF1bHQpKCk7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gY2hlY2tNYXhEZXB0aChwYXRoKTtcblx0XHRcdFx0aWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdFx0Y29uc3QgaXRlcmF0b3IgPSBfdXNpbmdDdHgkMS5hKGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUkMSkpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXh0ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0XHRcdFx0aWYgKG5leHQuZG9uZSkge1xuXHRcdFx0XHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0XHRcdEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk4sXG5cdFx0XHRcdFx0XHRcdFx0ZW5jb2RlKG5leHQudmFsdWUsIHBhdGgpXG5cdFx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0eWllbGQgW1xuXHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdEFTWU5DX0lURVJBQkxFX1NUQVRVU19ZSUVMRCxcblx0XHRcdFx0XHRcdFx0ZW5jb2RlKG5leHQudmFsdWUsIHBhdGgpXG5cdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0eWllbGQgW1xuXHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0QVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SLFxuXHRcdFx0XHRcdFx0b3B0cy5mb3JtYXRFcnJvcj8uKHtcblx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNhdXNlLFxuXHRcdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0X3VzaW5nQ3R4JDEuZSA9IF87XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRhd2FpdCBfdXNpbmdDdHgkMS5kKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0ZnVuY3Rpb24gY2hlY2tNYXhEZXB0aChwYXRoKSB7XG5cdFx0aWYgKG9wdHMubWF4RGVwdGggJiYgcGF0aC5sZW5ndGggPiBvcHRzLm1heERlcHRoKSByZXR1cm4gbmV3IE1heERlcHRoRXJyb3IocGF0aCk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gZW5jb2RlQXN5bmModmFsdWUsIHBhdGgpIHtcblx0XHRpZiAoaXNQcm9taXNlKHZhbHVlKSkgcmV0dXJuIFtDSFVOS19WQUxVRV9UWVBFX1BST01JU0UsIGVuY29kZVByb21pc2UodmFsdWUsIHBhdGgpXTtcblx0XHRpZiAoaXNBc3luY0l0ZXJhYmxlKHZhbHVlKSkge1xuXHRcdFx0aWYgKG9wdHMubWF4RGVwdGggJiYgcGF0aC5sZW5ndGggPj0gb3B0cy5tYXhEZXB0aCkgdGhyb3cgbmV3IEVycm9yKFwiTWF4IGRlcHRoIHJlYWNoZWRcIik7XG5cdFx0XHRyZXR1cm4gW0NIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEUsIGVuY29kZUFzeW5jSXRlcmFibGUodmFsdWUsIHBhdGgpXTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBwYXRoKSB7XG5cdFx0aWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiBbW11dO1xuXHRcdGNvbnN0IHJlZyA9IGVuY29kZUFzeW5jKHZhbHVlLCBwYXRoKTtcblx0XHRpZiAocmVnKSByZXR1cm4gW1twbGFjZWhvbGRlcl0sIFtudWxsLCAuLi5yZWddXTtcblx0XHRpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSByZXR1cm4gW1t2YWx1ZV1dO1xuXHRcdGNvbnN0IG5ld09iaiA9IHt9O1xuXHRcdGNvbnN0IGFzeW5jVmFsdWVzID0gW107XG5cdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcblx0XHRcdGNvbnN0IHRyYW5zZm9ybWVkID0gZW5jb2RlQXN5bmMoaXRlbSwgWy4uLnBhdGgsIGtleV0pO1xuXHRcdFx0aWYgKCF0cmFuc2Zvcm1lZCkge1xuXHRcdFx0XHRuZXdPYmpba2V5XSA9IGl0ZW07XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0bmV3T2JqW2tleV0gPSBwbGFjZWhvbGRlcjtcblx0XHRcdGFzeW5jVmFsdWVzLnB1c2goW2tleSwgLi4udHJhbnNmb3JtZWRdKTtcblx0XHR9XG5cdFx0cmV0dXJuIFtbbmV3T2JqXSwgLi4uYXN5bmNWYWx1ZXNdO1xuXHR9XG5cdGNvbnN0IG5ld0hlYWQgPSB7fTtcblx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkgbmV3SGVhZFtrZXldID0gZW5jb2RlKGl0ZW0sIFtrZXldKTtcblx0eWllbGQgbmV3SGVhZDtcblx0bGV0IGl0ZXJhYmxlID0gbWVyZ2VkSXRlcmFibGVzO1xuXHRpZiAob3B0cy5waW5nTXMpIGl0ZXJhYmxlID0gd2l0aFBpbmcobWVyZ2VkSXRlcmFibGVzLCBvcHRzLnBpbmdNcyk7XG5cdGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHlpZWxkIHZhbHVlO1xufVxuLyoqXG4qIEpTT04gTGluZXMgc3RyZWFtIHByb2R1Y2VyXG4qIEBzZWUgaHR0cHM6Ly9qc29ubGluZXMub3JnL1xuKi9cbmZ1bmN0aW9uIGpzb25sU3RyZWFtUHJvZHVjZXIob3B0cykge1xuXHRsZXQgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGNyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIob3B0cykpO1xuXHRjb25zdCB7IHNlcmlhbGl6ZSB9ID0gb3B0cztcblx0aWYgKHNlcmlhbGl6ZSkgc3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRpZiAoY2h1bmsgPT09IFBJTkdfU1lNKSBjb250cm9sbGVyLmVucXVldWUoUElOR19TWU0pO1xuXHRcdGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHNlcmlhbGl6ZShjaHVuaykpO1xuXHR9IH0pKTtcblx0cmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHsgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG5cdFx0aWYgKGNodW5rID09PSBQSU5HX1NZTSkgY29udHJvbGxlci5lbnF1ZXVlKFwiIFwiKTtcblx0XHRlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZShKU09OLnN0cmluZ2lmeShjaHVuaykgKyBcIlxcblwiKTtcblx0fSB9KSkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xufVxudmFyIEFzeW5jRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoZGF0YSkge1xuXHRcdHN1cGVyKFwiUmVjZWl2ZWQgZXJyb3IgZnJvbSBzZXJ2ZXJcIik7XG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0fVxufTtcbmNvbnN0IG5vZGVKc1N0cmVhbVRvUmVhZGVyRXNxdWUgPSAoc291cmNlKSA9PiB7XG5cdHJldHVybiB7IGdldFJlYWRlcigpIHtcblx0XHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRzb3VyY2Uub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuXHRcdFx0fSk7XG5cdFx0XHRzb3VyY2Uub24oXCJlbmRcIiwgKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHR9KTtcblx0XHRcdHNvdXJjZS5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVycm9yKGVycm9yKTtcblx0XHRcdH0pO1xuXHRcdH0gfSk7XG5cdFx0cmV0dXJuIHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0fSB9O1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmVBY2N1bXVsYXRvcihmcm9tKSB7XG5cdGNvbnN0IHJlYWRlciA9IFwiZ2V0UmVhZGVyXCIgaW4gZnJvbSA/IGZyb20uZ2V0UmVhZGVyKCkgOiBub2RlSnNTdHJlYW1Ub1JlYWRlckVzcXVlKGZyb20pLmdldFJlYWRlcigpO1xuXHRsZXQgbGluZUFnZ3JlZ2F0ZSA9IFwiXCI7XG5cdHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuXHRcdGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuXHRcdFx0Y29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblx0XHRcdGlmIChkb25lKSBjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG5cdFx0fSxcblx0XHRjYW5jZWwoKSB7XG5cdFx0XHRyZXR1cm4gcmVhZGVyLmNhbmNlbCgpO1xuXHRcdH1cblx0fSkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRsaW5lQWdncmVnYXRlICs9IGNodW5rO1xuXHRcdGNvbnN0IHBhcnRzID0gbGluZUFnZ3JlZ2F0ZS5zcGxpdChcIlxcblwiKTtcblx0XHRsaW5lQWdncmVnYXRlID0gcGFydHMucG9wKCkgPz8gXCJcIjtcblx0XHRmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcblx0fSB9KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb25zdW1lclN0cmVhbShmcm9tKSB7XG5cdGNvbnN0IHN0cmVhbSA9IGNyZWF0ZUxpbmVBY2N1bXVsYXRvcihmcm9tKTtcblx0bGV0IHNlbnRIZWFkID0gZmFsc2U7XG5cdHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh7IHRyYW5zZm9ybShsaW5lLCBjb250cm9sbGVyKSB7XG5cdFx0aWYgKCFzZW50SGVhZCkge1xuXHRcdFx0Y29uc3QgaGVhZCA9IEpTT04ucGFyc2UobGluZSk7XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUoaGVhZCk7XG5cdFx0XHRzZW50SGVhZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGNodW5rID0gSlNPTi5wYXJzZShsaW5lKTtcblx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG5cdFx0fVxuXHR9IH0pKTtcbn1cbi8qKlxuKiBDcmVhdGVzIGEgaGFuZGxlciBmb3IgbWFuYWdpbmcgc3RyZWFtIGNvbnRyb2xsZXJzIGFuZCB0aGVpciBsaWZlY3ljbGVcbiovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1zTWFuYWdlcihhYm9ydENvbnRyb2xsZXIpIHtcblx0Y29uc3QgY29udHJvbGxlck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5cdC8qKlxuXHQqIENoZWNrcyBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBjb250cm9sbGVycyBvciBkZWZlcnJlZCBwcm9taXNlc1xuXHQqL1xuXHRmdW5jdGlvbiBpc0VtcHR5KCkge1xuXHRcdHJldHVybiBBcnJheS5mcm9tKGNvbnRyb2xsZXJNYXAudmFsdWVzKCkpLmV2ZXJ5KChjKSA9PiBjLmNsb3NlZCk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIHN0cmVhbSBjb250cm9sbGVyXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbUNvbnRyb2xsZXIoKSB7XG5cdFx0bGV0IG9yaWdpbmFsQ29udHJvbGxlcjtcblx0XHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRvcmlnaW5hbENvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdH0gfSk7XG5cdFx0Y29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHtcblx0XHRcdGVucXVldWU6ICh2KSA9PiBvcmlnaW5hbENvbnRyb2xsZXIuZW5xdWV1ZSh2KSxcblx0XHRcdGNsb3NlOiAoKSA9PiB7XG5cdFx0XHRcdG9yaWdpbmFsQ29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRjbGVhcigpO1xuXHRcdFx0XHRpZiAoaXNFbXB0eSgpKSBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcblx0XHRcdH0sXG5cdFx0XHRjbG9zZWQ6IGZhbHNlLFxuXHRcdFx0Z2V0UmVhZGVyUmVzb3VyY2U6ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuXHRcdFx0XHRyZXR1cm4gbWFrZVJlc291cmNlKHJlYWRlciwgKCkgPT4ge1xuXHRcdFx0XHRcdHJlYWRlci5yZWxlYXNlTG9jaygpO1xuXHRcdFx0XHRcdHN0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IChyZWFzb24pID0+IHtcblx0XHRcdFx0b3JpZ2luYWxDb250cm9sbGVyLmVycm9yKHJlYXNvbik7XG5cdFx0XHRcdGNsZWFyKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRmdW5jdGlvbiBjbGVhcigpIHtcblx0XHRcdE9iamVjdC5hc3NpZ24oc3RyZWFtQ29udHJvbGxlciwge1xuXHRcdFx0XHRjbG9zZWQ6IHRydWUsXG5cdFx0XHRcdGNsb3NlOiAoKSA9PiB7fSxcblx0XHRcdFx0ZW5xdWV1ZTogKCkgPT4ge30sXG5cdFx0XHRcdGdldFJlYWRlclJlc291cmNlOiBudWxsLFxuXHRcdFx0XHRlcnJvcjogKCkgPT4ge31cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyZWFtQ29udHJvbGxlcjtcblx0fVxuXHQvKipcblx0KiBHZXRzIG9yIGNyZWF0ZXMgYSBzdHJlYW0gY29udHJvbGxlclxuXHQqL1xuXHRmdW5jdGlvbiBnZXRPckNyZWF0ZShjaHVua0lkKSB7XG5cdFx0bGV0IGMgPSBjb250cm9sbGVyTWFwLmdldChjaHVua0lkKTtcblx0XHRpZiAoIWMpIHtcblx0XHRcdGMgPSBjcmVhdGVTdHJlYW1Db250cm9sbGVyKCk7XG5cdFx0XHRjb250cm9sbGVyTWFwLnNldChjaHVua0lkLCBjKTtcblx0XHR9XG5cdFx0cmV0dXJuIGM7XG5cdH1cblx0LyoqXG5cdCogQ2FuY2VscyBhbGwgcGVuZGluZyBjb250cm9sbGVycyBhbmQgcmVqZWN0cyBkZWZlcnJlZCBwcm9taXNlc1xuXHQqL1xuXHRmdW5jdGlvbiBjYW5jZWxBbGwocmVhc29uKSB7XG5cdFx0Zm9yIChjb25zdCBjb250cm9sbGVyIG9mIGNvbnRyb2xsZXJNYXAudmFsdWVzKCkpIGNvbnRyb2xsZXIuZXJyb3IocmVhc29uKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGdldE9yQ3JlYXRlLFxuXHRcdGlzRW1wdHksXG5cdFx0Y2FuY2VsQWxsXG5cdH07XG59XG4vKipcbiogSlNPTiBMaW5lcyBzdHJlYW0gY29uc3VtZXJcbiogQHNlZSBodHRwczovL2pzb25saW5lcy5vcmcvXG4qL1xuYXN5bmMgZnVuY3Rpb24ganNvbmxTdHJlYW1Db25zdW1lcihvcHRzKSB7XG5cdGNvbnN0IHsgZGVzZXJpYWxpemUgPSAodikgPT4gdiB9ID0gb3B0cztcblx0bGV0IHNvdXJjZSA9IGNyZWF0ZUNvbnN1bWVyU3RyZWFtKG9wdHMuZnJvbSk7XG5cdGlmIChkZXNlcmlhbGl6ZSkgc291cmNlID0gc291cmNlLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRjb250cm9sbGVyLmVucXVldWUoZGVzZXJpYWxpemUoY2h1bmspKTtcblx0fSB9KSk7XG5cdGxldCBoZWFkRGVmZXJyZWQgPSBjcmVhdGVEZWZlcnJlZCgpO1xuXHRjb25zdCBzdHJlYW1NYW5hZ2VyID0gY3JlYXRlU3RyZWFtc01hbmFnZXIob3B0cy5hYm9ydENvbnRyb2xsZXIpO1xuXHRmdW5jdGlvbiBkZWNvZGVDaHVua0RlZmluaXRpb24odmFsdWUpIHtcblx0XHRjb25zdCBbX3BhdGgsIHR5cGUsIGNodW5rSWRdID0gdmFsdWU7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IHN0cmVhbU1hbmFnZXIuZ2V0T3JDcmVhdGUoY2h1bmtJZCk7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIENIVU5LX1ZBTFVFX1RZUEVfUFJPTUlTRTogcmV0dXJuIHJ1bihhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIF91c2luZ0N0eDMgPSAoMCwgaW1wb3J0X3VzaW5nQ3R4JDEuZGVmYXVsdCkoKTtcblx0XHRcdFx0XHRjb25zdCByZWFkZXIgPSBfdXNpbmdDdHgzLnUoY29udHJvbGxlci5nZXRSZWFkZXJSZXNvdXJjZSgpKTtcblx0XHRcdFx0XHRjb25zdCB7IHZhbHVlOiB2YWx1ZSQxIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXHRcdFx0XHRcdGNvbnN0IFtfY2h1bmtJZCwgc3RhdHVzLCBkYXRhXSA9IHZhbHVlJDE7XG5cdFx0XHRcdFx0c3dpdGNoIChzdGF0dXMpIHtcblx0XHRcdFx0XHRcdGNhc2UgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEOiByZXR1cm4gZGVjb2RlKGRhdGEpO1xuXHRcdFx0XHRcdFx0Y2FzZSBQUk9NSVNFX1NUQVRVU19SRUpFQ1RFRDogdGhyb3cgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGRhdGEgfSkgPz8gbmV3IEFzeW5jRXJyb3IoZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRcdFx0X3VzaW5nQ3R4My5lID0gXztcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRfdXNpbmdDdHgzLmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRjYXNlIENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEU6IHJldHVybiBydW4oYXN5bmMgZnVuY3Rpb24qICgpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgX3VzaW5nQ3R4NCA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMS5kZWZhdWx0KSgpO1xuXHRcdFx0XHRcdGNvbnN0IHJlYWRlciA9IF91c2luZ0N0eDQudShjb250cm9sbGVyLmdldFJlYWRlclJlc291cmNlKCkpO1xuXHRcdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB7IHZhbHVlOiB2YWx1ZSQxIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXHRcdFx0XHRcdFx0Y29uc3QgW19jaHVua0lkLCBzdGF0dXMsIGRhdGFdID0gdmFsdWUkMTtcblx0XHRcdFx0XHRcdHN3aXRjaCAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1lJRUxEOlxuXHRcdFx0XHRcdFx0XHRcdHlpZWxkIGRlY29kZShkYXRhKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOOiByZXR1cm4gZGVjb2RlKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRjYXNlIEFTWU5DX0lURVJBQkxFX1NUQVRVU19FUlJPUjogdGhyb3cgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGRhdGEgfSkgPz8gbmV3IEFzeW5jRXJyb3IoZGF0YSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRcdFx0X3VzaW5nQ3R4NC5lID0gXztcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRfdXNpbmdDdHg0LmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGRlY29kZSh2YWx1ZSkge1xuXHRcdGNvbnN0IFtbZGF0YV0sIC4uLmFzeW5jUHJvcHNdID0gdmFsdWU7XG5cdFx0Zm9yIChjb25zdCB2YWx1ZSQxIG9mIGFzeW5jUHJvcHMpIHtcblx0XHRcdGNvbnN0IFtrZXldID0gdmFsdWUkMTtcblx0XHRcdGNvbnN0IGRlY29kZWQgPSBkZWNvZGVDaHVua0RlZmluaXRpb24odmFsdWUkMSk7XG5cdFx0XHRpZiAoa2V5ID09PSBudWxsKSByZXR1cm4gZGVjb2RlZDtcblx0XHRcdGRhdGFba2V5XSA9IGRlY29kZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGNvbnN0IGNsb3NlT3JBYm9ydCA9IChyZWFzb24pID0+IHtcblx0XHRoZWFkRGVmZXJyZWQ/LnJlamVjdChyZWFzb24pO1xuXHRcdHN0cmVhbU1hbmFnZXIuY2FuY2VsQWxsKHJlYXNvbik7XG5cdH07XG5cdHNvdXJjZS5waXBlVG8obmV3IFdyaXRhYmxlU3RyZWFtKHtcblx0XHR3cml0ZShjaHVua09ySGVhZCkge1xuXHRcdFx0aWYgKGhlYWREZWZlcnJlZCkge1xuXHRcdFx0XHRjb25zdCBoZWFkID0gY2h1bmtPckhlYWQ7XG5cdFx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNodW5rT3JIZWFkKSkge1xuXHRcdFx0XHRcdGNvbnN0IHBhcnNlZCA9IGRlY29kZSh2YWx1ZSk7XG5cdFx0XHRcdFx0aGVhZFtrZXldID0gcGFyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhlYWREZWZlcnJlZC5yZXNvbHZlKGhlYWQpO1xuXHRcdFx0XHRoZWFkRGVmZXJyZWQgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjaHVuayA9IGNodW5rT3JIZWFkO1xuXHRcdFx0Y29uc3QgW2lkeF0gPSBjaHVuaztcblx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW1NYW5hZ2VyLmdldE9yQ3JlYXRlKGlkeCk7XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuXHRcdH0sXG5cdFx0Y2xvc2U6ICgpID0+IGNsb3NlT3JBYm9ydChuZXcgRXJyb3IoXCJTdHJlYW0gY2xvc2VkXCIpKSxcblx0XHRhYm9ydDogY2xvc2VPckFib3J0XG5cdH0pLCB7IHNpZ25hbDogb3B0cy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdG9wdHMub25FcnJvcj8uKHsgZXJyb3IgfSk7XG5cdFx0Y2xvc2VPckFib3J0KGVycm9yKTtcblx0fSk7XG5cdHJldHVybiBbYXdhaXQgaGVhZERlZmVycmVkLnByb21pc2UsIHN0cmVhbU1hbmFnZXJdO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS9zc2UudHNcbnZhciBpbXBvcnRfdXNpbmdDdHggPSBfX3RvRVNNKHJlcXVpcmVfdXNpbmdDdHgoKSwgMSk7XG5jb25zdCBQSU5HX0VWRU5UID0gXCJwaW5nXCI7XG5jb25zdCBTRVJJQUxJWkVEX0VSUk9SX0VWRU5UID0gXCJzZXJpYWxpemVkLWVycm9yXCI7XG5jb25zdCBDT05ORUNURURfRVZFTlQgPSBcImNvbm5lY3RlZFwiO1xuY29uc3QgUkVUVVJOX0VWRU5UID0gXCJyZXR1cm5cIjtcbi8qKlxuKlxuKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sXG4qL1xuZnVuY3Rpb24gc3NlU3RyZWFtUHJvZHVjZXIob3B0cykge1xuXHRjb25zdCB7IHNlcmlhbGl6ZSA9IGlkZW50aXR5IH0gPSBvcHRzO1xuXHRjb25zdCBwaW5nID0ge1xuXHRcdGVuYWJsZWQ6IG9wdHMucGluZz8uZW5hYmxlZCA/PyBmYWxzZSxcblx0XHRpbnRlcnZhbE1zOiBvcHRzLnBpbmc/LmludGVydmFsTXMgPz8gMWUzXG5cdH07XG5cdGNvbnN0IGNsaWVudCA9IG9wdHMuY2xpZW50ID8/IHt9O1xuXHRpZiAocGluZy5lbmFibGVkICYmIGNsaWVudC5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcyAmJiBwaW5nLmludGVydmFsTXMgPiBjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXMpIHRocm93IG5ldyBFcnJvcihgUGluZyBpbnRlcnZhbCBtdXN0IGJlIGxlc3MgdGhhbiBjbGllbnQgcmVjb25uZWN0IGludGVydmFsIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVjb25uZWN0aW9uIC0gcGluZy5pbnRlcnZhbE1zOiAke3BpbmcuaW50ZXJ2YWxNc30gY2xpZW50LnJlY29ubmVjdEFmdGVySW5hY3Rpdml0eU1zOiAke2NsaWVudC5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNc31gKTtcblx0YXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcblx0XHR5aWVsZCB7XG5cdFx0XHRldmVudDogQ09OTkVDVEVEX0VWRU5ULFxuXHRcdFx0ZGF0YTogSlNPTi5zdHJpbmdpZnkoY2xpZW50KVxuXHRcdH07XG5cdFx0bGV0IGl0ZXJhYmxlID0gb3B0cy5kYXRhO1xuXHRcdGlmIChvcHRzLmVtaXRBbmRFbmRJbW1lZGlhdGVseSkgaXRlcmFibGUgPSB0YWtlV2l0aEdyYWNlKGl0ZXJhYmxlLCB7XG5cdFx0XHRjb3VudDogMSxcblx0XHRcdGdyYWNlUGVyaW9kTXM6IDFcblx0XHR9KTtcblx0XHRpZiAob3B0cy5tYXhEdXJhdGlvbk1zICYmIG9wdHMubWF4RHVyYXRpb25NcyA+IDAgJiYgb3B0cy5tYXhEdXJhdGlvbk1zICE9PSBJbmZpbml0eSkgaXRlcmFibGUgPSB3aXRoTWF4RHVyYXRpb24oaXRlcmFibGUsIHsgbWF4RHVyYXRpb25Nczogb3B0cy5tYXhEdXJhdGlvbk1zIH0pO1xuXHRcdGlmIChwaW5nLmVuYWJsZWQgJiYgcGluZy5pbnRlcnZhbE1zICE9PSBJbmZpbml0eSAmJiBwaW5nLmludGVydmFsTXMgPiAwKSBpdGVyYWJsZSA9IHdpdGhQaW5nKGl0ZXJhYmxlLCBwaW5nLmludGVydmFsTXMpO1xuXHRcdGxldCB2YWx1ZTtcblx0XHRsZXQgY2h1bms7XG5cdFx0Zm9yIGF3YWl0ICh2YWx1ZSBvZiBpdGVyYWJsZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSBQSU5HX1NZTSkge1xuXHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0ZXZlbnQ6IFBJTkdfRVZFTlQsXG5cdFx0XHRcdFx0ZGF0YTogXCJcIlxuXHRcdFx0XHR9O1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGNodW5rID0gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpID8ge1xuXHRcdFx0XHRpZDogdmFsdWVbMF0sXG5cdFx0XHRcdGRhdGE6IHZhbHVlWzFdXG5cdFx0XHR9IDogeyBkYXRhOiB2YWx1ZSB9O1xuXHRcdFx0Y2h1bmsuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZShjaHVuay5kYXRhKSk7XG5cdFx0XHR5aWVsZCBjaHVuaztcblx0XHRcdHZhbHVlID0gbnVsbDtcblx0XHRcdGNodW5rID0gbnVsbDtcblx0XHR9XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkge1xuXHRcdHRyeSB7XG5cdFx0XHR5aWVsZCogZ2VuZXJhdG9yKCk7XG5cdFx0XHR5aWVsZCB7XG5cdFx0XHRcdGV2ZW50OiBSRVRVUk5fRVZFTlQsXG5cdFx0XHRcdGRhdGE6IFwiXCJcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdGlmIChpc0Fib3J0RXJyb3IoY2F1c2UpKSByZXR1cm47XG5cdFx0XHRjb25zdCBlcnJvciA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKTtcblx0XHRcdGNvbnN0IGRhdGEgPSBvcHRzLmZvcm1hdEVycm9yPy4oeyBlcnJvciB9KSA/PyBudWxsO1xuXHRcdFx0eWllbGQge1xuXHRcdFx0XHRldmVudDogU0VSSUFMSVpFRF9FUlJPUl9FVkVOVCxcblx0XHRcdFx0ZGF0YTogSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplKGRhdGEpKVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0Y29uc3Qgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkpO1xuXHRyZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRpZiAoXCJldmVudFwiIGluIGNodW5rKSBjb250cm9sbGVyLmVucXVldWUoYGV2ZW50OiAke2NodW5rLmV2ZW50fVxcbmApO1xuXHRcdGlmIChcImRhdGFcIiBpbiBjaHVuaykgY29udHJvbGxlci5lbnF1ZXVlKGBkYXRhOiAke2NodW5rLmRhdGF9XFxuYCk7XG5cdFx0aWYgKFwiaWRcIiBpbiBjaHVuaykgY29udHJvbGxlci5lbnF1ZXVlKGBpZDogJHtjaHVuay5pZH1cXG5gKTtcblx0XHRpZiAoXCJjb21tZW50XCIgaW4gY2h1bmspIGNvbnRyb2xsZXIuZW5xdWV1ZShgOiAke2NodW5rLmNvbW1lbnR9XFxuYCk7XG5cdFx0Y29udHJvbGxlci5lbnF1ZXVlKFwiXFxuXFxuXCIpO1xuXHR9IH0pKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChvcHRzKSB7XG5cdHRyeSB7XG5cdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eC5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IHRpbWVvdXRQcm9taXNlID0gX3VzaW5nQ3R4JDEudSh0aW1lclJlc291cmNlKG9wdHMudGltZW91dE1zKSk7XG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW29wdHMucHJvbWlzZSwgdGltZW91dFByb21pc2Uuc3RhcnQoKV0pO1xuXHRcdGlmIChyZXMgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHJldHVybiBhd2FpdCBvcHRzLm9uVGltZW91dCgpO1xuXHRcdHJldHVybiByZXM7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0fSBmaW5hbGx5IHtcblx0XHRfdXNpbmdDdHgkMS5kKCk7XG5cdH1cbn1cbi8qKlxuKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sXG4qL1xuZnVuY3Rpb24gc3NlU3RyZWFtQ29uc3VtZXIob3B0cykge1xuXHRjb25zdCB7IGRlc2VyaWFsaXplID0gKHYpID0+IHYgfSA9IG9wdHM7XG5cdGxldCBjbGllbnRPcHRpb25zID0ge307XG5cdGNvbnN0IHNpZ25hbCA9IG9wdHMuc2lnbmFsO1xuXHRsZXQgX2VzID0gbnVsbDtcblx0Y29uc3QgY3JlYXRlU3RyZWFtID0gKCkgPT4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRjb25zdCBbdXJsLCBpbml0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtvcHRzLnVybCgpLCBvcHRzLmluaXQoKV0pO1xuXHRcdFx0Y29uc3QgZXZlbnRTb3VyY2UgPSBfZXMgPSBuZXcgb3B0cy5FdmVudFNvdXJjZSh1cmwsIGluaXQpO1xuXHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0dHlwZTogXCJjb25uZWN0aW5nXCIsXG5cdFx0XHRcdGV2ZW50U291cmNlOiBfZXMsXG5cdFx0XHRcdGV2ZW50OiBudWxsXG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoQ09OTkVDVEVEX0VWRU5ULCAoX21zZykgPT4ge1xuXHRcdFx0XHRjb25zdCBtc2cgPSBfbXNnO1xuXHRcdFx0XHRjb25zdCBvcHRpb25zID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG5cdFx0XHRcdGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwiY29ubmVjdGVkXCIsXG5cdFx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0XHRldmVudFNvdXJjZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0ZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihTRVJJQUxJWkVEX0VSUk9SX0VWRU5ULCAoX21zZykgPT4ge1xuXHRcdFx0XHRjb25zdCBtc2cgPSBfbXNnO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwic2VyaWFsaXplZC1lcnJvclwiLFxuXHRcdFx0XHRcdGVycm9yOiBkZXNlcmlhbGl6ZShKU09OLnBhcnNlKG1zZy5kYXRhKSksXG5cdFx0XHRcdFx0ZXZlbnRTb3VyY2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoUElOR19FVkVOVCwgKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwicGluZ1wiLFxuXHRcdFx0XHRcdGV2ZW50U291cmNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFJFVFVSTl9FVkVOVCwgKCkgPT4ge1xuXHRcdFx0XHRldmVudFNvdXJjZS5jbG9zZSgpO1xuXHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdF9lcyA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0aWYgKGV2ZW50U291cmNlLnJlYWR5U3RhdGUgPT09IGV2ZW50U291cmNlLkNMT1NFRCkgY29udHJvbGxlci5lcnJvcihldmVudCk7XG5cdFx0XHRcdGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0XHR0eXBlOiBcImNvbm5lY3RpbmdcIixcblx0XHRcdFx0XHRldmVudFNvdXJjZSxcblx0XHRcdFx0XHRldmVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0ZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKF9tc2cpID0+IHtcblx0XHRcdFx0Y29uc3QgbXNnID0gX21zZztcblx0XHRcdFx0Y29uc3QgY2h1bmsgPSBkZXNlcmlhbGl6ZShKU09OLnBhcnNlKG1zZy5kYXRhKSk7XG5cdFx0XHRcdGNvbnN0IGRlZiA9IHsgZGF0YTogY2h1bmsgfTtcblx0XHRcdFx0aWYgKG1zZy5sYXN0RXZlbnRJZCkgZGVmLmlkID0gbXNnLmxhc3RFdmVudElkO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwiZGF0YVwiLFxuXHRcdFx0XHRcdGRhdGE6IGRlZixcblx0XHRcdFx0XHRldmVudFNvdXJjZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3Qgb25BYm9ydCA9ICgpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRldmVudFNvdXJjZS5jbG9zZSgpO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fSBjYXRjaCB7fVxuXHRcdFx0fTtcblx0XHRcdGlmIChzaWduYWwuYWJvcnRlZCkgb25BYm9ydCgpO1xuXHRcdFx0ZWxzZSBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuXHRcdH0sXG5cdFx0Y2FuY2VsKCkge1xuXHRcdFx0X2VzPy5jbG9zZSgpO1xuXHRcdH1cblx0fSk7XG5cdGNvbnN0IGdldFN0cmVhbVJlc291cmNlID0gKCkgPT4ge1xuXHRcdGxldCBzdHJlYW0gPSBjcmVhdGVTdHJlYW0oKTtcblx0XHRsZXQgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuXHRcdGFzeW5jIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG5cdFx0XHRfZXMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFrZUFzeW5jUmVzb3VyY2Uoe1xuXHRcdFx0cmVhZCgpIHtcblx0XHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkKCk7XG5cdFx0XHR9LFxuXHRcdFx0YXN5bmMgcmVjcmVhdGUoKSB7XG5cdFx0XHRcdGF3YWl0IGRpc3Bvc2UoKTtcblx0XHRcdFx0c3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG5cdFx0XHRcdHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0XHRcdH1cblx0XHR9LCBkaXNwb3NlKTtcblx0fTtcblx0cmV0dXJuIHJ1bihhc3luYyBmdW5jdGlvbiogKCkge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHguZGVmYXVsdCkoKTtcblx0XHRcdGNvbnN0IHN0cmVhbSA9IF91c2luZ0N0eDMuYShnZXRTdHJlYW1SZXNvdXJjZSgpKTtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdGxldCBwcm9taXNlID0gc3RyZWFtLnJlYWQoKTtcblx0XHRcdFx0Y29uc3QgdGltZW91dE1zID0gY2xpZW50T3B0aW9ucy5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcztcblx0XHRcdFx0aWYgKHRpbWVvdXRNcykgcHJvbWlzZSA9IHdpdGhUaW1lb3V0KHtcblx0XHRcdFx0XHRwcm9taXNlLFxuXHRcdFx0XHRcdHRpbWVvdXRNcyxcblx0XHRcdFx0XHRvblRpbWVvdXQ6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlcyA9IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInRpbWVvdXRcIixcblx0XHRcdFx0XHRcdFx0XHRtczogdGltZW91dE1zLFxuXHRcdFx0XHRcdFx0XHRcdGV2ZW50U291cmNlOiBfZXNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG9uZTogZmFsc2Vcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRhd2FpdCBzdHJlYW0ucmVjcmVhdGUoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcblx0XHRcdFx0aWYgKHJlc3VsdC5kb25lKSByZXR1cm4gcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHR5aWVsZCByZXN1bHQudmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0X3VzaW5nQ3R4My5lID0gXztcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0YXdhaXQgX3VzaW5nQ3R4My5kKCk7XG5cdFx0fVxuXHR9KTtcbn1cbmNvbnN0IHNzZUhlYWRlcnMgPSB7XG5cdFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcblx0XCJDYWNoZS1Db250cm9sXCI6IFwibm8tY2FjaGUsIG5vLXRyYW5zZm9ybVwiLFxuXHRcIlgtQWNjZWwtQnVmZmVyaW5nXCI6IFwibm9cIixcblx0Q29ubmVjdGlvbjogXCJrZWVwLWFsaXZlXCJcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9yZXNvbHZlUmVzcG9uc2UudHNcbmZ1bmN0aW9uIGVycm9yVG9Bc3luY0l0ZXJhYmxlKGVycikge1xuXHRyZXR1cm4gcnVuKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG5cdFx0dGhyb3cgZXJyO1xuXHR9KTtcbn1cbmNvbnN0IFRZUEVfQUNDRVBURURfTUVUSE9EX01BUCA9IHtcblx0bXV0YXRpb246IFtcIlBPU1RcIl0sXG5cdHF1ZXJ5OiBbXCJHRVRcIl0sXG5cdHN1YnNjcmlwdGlvbjogW1wiR0VUXCJdXG59O1xuY29uc3QgVFlQRV9BQ0NFUFRFRF9NRVRIT0RfTUFQX1dJVEhfTUVUSE9EX09WRVJSSURFID0ge1xuXHRtdXRhdGlvbjogW1wiUE9TVFwiXSxcblx0cXVlcnk6IFtcIkdFVFwiLCBcIlBPU1RcIl0sXG5cdHN1YnNjcmlwdGlvbjogW1wiR0VUXCIsIFwiUE9TVFwiXVxufTtcbmZ1bmN0aW9uIGluaXRSZXNwb25zZShpbml0T3B0cykge1xuXHRjb25zdCB7IGN0eCwgaW5mbywgcmVzcG9uc2VNZXRhLCB1bnRyYW5zZm9ybWVkSlNPTiwgZXJyb3JzID0gW10sIGhlYWRlcnMgfSA9IGluaXRPcHRzO1xuXHRsZXQgc3RhdHVzID0gdW50cmFuc2Zvcm1lZEpTT04gPyBnZXRIVFRQU3RhdHVzQ29kZSh1bnRyYW5zZm9ybWVkSlNPTikgOiAyMDA7XG5cdGNvbnN0IGVhZ2VyR2VuZXJhdGlvbiA9ICF1bnRyYW5zZm9ybWVkSlNPTjtcblx0Y29uc3QgZGF0YSA9IGVhZ2VyR2VuZXJhdGlvbiA/IFtdIDogQXJyYXkuaXNBcnJheSh1bnRyYW5zZm9ybWVkSlNPTikgPyB1bnRyYW5zZm9ybWVkSlNPTiA6IFt1bnRyYW5zZm9ybWVkSlNPTl07XG5cdGNvbnN0IG1ldGEgPSByZXNwb25zZU1ldGE/Lih7XG5cdFx0Y3R4LFxuXHRcdGluZm8sXG5cdFx0cGF0aHM6IGluZm8/LmNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5wYXRoKSxcblx0XHRkYXRhLFxuXHRcdGVycm9ycyxcblx0XHRlYWdlckdlbmVyYXRpb24sXG5cdFx0dHlwZTogaW5mbz8uY2FsbHMuZmluZCgoY2FsbCkgPT4gY2FsbC5wcm9jZWR1cmU/Ll9kZWYudHlwZSk/LnByb2NlZHVyZT8uX2RlZi50eXBlID8/IFwidW5rbm93blwiXG5cdH0pID8/IHt9O1xuXHRpZiAobWV0YS5oZWFkZXJzKSB7XG5cdFx0aWYgKG1ldGEuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1ldGEuaGVhZGVycy5lbnRyaWVzKCkpIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuXHRcdGVsc2VcbiAvKipcblx0XHQqIEBkZXByZWNhdGVkLCBkZWxldGUgaW4gdjEyXG5cdFx0Ki9cblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhLmhlYWRlcnMpKSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkgaGVhZGVycy5hcHBlbmQoa2V5LCB2KTtcblx0XHRlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuXHR9XG5cdGlmIChtZXRhLnN0YXR1cykgc3RhdHVzID0gbWV0YS5zdGF0dXM7XG5cdHJldHVybiB7IHN0YXR1cyB9O1xufVxuZnVuY3Rpb24gY2F1Z2h0RXJyb3JUb0RhdGEoY2F1c2UsIGVycm9yT3B0cykge1xuXHRjb25zdCB7IHJvdXRlciwgcmVxLCBvbkVycm9yIH0gPSBlcnJvck9wdHMub3B0cztcblx0Y29uc3QgZXJyb3IgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSk7XG5cdG9uRXJyb3I/Lih7XG5cdFx0ZXJyb3IsXG5cdFx0cGF0aDogZXJyb3JPcHRzLnBhdGgsXG5cdFx0aW5wdXQ6IGVycm9yT3B0cy5pbnB1dCxcblx0XHRjdHg6IGVycm9yT3B0cy5jdHgsXG5cdFx0dHlwZTogZXJyb3JPcHRzLnR5cGUsXG5cdFx0cmVxXG5cdH0pO1xuXHRjb25zdCB1bnRyYW5zZm9ybWVkSlNPTiA9IHsgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuXHRcdGNvbmZpZzogcm91dGVyLl9kZWYuX2NvbmZpZyxcblx0XHRlcnJvcixcblx0XHR0eXBlOiBlcnJvck9wdHMudHlwZSxcblx0XHRwYXRoOiBlcnJvck9wdHMucGF0aCxcblx0XHRpbnB1dDogZXJyb3JPcHRzLmlucHV0LFxuXHRcdGN0eDogZXJyb3JPcHRzLmN0eFxuXHR9KSB9O1xuXHRjb25zdCB0cmFuc2Zvcm1lZEpTT04gPSB0cmFuc2Zvcm1UUlBDUmVzcG9uc2Uocm91dGVyLl9kZWYuX2NvbmZpZywgdW50cmFuc2Zvcm1lZEpTT04pO1xuXHRjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtZWRKU09OKTtcblx0cmV0dXJuIHtcblx0XHRlcnJvcixcblx0XHR1bnRyYW5zZm9ybWVkSlNPTixcblx0XHRib2R5XG5cdH07XG59XG4vKipcbiogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHN0cmVhbS1saWtlIG9iamVjdFxuKiAtIGlmIGl0J3MgYW4gYXN5bmMgaXRlcmFibGVcbiogLSBpZiBpdCdzIGFuIG9iamVjdCB3aXRoIGFzeW5jIGl0ZXJhYmxlcyBvciBwcm9taXNlc1xuKi9cbmZ1bmN0aW9uIGlzRGF0YVN0cmVhbSh2KSB7XG5cdGlmICghaXNPYmplY3QodikpIHJldHVybiBmYWxzZTtcblx0aWYgKGlzQXN5bmNJdGVyYWJsZSh2KSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBPYmplY3QudmFsdWVzKHYpLnNvbWUoaXNQcm9taXNlKSB8fCBPYmplY3QudmFsdWVzKHYpLnNvbWUoaXNBc3luY0l0ZXJhYmxlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVSZXNwb25zZShvcHRzKSB7XG5cdGNvbnN0IHsgcm91dGVyLCByZXEgfSA9IG9wdHM7XG5cdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhbW1widmFyeVwiLCBcInRycGMtYWNjZXB0XCJdXSk7XG5cdGNvbnN0IGNvbmZpZyA9IHJvdXRlci5fZGVmLl9jb25maWc7XG5cdGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG5cdGlmIChyZXEubWV0aG9kID09PSBcIkhFQURcIikgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogMjA0IH0pO1xuXHRjb25zdCBhbGxvd0JhdGNoaW5nID0gb3B0cy5hbGxvd0JhdGNoaW5nID8/IG9wdHMuYmF0Y2hpbmc/LmVuYWJsZWQgPz8gdHJ1ZTtcblx0Y29uc3QgYWxsb3dNZXRob2RPdmVycmlkZSA9IChvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUgPz8gZmFsc2UpICYmIHJlcS5tZXRob2QgPT09IFwiUE9TVFwiO1xuXHRjb25zdCBpbmZvVHVwbGUgPSBhd2FpdCBydW4oYXN5bmMgKCkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gW3ZvaWQgMCwgYXdhaXQgZ2V0UmVxdWVzdEluZm8oe1xuXHRcdFx0XHRyZXEsXG5cdFx0XHRcdHBhdGg6IGRlY29kZVVSSUNvbXBvbmVudChvcHRzLnBhdGgpLFxuXHRcdFx0XHRyb3V0ZXIsXG5cdFx0XHRcdHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcblx0XHRcdFx0aGVhZGVyczogb3B0cy5yZXEuaGVhZGVycyxcblx0XHRcdFx0dXJsXG5cdFx0XHR9KV07XG5cdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdHJldHVybiBbZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLCB2b2lkIDBdO1xuXHRcdH1cblx0fSk7XG5cdGNvbnN0IGN0eE1hbmFnZXIgPSBydW4oKCkgPT4ge1xuXHRcdGxldCByZXN1bHQgPSB2b2lkIDA7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZhbHVlT3JVbmRlZmluZWQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKCFyZXN1bHQpIHJldHVybiB2b2lkIDA7XG5cdFx0XHRcdHJldHVybiByZXN1bHRbMV07XG5cdFx0XHR9LFxuXHRcdFx0dmFsdWU6ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgW2VyciwgY3R4XSA9IHJlc3VsdDtcblx0XHRcdFx0aWYgKGVycikgdGhyb3cgZXJyO1xuXHRcdFx0XHRyZXR1cm4gY3R4O1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZTogYXN5bmMgKGluZm8pID0+IHtcblx0XHRcdFx0aWYgKHJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSAtIHJlcG9ydCBhIGJ1ZyBpbiB0UlBDXCIpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbnN0IGN0eCA9IGF3YWl0IG9wdHMuY3JlYXRlQ29udGV4dCh7IGluZm8gfSk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gW3ZvaWQgMCwgY3R4XTtcblx0XHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBbZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLCB2b2lkIDBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cdGNvbnN0IG1ldGhvZE1hcHBlciA9IGFsbG93TWV0aG9kT3ZlcnJpZGUgPyBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVBfV0lUSF9NRVRIT0RfT1ZFUlJJREUgOiBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVA7XG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCovXG5cdGNvbnN0IGlzU3RyZWFtQ2FsbCA9IHJlcS5oZWFkZXJzLmdldChcInRycGMtYWNjZXB0XCIpID09PSBcImFwcGxpY2F0aW9uL2pzb25sXCI7XG5cdGNvbnN0IGV4cGVyaW1lbnRhbFNTRSA9IGNvbmZpZy5zc2U/LmVuYWJsZWQgPz8gdHJ1ZTtcblx0dHJ5IHtcblx0XHRjb25zdCBbaW5mb0Vycm9yLCBpbmZvXSA9IGluZm9UdXBsZTtcblx0XHRpZiAoaW5mb0Vycm9yKSB0aHJvdyBpbmZvRXJyb3I7XG5cdFx0aWYgKGluZm8uaXNCYXRjaENhbGwgJiYgIWFsbG93QmF0Y2hpbmcpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0bWVzc2FnZTogYEJhdGNoaW5nIGlzIG5vdCBlbmFibGVkIG9uIHRoZSBzZXJ2ZXJgXG5cdFx0fSk7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuXHRcdGlmIChpc1N0cmVhbUNhbGwgJiYgIWluZm8uaXNCYXRjaENhbGwpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0bWVzc2FnZTogYFN0cmVhbWluZyByZXF1ZXN0cyBtdXN0IGJlIGJhdGNoZWQgKHlvdSBjYW4gZG8gYSBiYXRjaCBvZiAxKWAsXG5cdFx0XHRjb2RlOiBcIkJBRF9SRVFVRVNUXCJcblx0XHR9KTtcblx0XHRhd2FpdCBjdHhNYW5hZ2VyLmNyZWF0ZShpbmZvKTtcblx0XHRjb25zdCBycGNDYWxscyA9IGluZm8uY2FsbHMubWFwKGFzeW5jIChjYWxsKSA9PiB7XG5cdFx0XHRjb25zdCBwcm9jID0gY2FsbC5wcm9jZWR1cmU7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAob3B0cy5lcnJvcikgdGhyb3cgb3B0cy5lcnJvcjtcblx0XHRcdFx0aWYgKCFwcm9jKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRjb2RlOiBcIk5PVF9GT1VORFwiLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGBObyBwcm9jZWR1cmUgZm91bmQgb24gcGF0aCBcIiR7Y2FsbC5wYXRofVwiYFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKCFtZXRob2RNYXBwZXJbcHJvYy5fZGVmLnR5cGVdLmluY2x1ZGVzKHJlcS5tZXRob2QpKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRjb2RlOiBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCIsXG5cdFx0XHRcdFx0bWVzc2FnZTogYFVuc3VwcG9ydGVkICR7cmVxLm1ldGhvZH0tcmVxdWVzdCB0byAke3Byb2MuX2RlZi50eXBlfSBwcm9jZWR1cmUgYXQgcGF0aCBcIiR7Y2FsbC5wYXRofVwiYFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHByb2MuX2RlZi50eXBlID09PSBcInN1YnNjcmlwdGlvblwiKSB7XG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuXHRcdFx0XHRcdGlmIChpbmZvLmlzQmF0Y2hDYWxsKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IGBDYW5ub3QgYmF0Y2ggc3Vic2NyaXB0aW9uIGNhbGxzYFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCBwcm9jKHtcblx0XHRcdFx0XHRwYXRoOiBjYWxsLnBhdGgsXG5cdFx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGNhbGwuZ2V0UmF3SW5wdXQsXG5cdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlKCksXG5cdFx0XHRcdFx0dHlwZTogcHJvYy5fZGVmLnR5cGUsXG5cdFx0XHRcdFx0c2lnbmFsOiBvcHRzLnJlcS5zaWduYWxcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBbdm9pZCAwLCB7IGRhdGEgfV07XG5cdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRjb25zdCBlcnJvciA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKTtcblx0XHRcdFx0Y29uc3QgaW5wdXQgPSBjYWxsLnJlc3VsdCgpO1xuXHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdFx0cGF0aDogY2FsbC5wYXRoLFxuXHRcdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0dHlwZTogY2FsbC5wcm9jZWR1cmU/Ll9kZWYudHlwZSA/PyBcInVua25vd25cIixcblx0XHRcdFx0XHRyZXE6IG9wdHMucmVxXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gW2Vycm9yLCB2b2lkIDBdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmICghaW5mby5pc0JhdGNoQ2FsbCkge1xuXHRcdFx0Y29uc3QgW2NhbGxdID0gaW5mby5jYWxscztcblx0XHRcdGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGF3YWl0IHJwY0NhbGxzWzBdO1xuXHRcdFx0c3dpdGNoIChpbmZvLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcInVua25vd25cIjpcblx0XHRcdFx0Y2FzZSBcIm11dGF0aW9uXCI6XG5cdFx0XHRcdGNhc2UgXCJxdWVyeVwiOiB7XG5cdFx0XHRcdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdFx0XHRcdGlmIChpc0RhdGFTdHJlYW0ocmVzdWx0Py5kYXRhKSkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0XHRjb2RlOiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IFwiQ2Fubm90IHVzZSBzdHJlYW0tbGlrZSByZXNwb25zZSBpbiBub24tc3RyZWFtaW5nIHJlcXVlc3QgLSB1c2UgaHR0cEJhdGNoU3RyZWFtTGlua1wiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y29uc3QgcmVzID0gZXJyb3IgPyB7IGVycm9yOiBnZXRFcnJvclNoYXBlKHtcblx0XHRcdFx0XHRcdGNvbmZpZyxcblx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRlcnJvcixcblx0XHRcdFx0XHRcdGlucHV0OiBjYWxsLnJlc3VsdCgpLFxuXHRcdFx0XHRcdFx0cGF0aDogY2FsbC5wYXRoLFxuXHRcdFx0XHRcdFx0dHlwZTogaW5mby50eXBlXG5cdFx0XHRcdFx0fSkgfSA6IHsgcmVzdWx0OiB7IGRhdGE6IHJlc3VsdC5kYXRhIH0gfTtcblx0XHRcdFx0XHRjb25zdCBoZWFkUmVzcG9uc2UkMSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0aW5mbyxcblx0XHRcdFx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHRcdFx0XHRlcnJvcnM6IGVycm9yID8gW2Vycm9yXSA6IFtdLFxuXHRcdFx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0XHRcdHVudHJhbnNmb3JtZWRKU09OOiBbcmVzXVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKGNvbmZpZywgcmVzKSksIHtcblx0XHRcdFx0XHRcdHN0YXR1czogaGVhZFJlc3BvbnNlJDEuc3RhdHVzLFxuXHRcdFx0XHRcdFx0aGVhZGVyc1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgXCJzdWJzY3JpcHRpb25cIjoge1xuXHRcdFx0XHRcdGNvbnN0IGl0ZXJhYmxlID0gcnVuKCgpID0+IHtcblx0XHRcdFx0XHRcdGlmIChlcnJvcikgcmV0dXJuIGVycm9yVG9Bc3luY0l0ZXJhYmxlKGVycm9yKTtcblx0XHRcdFx0XHRcdGlmICghZXhwZXJpbWVudGFsU1NFKSByZXR1cm4gZXJyb3JUb0FzeW5jSXRlcmFibGUobmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0XHRcdGNvZGU6IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIixcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogXCJNaXNzaW5nIGV4cGVyaW1lbnRhbCBmbGFnIFxcXCJzc2VTdWJzY3JpcHRpb25zXFxcIlwiXG5cdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHRpZiAoIWlzT2JzZXJ2YWJsZShyZXN1bHQuZGF0YSkgJiYgIWlzQXN5bmNJdGVyYWJsZShyZXN1bHQuZGF0YSkpIHJldHVybiBlcnJvclRvQXN5bmNJdGVyYWJsZShuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogYFN1YnNjcmlwdGlvbiAke2NhbGwucGF0aH0gZGlkIG5vdCByZXR1cm4gYW4gb2JzZXJ2YWJsZSBvciBhIEFzeW5jR2VuZXJhdG9yYCxcblx0XHRcdFx0XHRcdFx0Y29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIlxuXHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGF0YUFzSXRlcmFibGUgPSBpc09ic2VydmFibGUocmVzdWx0LmRhdGEpID8gb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZShyZXN1bHQuZGF0YSwgb3B0cy5yZXEuc2lnbmFsKSA6IHJlc3VsdC5kYXRhO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGFBc0l0ZXJhYmxlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNvbnN0IHN0cmVhbSA9IHNzZVN0cmVhbVByb2R1Y2VyKHtcblx0XHRcdFx0XHRcdC4uLmNvbmZpZy5zc2UsXG5cdFx0XHRcdFx0XHRkYXRhOiBpdGVyYWJsZSxcblx0XHRcdFx0XHRcdHNlcmlhbGl6ZTogKHYpID0+IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKHYpLFxuXHRcdFx0XHRcdFx0Zm9ybWF0RXJyb3IoZXJyb3JPcHRzKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVycm9yJDEgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihlcnJvck9wdHMuZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBpbnB1dCA9IGNhbGw/LnJlc3VsdCgpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBwYXRoID0gY2FsbD8ucGF0aDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgdHlwZSA9IGNhbGw/LnByb2NlZHVyZT8uX2RlZi50eXBlID8/IFwidW5rbm93blwiO1xuXHRcdFx0XHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yJDEsXG5cdFx0XHRcdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHRcdFx0XHRpbnB1dCxcblx0XHRcdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0XHRcdHJlcTogb3B0cy5yZXEsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBnZXRFcnJvclNoYXBlKHtcblx0XHRcdFx0XHRcdFx0XHRjb25maWcsXG5cdFx0XHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IkMSxcblx0XHRcdFx0XHRcdFx0XHRpbnB1dCxcblx0XHRcdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGVcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzaGFwZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzc2VIZWFkZXJzKSkgaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0Y29uc3QgaGVhZFJlc3BvbnNlJDEgPSBpbml0UmVzcG9uc2Uoe1xuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGluZm8sXG5cdFx0XHRcdFx0XHRyZXNwb25zZU1ldGE6IG9wdHMucmVzcG9uc2VNZXRhLFxuXHRcdFx0XHRcdFx0ZXJyb3JzOiBbXSxcblx0XHRcdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdFx0XHR1bnRyYW5zZm9ybWVkSlNPTjogbnVsbFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2UkMS5zdGF0dXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaW5mby5hY2NlcHQgPT09IFwiYXBwbGljYXRpb24vanNvbmxcIikge1xuXHRcdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdFx0aGVhZGVycy5zZXQoXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLCBcImNodW5rZWRcIik7XG5cdFx0XHRjb25zdCBoZWFkUmVzcG9uc2UkMSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdGluZm8sXG5cdFx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHRcdGVycm9yczogW10sXG5cdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdHVudHJhbnNmb3JtZWRKU09OOiBudWxsXG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IHN0cmVhbSA9IGpzb25sU3RyZWFtUHJvZHVjZXIoe1xuXHRcdFx0XHQuLi5jb25maWcuanNvbmwsXG5cdFx0XHRcdG1heERlcHRoOiBJbmZpbml0eSxcblx0XHRcdFx0ZGF0YTogcnBjQ2FsbHMubWFwKGFzeW5jIChyZXMpID0+IHtcblx0XHRcdFx0XHRjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBhd2FpdCByZXM7XG5cdFx0XHRcdFx0Y29uc3QgY2FsbCA9IGluZm8uY2FsbHNbMF07XG5cdFx0XHRcdFx0aWYgKGVycm9yKSByZXR1cm4geyBlcnJvcjogZ2V0RXJyb3JTaGFwZSh7XG5cdFx0XHRcdFx0XHRjb25maWcsXG5cdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdFx0XHRpbnB1dDogY2FsbC5yZXN1bHQoKSxcblx0XHRcdFx0XHRcdHBhdGg6IGNhbGwucGF0aCxcblx0XHRcdFx0XHRcdHR5cGU6IGNhbGwucHJvY2VkdXJlPy5fZGVmLnR5cGUgPz8gXCJ1bmtub3duXCJcblx0XHRcdFx0XHR9KSB9O1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCogTm90IHZlcnkgcHJldHR5LCBidXQgd2UgbmVlZCB0byB3cmFwIG5lc3RlZCBkYXRhIGluIHByb21pc2VzXG5cdFx0XHRcdFx0KiBPdXIgc3RyZWFtIHByb2R1Y2VyIHdpbGwgb25seSByZXNvbHZlIHRvcC1sZXZlbCBhc3luYyB2YWx1ZXMgb3IgYXN5bmMgdmFsdWVzIHRoYXQgYXJlIGRpcmVjdGx5IG5lc3RlZCBpbiBhbm90aGVyIGFzeW5jIHZhbHVlXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRjb25zdCBpdGVyYWJsZSA9IGlzT2JzZXJ2YWJsZShyZXN1bHQuZGF0YSkgPyBvYnNlcnZhYmxlVG9Bc3luY0l0ZXJhYmxlKHJlc3VsdC5kYXRhLCBvcHRzLnJlcS5zaWduYWwpIDogUHJvbWlzZS5yZXNvbHZlKHJlc3VsdC5kYXRhKTtcblx0XHRcdFx0XHRyZXR1cm4geyByZXN1bHQ6IFByb21pc2UucmVzb2x2ZSh7IGRhdGE6IGl0ZXJhYmxlIH0pIH07XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRzZXJpYWxpemU6IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplLFxuXHRcdFx0XHRvbkVycm9yOiAoY2F1c2UpID0+IHtcblx0XHRcdFx0XHRvcHRzLm9uRXJyb3I/Lih7XG5cdFx0XHRcdFx0XHRlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuXHRcdFx0XHRcdFx0cGF0aDogdm9pZCAwLFxuXHRcdFx0XHRcdFx0aW5wdXQ6IHZvaWQgMCxcblx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRyZXE6IG9wdHMucmVxLFxuXHRcdFx0XHRcdFx0dHlwZTogaW5mbz8udHlwZSA/PyBcInVua25vd25cIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmb3JtYXRFcnJvcihlcnJvck9wdHMpIHtcblx0XHRcdFx0XHRjb25zdCBjYWxsID0gaW5mbz8uY2FsbHNbZXJyb3JPcHRzLnBhdGhbMF1dO1xuXHRcdFx0XHRcdGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oZXJyb3JPcHRzLmVycm9yKTtcblx0XHRcdFx0XHRjb25zdCBpbnB1dCA9IGNhbGw/LnJlc3VsdCgpO1xuXHRcdFx0XHRcdGNvbnN0IHBhdGggPSBjYWxsPy5wYXRoO1xuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBjYWxsPy5wcm9jZWR1cmU/Ll9kZWYudHlwZSA/PyBcInVua25vd25cIjtcblx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRcdFx0Y29uZmlnLFxuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdFx0aW5wdXQsXG5cdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0dHlwZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBzaGFwZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuXHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRzdGF0dXM6IGhlYWRSZXNwb25zZSQxLnN0YXR1c1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCogTm9uLXN0cmVhbWluZyByZXNwb25zZTpcblx0XHQqIC0gYXdhaXQgYWxsIHJlc3BvbnNlcyBpbiBwYXJhbGxlbCwgYmxvY2tpbmcgb24gdGhlIHNsb3dlc3Qgb25lXG5cdFx0KiAtIGNyZWF0ZSBoZWFkZXJzIHdpdGgga25vd24gcmVzcG9uc2UgYm9keVxuXHRcdCogLSByZXR1cm4gYSBjb21wbGV0ZSBIVFRQUmVzcG9uc2Vcblx0XHQqL1xuXHRcdGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0XHRjb25zdCByZXN1bHRzID0gKGF3YWl0IFByb21pc2UuYWxsKHJwY0NhbGxzKSkubWFwKChyZXMpID0+IHtcblx0XHRcdGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IHJlcztcblx0XHRcdGlmIChlcnJvcikgcmV0dXJuIHJlcztcblx0XHRcdGlmIChpc0RhdGFTdHJlYW0ocmVzdWx0LmRhdGEpKSByZXR1cm4gW25ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0XHRjb2RlOiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0XHRcdFx0bWVzc2FnZTogXCJDYW5ub3QgdXNlIHN0cmVhbS1saWtlIHJlc3BvbnNlIGluIG5vbi1zdHJlYW1pbmcgcmVxdWVzdCAtIHVzZSBodHRwQmF0Y2hTdHJlYW1MaW5rXCJcblx0XHRcdH0pLCB2b2lkIDBdO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9KTtcblx0XHRjb25zdCByZXN1bHRBc1JQQ1Jlc3BvbnNlID0gcmVzdWx0cy5tYXAoKFtlcnJvciwgcmVzdWx0XSwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IGNhbGwgPSBpbmZvLmNhbGxzW2luZGV4XTtcblx0XHRcdGlmIChlcnJvcikgcmV0dXJuIHsgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRjb25maWcsXG5cdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRpbnB1dDogY2FsbC5yZXN1bHQoKSxcblx0XHRcdFx0cGF0aDogY2FsbC5wYXRoLFxuXHRcdFx0XHR0eXBlOiBjYWxsLnByb2NlZHVyZT8uX2RlZi50eXBlID8/IFwidW5rbm93blwiXG5cdFx0XHR9KSB9O1xuXHRcdFx0cmV0dXJuIHsgcmVzdWx0OiB7IGRhdGE6IHJlc3VsdC5kYXRhIH0gfTtcblx0XHR9KTtcblx0XHRjb25zdCBlcnJvcnMgPSByZXN1bHRzLm1hcCgoW2Vycm9yXSkgPT4gZXJyb3IpLmZpbHRlcihCb29sZWFuKTtcblx0XHRjb25zdCBoZWFkUmVzcG9uc2UgPSBpbml0UmVzcG9uc2Uoe1xuXHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdGluZm8sXG5cdFx0XHRyZXNwb25zZU1ldGE6IG9wdHMucmVzcG9uc2VNZXRhLFxuXHRcdFx0dW50cmFuc2Zvcm1lZEpTT046IHJlc3VsdEFzUlBDUmVzcG9uc2UsXG5cdFx0XHRlcnJvcnMsXG5cdFx0XHRoZWFkZXJzXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1UUlBDUmVzcG9uc2UoY29uZmlnLCByZXN1bHRBc1JQQ1Jlc3BvbnNlKSksIHtcblx0XHRcdHN0YXR1czogaGVhZFJlc3BvbnNlLnN0YXR1cyxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRjb25zdCBbX2luZm9FcnJvciwgaW5mb10gPSBpbmZvVHVwbGU7XG5cdFx0Y29uc3QgY3R4ID0gY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCk7XG5cdFx0Y29uc3QgeyBlcnJvciwgdW50cmFuc2Zvcm1lZEpTT04sIGJvZHkgfSA9IGNhdWdodEVycm9yVG9EYXRhKGNhdXNlLCB7XG5cdFx0XHRvcHRzLFxuXHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdHR5cGU6IGluZm8/LnR5cGUgPz8gXCJ1bmtub3duXCJcblx0XHR9KTtcblx0XHRjb25zdCBoZWFkUmVzcG9uc2UgPSBpbml0UmVzcG9uc2Uoe1xuXHRcdFx0Y3R4LFxuXHRcdFx0aW5mbyxcblx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHR1bnRyYW5zZm9ybWVkSlNPTixcblx0XHRcdGVycm9yczogW2Vycm9yXSxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcblx0XHRcdHN0YXR1czogaGVhZFJlc3BvbnNlLnN0YXR1cyxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0fVxufVxuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IFVucHJvbWlzZSwgX19jb21tb25KUywgX190b0VTTSwgY3JlYXRlRGVmZXJyZWQsIGdldFJlcXVlc3RJbmZvLCBpc0Fib3J0RXJyb3IsIGlzUHJvbWlzZSwgaXRlcmF0b3JSZXNvdXJjZSwganNvbmxTdHJlYW1Db25zdW1lciwganNvbmxTdHJlYW1Qcm9kdWNlciwgbWFrZUFzeW5jUmVzb3VyY2UsIG1ha2VSZXNvdXJjZSwgcGFyc2VDb25uZWN0aW9uUGFyYW1zRnJvbVN0cmluZywgcGFyc2VDb25uZWN0aW9uUGFyYW1zRnJvbVVua25vd24sIHJlcXVpcmVfdXNpbmdDdHgsIHJlc29sdmVSZXNwb25zZSwgc3NlSGVhZGVycywgc3NlU3RyZWFtQ29uc3VtZXIsIHNzZVN0cmVhbVByb2R1Y2VyLCB0YWtlV2l0aEdyYWNlLCB0aHJvd0Fib3J0RXJyb3IsIHdpdGhNYXhEdXJhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZVJlc3BvbnNlLURQYllnSkRELm1qcy5tYXAiXSwibmFtZXMiOlsiZ2V0RXJyb3JTaGFwZSIsImdldEhUVFBTdGF0dXNDb2RlIiwiVFJQQ0Vycm9yIiwiZ2V0UHJvY2VkdXJlQXRQYXRoIiwiZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24iLCJpc1RyYWNrZWRFbnZlbG9wZSIsInRyYW5zZm9ybVRSUENSZXNwb25zZSIsImlkZW50aXR5IiwiaXNBc3luY0l0ZXJhYmxlIiwiaXNGdW5jdGlvbiIsImlzT2JqZWN0IiwicnVuIiwiaXNPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZSIsIl9fY3JlYXRlIiwiT2JqZWN0IiwiY3JlYXRlIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2dldE93blByb3BEZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19nZXRQcm90b09mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fY29tbW9uSlMiLCJjYiIsIm1vZCIsImV4cG9ydHMiLCJfX2NvcHlQcm9wcyIsInRvIiwiZnJvbSIsImV4Y2VwdCIsImRlc2MiLCJrZXlzIiwiaSIsIm4iLCJsZW5ndGgiLCJrZXkiLCJjYWxsIiwiZ2V0IiwiayIsImJpbmQiLCJlbnVtZXJhYmxlIiwiX190b0VTTSIsImlzTm9kZU1vZGUiLCJ0YXJnZXQiLCJfX2VzTW9kdWxlIiwidmFsdWUiLCJwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93biIsInBhcnNlZCIsIkVycm9yIiwibm9uU3RyaW5nVmFsdWVzIiwiZW50cmllcyIsImZpbHRlciIsIl9rZXkiLCJtYXAiLCJqb2luIiwiY2F1c2UiLCJjb2RlIiwibWVzc2FnZSIsInBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmciLCJzdHIiLCJKU09OIiwicGFyc2UiLCJtZW1vIiwiZm4iLCJwcm9taXNlIiwic3ltIiwiU3ltYm9sIiwiZm9yIiwicmVhZCIsImNhdGNoIiwicmVzdWx0IiwianNvbkNvbnRlbnRUeXBlSGFuZGxlciIsImlzTWF0Y2giLCJyZXEiLCJoZWFkZXJzIiwic3RhcnRzV2l0aCIsIm9wdHMiLCJpc0JhdGNoQ2FsbCIsInNlYXJjaFBhcmFtcyIsInBhdGhzIiwicGF0aCIsInNwbGl0IiwiZ2V0SW5wdXRzIiwiaW5wdXRzIiwibWV0aG9kIiwicXVlcnlJbnB1dCIsImpzb24iLCJyb3V0ZXIiLCJfZGVmIiwiX2NvbmZpZyIsInRyYW5zZm9ybWVyIiwiaW5wdXQiLCJkZXNlcmlhbGl6ZSIsImFjYyIsImluZGV4IiwiY2FsbHMiLCJQcm9taXNlIiwiYWxsIiwicHJvY2VkdXJlIiwiZ2V0UmF3SW5wdXQiLCJ0eXBlIiwibGFzdEV2ZW50SWQiLCJ0eXBlcyIsIlNldCIsIkJvb2xlYW4iLCJzaXplIiwiQXJyYXkiLCJ2YWx1ZXMiLCJuZXh0IiwiY29ubmVjdGlvblBhcmFtc1N0ciIsImluZm8iLCJhY2NlcHQiLCJjb25uZWN0aW9uUGFyYW1zIiwic2lnbmFsIiwidXJsIiwiZm9ybURhdGFDb250ZW50VHlwZUhhbmRsZXIiLCJmZCIsImZvcm1EYXRhIiwib2N0ZXRTdHJlYW1Db250ZW50VHlwZUhhbmRsZXIiLCJib2R5IiwiaGFuZGxlcnMiLCJnZXRDb250ZW50VHlwZUhhbmRsZXIiLCJoYW5kbGVyIiwiZmluZCIsImhhbmRsZXIkMSIsImhhcyIsImdldFJlcXVlc3RJbmZvIiwiaXNBYm9ydEVycm9yIiwiZXJyb3IiLCJ0aHJvd0Fib3J0RXJyb3IiLCJET01FeGNlcHRpb24iLCJzdWJzY3JpYmFibGVDYWNoZSIsIldlYWtNYXAiLCJOT09QIiwiVW5wcm9taXNlIiwidG9TdHJpbmdUYWciLCJjb25zdHJ1Y3RvciIsImFyZyIsInN1YnNjcmliZXJzIiwic2V0dGxlbWVudCIsInRoZW5SZXR1cm4iLCJ0aGVuIiwic3RhdHVzIiwiZm9yRWFjaCIsInJlc29sdmUiLCJyZWFzb24iLCJyZWplY3QiLCJzdWJzY3JpYmUiLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZXIiLCJ3aXRoUmVzb2x2ZXJzIiwibGlzdFdpdGhNZW1iZXIiLCJsaXN0V2l0aG91dE1lbWJlciIsImFzc2lnbiIsIm9uZnVsZmlsbGVkIiwib25yZWplY3RlZCIsInN1YnNjcmliZWQiLCJmaW5hbGx5Iiwib25maW5hbGx5IiwicHJveHkiLCJjYWNoZWQiLCJnZXRTdWJzY3JpYmFibGVQcm9taXNlIiwiY3JlYXRlU3Vic2NyaWJhYmxlUHJvbWlzZSIsImNyZWF0ZWQiLCJzZXQiLCJhbnkiLCJ2YWx1ZXNBcnJheSIsImlzQXJyYXkiLCJzdWJzY3JpYmVkUHJvbWlzZXMiLCJyYWNlIiwicmFjZVJlZmVyZW5jZXMiLCJwcm9taXNlcyIsInNlbGZQcm9taXNlcyIsInJlc29sdmVTZWxmVHVwbGUiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJhcnIiLCJtZW1iZXIiLCJsaXN0V2l0aG91dEluZGV4Iiwic2xpY2UiLCJpbmRleE9mIiwiZGlzcG9zZSIsImFzeW5jRGlzcG9zZSIsIm1ha2VSZXNvdXJjZSIsInRoaW5nIiwiaXQiLCJleGlzdGluZyIsIm1ha2VBc3luY1Jlc291cmNlIiwiZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCIsInRpbWVyUmVzb3VyY2UiLCJtcyIsInRpbWVyIiwic3RhcnQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicmVxdWlyZV91c2luZ0N0eCIsIm1vZHVsZSIsIl91c2luZ0N0eCIsInIiLCJTdXBwcmVzc2VkRXJyb3IiLCJyJDEiLCJlJDEiLCJuJDEiLCJuYW1lIiwic3VwcHJlc3NlZCIsImUiLCJ1c2luZyIsIlR5cGVFcnJvciIsIm8iLCJ0IiwibyQxIiwiciQyIiwicHVzaCIsInYiLCJkIiwiYSIsInUiLCJzIiwicG9wIiwiZXJyIiwiaW1wb3J0X3VzaW5nQ3R4JDQiLCJpdGVyYXRvclJlc291cmNlIiwiaXRlcmFibGUiLCJpdGVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJyZXR1cm4iLCJ3aXRoTWF4RHVyYXRpb24iLCJfdXNpbmdDdHgkMSIsImRlZmF1bHQiLCJtYXhEdXJhdGlvbk1zIiwidGltZXJQcm9taXNlIiwiZG9uZSIsIl8iLCJ0YWtlV2l0aEdyYWNlIiwiX3VzaW5nQ3R4MyIsImdyYWNlUGVyaW9kTXMiLCJjb3VudCIsImNyZWF0ZURlZmVycmVkIiwicmVzIiwicmVqIiwiaW1wb3J0X3VzaW5nQ3R4JDMiLCJjcmVhdGVNYW5hZ2VkSXRlcmF0b3IiLCJvblJlc3VsdCIsInN0YXRlIiwiY2xlYW51cCIsInB1bGwiLCJkZXN0cm95IiwibWVyZ2VBc3luY0l0ZXJhYmxlcyIsImZsdXNoU2lnbmFsIiwiaXRlcmFibGVzIiwiaXRlcmF0b3JzIiwiYnVmZmVyIiwiaW5pdEl0ZXJhYmxlIiwiZGVsZXRlIiwiYWRkIiwiX2ZpbmFsbHkiLCJlcnJvcnMiLCJjbGVhciIsIkFnZ3JlZ2F0ZUVycm9yIiwic2hpZnQiLCJyZWFkYWJsZVN0cmVhbUZyb20iLCJSZWFkYWJsZVN0cmVhbSIsImNhbmNlbCIsImNvbnRyb2xsZXIiLCJjbG9zZSIsImVucXVldWUiLCJpbXBvcnRfdXNpbmdDdHgkMiIsIlBJTkdfU1lNIiwid2l0aFBpbmciLCJwaW5nSW50ZXJ2YWxNcyIsIm5leHRQcm9taXNlIiwicGluZ1Byb21pc2UiLCJpbXBvcnRfdXNpbmdDdHgkMSIsImlzUGxhaW5PYmplY3QiLCJ0b1N0cmluZyIsIkNIVU5LX1ZBTFVFX1RZUEVfUFJPTUlTRSIsIkNIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEUiLCJQUk9NSVNFX1NUQVRVU19GVUxGSUxMRUQiLCJQUk9NSVNFX1NUQVRVU19SRUpFQ1RFRCIsIkFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk4iLCJBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQiLCJBU1lOQ19JVEVSQUJMRV9TVEFUVVNfRVJST1IiLCJpc1Byb21pc2UiLCJNYXhEZXB0aEVycm9yIiwiY3JlYXRlQmF0Y2hTdHJlYW1Qcm9kdWNlciIsImRhdGEiLCJjb3VudGVyIiwicGxhY2Vob2xkZXIiLCJtZXJnZWRJdGVyYWJsZXMiLCJyZWdpc3RlckFzeW5jIiwiY2FsbGJhY2siLCJpZHgiLCJpdGVyYWJsZSQxIiwiZW5jb2RlUHJvbWlzZSIsImNoZWNrTWF4RGVwdGgiLCJvbkVycm9yIiwiZW5jb2RlIiwiZm9ybWF0RXJyb3IiLCJlbmNvZGVBc3luY0l0ZXJhYmxlIiwibWF4RGVwdGgiLCJlbmNvZGVBc3luYyIsInJlZyIsIm5ld09iaiIsImFzeW5jVmFsdWVzIiwiaXRlbSIsInRyYW5zZm9ybWVkIiwibmV3SGVhZCIsInBpbmdNcyIsImpzb25sU3RyZWFtUHJvZHVjZXIiLCJzdHJlYW0iLCJzZXJpYWxpemUiLCJwaXBlVGhyb3VnaCIsIlRyYW5zZm9ybVN0cmVhbSIsInRyYW5zZm9ybSIsImNodW5rIiwic3RyaW5naWZ5IiwiVGV4dEVuY29kZXJTdHJlYW0iLCJBc3luY0Vycm9yIiwibm9kZUpzU3RyZWFtVG9SZWFkZXJFc3F1ZSIsInNvdXJjZSIsImdldFJlYWRlciIsIm9uIiwiY3JlYXRlTGluZUFjY3VtdWxhdG9yIiwicmVhZGVyIiwibGluZUFnZ3JlZ2F0ZSIsIlRleHREZWNvZGVyU3RyZWFtIiwicGFydHMiLCJwYXJ0IiwiY3JlYXRlQ29uc3VtZXJTdHJlYW0iLCJzZW50SGVhZCIsImxpbmUiLCJoZWFkIiwiY3JlYXRlU3RyZWFtc01hbmFnZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJjb250cm9sbGVyTWFwIiwiTWFwIiwiaXNFbXB0eSIsImV2ZXJ5IiwiYyIsImNsb3NlZCIsImNyZWF0ZVN0cmVhbUNvbnRyb2xsZXIiLCJvcmlnaW5hbENvbnRyb2xsZXIiLCJzdHJlYW1Db250cm9sbGVyIiwiYWJvcnQiLCJnZXRSZWFkZXJSZXNvdXJjZSIsInJlbGVhc2VMb2NrIiwiZ2V0T3JDcmVhdGUiLCJjaHVua0lkIiwiY2FuY2VsQWxsIiwianNvbmxTdHJlYW1Db25zdW1lciIsImhlYWREZWZlcnJlZCIsInN0cmVhbU1hbmFnZXIiLCJkZWNvZGVDaHVua0RlZmluaXRpb24iLCJfcGF0aCIsInZhbHVlJDEiLCJfY2h1bmtJZCIsImRlY29kZSIsIl91c2luZ0N0eDQiLCJhc3luY1Byb3BzIiwiZGVjb2RlZCIsImNsb3NlT3JBYm9ydCIsInBpcGVUbyIsIldyaXRhYmxlU3RyZWFtIiwid3JpdGUiLCJjaHVua09ySGVhZCIsImltcG9ydF91c2luZ0N0eCIsIlBJTkdfRVZFTlQiLCJTRVJJQUxJWkVEX0VSUk9SX0VWRU5UIiwiQ09OTkVDVEVEX0VWRU5UIiwiUkVUVVJOX0VWRU5UIiwic3NlU3RyZWFtUHJvZHVjZXIiLCJwaW5nIiwiZW5hYmxlZCIsImludGVydmFsTXMiLCJjbGllbnQiLCJyZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcyIsImdlbmVyYXRvciIsImV2ZW50IiwiZW1pdEFuZEVuZEltbWVkaWF0ZWx5IiwiSW5maW5pdHkiLCJpZCIsImdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nIiwiY29tbWVudCIsIndpdGhUaW1lb3V0IiwidGltZW91dFByb21pc2UiLCJ0aW1lb3V0TXMiLCJvblRpbWVvdXQiLCJzc2VTdHJlYW1Db25zdW1lciIsImNsaWVudE9wdGlvbnMiLCJfZXMiLCJjcmVhdGVTdHJlYW0iLCJpbml0IiwiZXZlbnRTb3VyY2UiLCJFdmVudFNvdXJjZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfbXNnIiwibXNnIiwib3B0aW9ucyIsInJlYWR5U3RhdGUiLCJDTE9TRUQiLCJkZWYiLCJvbkFib3J0IiwiYWJvcnRlZCIsImdldFN0cmVhbVJlc291cmNlIiwicmVjcmVhdGUiLCJzc2VIZWFkZXJzIiwiQ29ubmVjdGlvbiIsImVycm9yVG9Bc3luY0l0ZXJhYmxlIiwiVFlQRV9BQ0NFUFRFRF9NRVRIT0RfTUFQIiwibXV0YXRpb24iLCJxdWVyeSIsInN1YnNjcmlwdGlvbiIsIlRZUEVfQUNDRVBURURfTUVUSE9EX01BUF9XSVRIX01FVEhPRF9PVkVSUklERSIsImluaXRSZXNwb25zZSIsImluaXRPcHRzIiwiY3R4IiwicmVzcG9uc2VNZXRhIiwidW50cmFuc2Zvcm1lZEpTT04iLCJlYWdlckdlbmVyYXRpb24iLCJtZXRhIiwiSGVhZGVycyIsImFwcGVuZCIsImNhdWdodEVycm9yVG9EYXRhIiwiZXJyb3JPcHRzIiwiY29uZmlnIiwidHJhbnNmb3JtZWRKU09OIiwiaXNEYXRhU3RyZWFtIiwic29tZSIsInJlc29sdmVSZXNwb25zZSIsIlVSTCIsIlJlc3BvbnNlIiwiYWxsb3dCYXRjaGluZyIsImJhdGNoaW5nIiwiYWxsb3dNZXRob2RPdmVycmlkZSIsImluZm9UdXBsZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImN0eE1hbmFnZXIiLCJ2YWx1ZU9yVW5kZWZpbmVkIiwiY3JlYXRlQ29udGV4dCIsIm1ldGhvZE1hcHBlciIsImlzU3RyZWFtQ2FsbCIsImV4cGVyaW1lbnRhbFNTRSIsInNzZSIsImluZm9FcnJvciIsInJwY0NhbGxzIiwicHJvYyIsImluY2x1ZGVzIiwiaGVhZFJlc3BvbnNlJDEiLCJkYXRhQXNJdGVyYWJsZSIsIm91dHB1dCIsImVycm9yJDEiLCJzaGFwZSIsImpzb25sIiwicmVzdWx0cyIsInJlc3VsdEFzUlBDUmVzcG9uc2UiLCJoZWFkUmVzcG9uc2UiLCJfaW5mb0Vycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-DPbYgJDD.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPCError: () => (/* binding */ TRPCError),\n/* harmony export */   callProcedure: () => (/* binding */ callProcedure),\n/* harmony export */   createCallerFactory: () => (/* binding */ createCallerFactory),\n/* harmony export */   createRouterFactory: () => (/* binding */ createRouterFactory),\n/* harmony export */   defaultFormatter: () => (/* binding */ defaultFormatter),\n/* harmony export */   defaultTransformer: () => (/* binding */ defaultTransformer),\n/* harmony export */   getCauseFromUnknown: () => (/* binding */ getCauseFromUnknown),\n/* harmony export */   getDataTransformer: () => (/* binding */ getDataTransformer),\n/* harmony export */   getProcedureAtPath: () => (/* binding */ getProcedureAtPath),\n/* harmony export */   getTRPCErrorFromUnknown: () => (/* binding */ getTRPCErrorFromUnknown),\n/* harmony export */   isTrackedEnvelope: () => (/* binding */ isTrackedEnvelope),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   mergeRouters: () => (/* binding */ mergeRouters),\n/* harmony export */   sse: () => (/* binding */ sse),\n/* harmony export */   tracked: () => (/* binding */ tracked),\n/* harmony export */   transformResult: () => (/* binding */ transformResult),\n/* harmony export */   transformTRPCResponse: () => (/* binding */ transformTRPCResponse)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getErrorShape-DyYil4aT.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-DyYil4aT.mjs\");\n/* harmony import */ var _utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-BHZJcBRv.mjs */ \"(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\");\n\n\n//#region src/unstable-core-do-not-import/error/formatter.ts\nconst defaultFormatter = ({ shape })=>{\n    return shape;\n};\n//#endregion\n//#region src/unstable-core-do-not-import/error/TRPCError.ts\nvar UnknownCauseError = class extends Error {\n};\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) return cause;\n    const type = typeof cause;\n    if (type === \"undefined\" || type === \"function\" || cause === null) return void 0;\n    if (type !== \"object\") return new Error(String(cause));\n    if ((0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(cause)) return Object.assign(new UnknownCauseError(), cause);\n    return void 0;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    if (cause instanceof TRPCError) return cause;\n    if (cause instanceof Error && cause.name === \"TRPCError\") return cause;\n    const trpcError = new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        cause\n    });\n    if (cause instanceof Error && cause.stack) trpcError.stack = cause.stack;\n    return trpcError;\n}\nvar TRPCError = class extends Error {\n    constructor(opts){\n        const cause = getCauseFromUnknown(opts.cause);\n        const message = opts.message ?? cause?.message ?? opts.code;\n        super(message, {\n            cause\n        });\n        this.code = opts.code;\n        this.name = \"TRPCError\";\n        this.cause ??= cause;\n    }\n};\n//#endregion\n//#region src/unstable-core-do-not-import/transformer.ts\n/**\n* @internal\n*/ function getDataTransformer(transformer) {\n    if (\"input\" in transformer) return transformer;\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n* @internal\n*/ const defaultTransformer = {\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\nfunction transformTRPCResponseItem(config, item) {\n    if (\"error\" in item) return {\n        ...item,\n        error: config.transformer.output.serialize(item.error)\n    };\n    if (\"data\" in item.result) return {\n        ...item,\n        result: {\n            ...item.result,\n            data: config.transformer.output.serialize(item.result.data)\n        }\n    };\n    return item;\n}\n/**\n* Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n**/ function transformTRPCResponse(config, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n/** @internal */ function transformResultInner(response, transformer) {\n    if (\"error\" in response) {\n        const error = transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: {\n                ...response,\n                error\n            }\n        };\n    }\n    const result = {\n        ...response.result,\n        ...(!response.result.type || response.result.type === \"data\") && {\n            type: \"data\",\n            data: transformer.deserialize(response.result.data)\n        }\n    };\n    return {\n        ok: true,\n        result\n    };\n}\nvar TransformResultError = class extends Error {\n    constructor(){\n        super(\"Unable to transform response from server\");\n    }\n};\n/**\n* Transforms and validates that the result is a valid TRPCResponse\n* @internal\n*/ function transformResult(response, transformer) {\n    let result;\n    try {\n        result = transformResultInner(response, transformer);\n    } catch  {\n        throw new TransformResultError();\n    }\n    if (!result.ok && (!(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(result.error.error) || typeof result.error.error[\"code\"] !== \"number\")) throw new TransformResultError();\n    if (result.ok && !(0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(result.result)) throw new TransformResultError();\n    return result;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/router.ts\nconst lazySymbol = Symbol(\"lazy\");\nfunction once(fn) {\n    const uncalled = Symbol();\n    let result = uncalled;\n    return ()=>{\n        if (result === uncalled) result = fn();\n        return result;\n    };\n}\n/**\n* Lazy load a router\n* @see https://trpc.io/docs/server/merging-routers#lazy-load\n*/ function lazy(importRouter) {\n    async function resolve() {\n        const mod = await importRouter();\n        if (isRouter(mod)) return mod;\n        const routers = Object.values(mod);\n        if (routers.length !== 1 || !isRouter(routers[0])) throw new Error(\"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\");\n        return routers[0];\n    }\n    resolve[lazySymbol] = true;\n    return resolve;\n}\nfunction isLazy(input) {\n    return typeof input === \"function\" && lazySymbol in input;\n}\nfunction isRouter(value) {\n    return (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value[\"_def\"]) && \"router\" in value[\"_def\"];\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n* Reserved words that can't be used as router or procedure names\n*/ const reservedWords = [\n    \"then\",\n    \"call\",\n    \"apply\"\n];\n/**\n* @internal\n*/ function createRouterFactory(config) {\n    function createRouterInner(input) {\n        const reservedWordsUsed = new Set(Object.keys(input).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) throw new Error(\"Reserved words used in `router({})` call: \" + Array.from(reservedWordsUsed).join(\", \"));\n        const procedures = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.omitPrototype)({});\n        const lazy$1 = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.omitPrototype)({});\n        function createLazyLoader(opts) {\n            return {\n                ref: opts.ref,\n                load: once(async ()=>{\n                    const router$1 = await opts.ref();\n                    const lazyPath = [\n                        ...opts.path,\n                        opts.key\n                    ];\n                    const lazyKey = lazyPath.join(\".\");\n                    opts.aggregate[opts.key] = step(router$1._def.record, lazyPath);\n                    delete lazy$1[lazyKey];\n                    for (const [nestedKey, nestedItem] of Object.entries(router$1._def.lazy)){\n                        const nestedRouterKey = [\n                            ...lazyPath,\n                            nestedKey\n                        ].join(\".\");\n                        lazy$1[nestedRouterKey] = createLazyLoader({\n                            ref: nestedItem.ref,\n                            path: lazyPath,\n                            key: nestedKey,\n                            aggregate: opts.aggregate[opts.key]\n                        });\n                    }\n                })\n            };\n        }\n        function step(from, path = []) {\n            const aggregate = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.omitPrototype)({});\n            for (const [key, item] of Object.entries(from ?? {})){\n                if (isLazy(item)) {\n                    lazy$1[[\n                        ...path,\n                        key\n                    ].join(\".\")] = createLazyLoader({\n                        path,\n                        ref: item,\n                        key,\n                        aggregate\n                    });\n                    continue;\n                }\n                if (isRouter(item)) {\n                    aggregate[key] = step(item._def.record, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                if (!isProcedure(item)) {\n                    aggregate[key] = step(item, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                const newPath = [\n                    ...path,\n                    key\n                ].join(\".\");\n                if (procedures[newPath]) throw new Error(`Duplicate key: ${newPath}`);\n                procedures[newPath] = item;\n                aggregate[key] = item;\n            }\n            return aggregate;\n        }\n        const record = step(input);\n        const _def = {\n            _config: config,\n            router: true,\n            procedures,\n            lazy: lazy$1,\n            ...emptyRouter,\n            record\n        };\n        const router = {\n            ...record,\n            _def,\n            createCaller: createCallerFactory()({\n                _def\n            })\n        };\n        return router;\n    }\n    return createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n    return typeof procedureOrRouter === \"function\";\n}\n/**\n* @internal\n*/ async function getProcedureAtPath(router, path) {\n    const { _def } = router;\n    let procedure = _def.procedures[path];\n    while(!procedure){\n        const key = Object.keys(_def.lazy).find((key$1)=>path.startsWith(key$1));\n        if (!key) return null;\n        const lazyRouter = _def.lazy[key];\n        await lazyRouter.load();\n        procedure = _def.procedures[path];\n    }\n    return procedure;\n}\n/**\n* @internal\n*/ async function callProcedure(opts) {\n    const { type, path } = opts;\n    const proc = await getProcedureAtPath(opts.router, path);\n    if (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: `No \"${type}\"-procedure on path \"${path}\"`\n    });\n    /* istanbul ignore if -- @preserve */ if (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === \"subscription\") throw new TRPCError({\n        code: \"METHOD_NOT_SUPPORTED\",\n        message: `Method override is not supported for subscriptions`\n    });\n    return proc(opts);\n}\nfunction createCallerFactory() {\n    return function createCallerInner(router) {\n        const { _def } = router;\n        return function createCaller(ctxOrCallback, opts) {\n            return (0,_getErrorShape_DyYil4aT_mjs__WEBPACK_IMPORTED_MODULE_1__.createRecursiveProxy)(async ({ path, args })=>{\n                const fullPath = path.join(\".\");\n                if (path.length === 1 && path[0] === \"_def\") return _def;\n                const procedure = await getProcedureAtPath(router, fullPath);\n                let ctx = void 0;\n                try {\n                    if (!procedure) throw new TRPCError({\n                        code: \"NOT_FOUND\",\n                        message: `No procedure found on path \"${path}\"`\n                    });\n                    ctx = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n                    return await procedure({\n                        path: fullPath,\n                        getRawInput: async ()=>args[0],\n                        ctx,\n                        type: procedure._def.type,\n                        signal: opts?.signal\n                    });\n                } catch (cause) {\n                    opts?.onError?.({\n                        ctx,\n                        error: getTRPCErrorFromUnknown(cause),\n                        input: args[0],\n                        path: fullPath,\n                        type: procedure?._def.type ?? \"unknown\"\n                    });\n                    throw cause;\n                }\n            });\n        };\n    };\n}\nfunction mergeRouters(...routerList) {\n    const record = (0,_utils_BHZJcBRv_mjs__WEBPACK_IMPORTED_MODULE_0__.mergeWithoutOverrides)({}, ...routerList.map((r)=>r._def.record));\n    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{\n        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) throw new Error(\"You seem to have several error formatters\");\n            return nextRouter._def._config.errorFormatter;\n        }\n        return currentErrorFormatter;\n    }, defaultFormatter);\n    const transformer = routerList.reduce((prev, current)=>{\n        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n            if (prev !== defaultTransformer && prev !== current._def._config.transformer) throw new Error(\"You seem to have several transformers\");\n            return current._def._config.transformer;\n        }\n        return prev;\n    }, defaultTransformer);\n    const router = createRouterFactory({\n        errorFormatter,\n        transformer,\n        isDev: routerList.every((r)=>r._def._config.isDev),\n        allowOutsideOfServer: routerList.every((r)=>r._def._config.allowOutsideOfServer),\n        isServer: routerList.every((r)=>r._def._config.isServer),\n        $types: routerList[0]?._def._config.$types\n    })(record);\n    return router;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/tracked.ts\nconst trackedSymbol = Symbol();\n/**\n* Produce a typed server-sent event message\n* @deprecated use `tracked(id, data)` instead\n*/ function sse(event) {\n    return tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n    return Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n* Automatically track an event so that it can be resumed from a given id if the connection is lost\n*/ function tracked(id, data) {\n    if (id === \"\") throw new Error(\"`id` must not be an empty string as empty string is the same as not setting the id at all\");\n    return [\n        id,\n        data,\n        trackedSymbol\n    ];\n}\n//#endregion\n //# sourceMappingURL=tracked-GEWPoL0C.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC90cmFja2VkLUdFV1BvTDBDLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQzhCO0FBRWxHLDREQUE0RDtBQUM1RCxNQUFNSyxtQkFBbUIsQ0FBQyxFQUFFQyxLQUFLLEVBQUU7SUFDbEMsT0FBT0E7QUFDUjtBQUVBLFlBQVk7QUFDWiw0REFBNEQ7QUFDNUQsSUFBSUMsb0JBQW9CLGNBQWNDO0FBQU87QUFDN0MsU0FBU0Msb0JBQW9CQyxLQUFLO0lBQ2pDLElBQUlBLGlCQUFpQkYsT0FBTyxPQUFPRTtJQUNuQyxNQUFNQyxPQUFPLE9BQU9EO0lBQ3BCLElBQUlDLFNBQVMsZUFBZUEsU0FBUyxjQUFjRCxVQUFVLE1BQU0sT0FBTyxLQUFLO0lBQy9FLElBQUlDLFNBQVMsVUFBVSxPQUFPLElBQUlILE1BQU1JLE9BQU9GO0lBQy9DLElBQUlSLDZEQUFRQSxDQUFDUSxRQUFRLE9BQU9HLE9BQU9DLE1BQU0sQ0FBQyxJQUFJUCxxQkFBcUJHO0lBQ25FLE9BQU8sS0FBSztBQUNiO0FBQ0EsU0FBU0ssd0JBQXdCTCxLQUFLO0lBQ3JDLElBQUlBLGlCQUFpQk0sV0FBVyxPQUFPTjtJQUN2QyxJQUFJQSxpQkFBaUJGLFNBQVNFLE1BQU1PLElBQUksS0FBSyxhQUFhLE9BQU9QO0lBQ2pFLE1BQU1RLFlBQVksSUFBSUYsVUFBVTtRQUMvQkcsTUFBTTtRQUNOVDtJQUNEO0lBQ0EsSUFBSUEsaUJBQWlCRixTQUFTRSxNQUFNVSxLQUFLLEVBQUVGLFVBQVVFLEtBQUssR0FBR1YsTUFBTVUsS0FBSztJQUN4RSxPQUFPRjtBQUNSO0FBQ0EsSUFBSUYsWUFBWSxjQUFjUjtJQUc3QmEsWUFBWUMsSUFBSSxDQUFFO1FBQ2pCLE1BQU1aLFFBQVFELG9CQUFvQmEsS0FBS1osS0FBSztR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QUFDUSxPQUFPLENBQUM5RSxXQUFXO1FBQ3hDO1FBQ0EsT0FBTzJHO0lBQ1IsR0FBR3hHO0lBQ0gsTUFBTTRFLFNBQVNoQyxvQkFBb0I7UUFDbENGO1FBQ0E3QztRQUNBNkcsT0FBT1AsV0FBV1EsS0FBSyxDQUFDLENBQUNQLElBQU1BLEVBQUVqQyxJQUFJLENBQUNRLE9BQU8sQ0FBQytCLEtBQUs7UUFDbkRFLHNCQUFzQlQsV0FBV1EsS0FBSyxDQUFDLENBQUNQLElBQU1BLEVBQUVqQyxJQUFJLENBQUNRLE9BQU8sQ0FBQ2lDLG9CQUFvQjtRQUNqRkMsVUFBVVYsV0FBV1EsS0FBSyxDQUFDLENBQUNQLElBQU1BLEVBQUVqQyxJQUFJLENBQUNRLE9BQU8sQ0FBQ2tDLFFBQVE7UUFDekRDLFFBQVFYLFVBQVUsQ0FBQyxFQUFFLEVBQUVoQyxLQUFLUSxRQUFRbUM7SUFDckMsR0FBRzFDO0lBQ0gsT0FBT1E7QUFDUjtBQUVBLFlBQVk7QUFDWiwyREFBMkQ7QUFDM0QsTUFBTW1DLGdCQUFnQjFGO0FBQ3RCOzs7QUFHQSxHQUNBLFNBQVMyRixJQUFJQyxLQUFLO0lBQ2pCLE9BQU9DLFFBQVFELE1BQU1FLEVBQUUsRUFBRUYsTUFBTXhHLElBQUk7QUFDcEM7QUFDQSxTQUFTMkcsa0JBQWtCbEYsS0FBSztJQUMvQixPQUFPdEIsTUFBTUMsT0FBTyxDQUFDcUIsVUFBVUEsS0FBSyxDQUFDLEVBQUUsS0FBSzZFO0FBQzdDO0FBQ0E7O0FBRUEsR0FDQSxTQUFTRyxRQUFRQyxFQUFFLEVBQUUxRyxJQUFJO0lBQ3hCLElBQUkwRyxPQUFPLElBQUksTUFBTSxJQUFJdkksTUFBTTtJQUMvQixPQUFPO1FBQ051STtRQUNBMUc7UUFDQXNHO0tBQ0E7QUFDRjtBQUVBLFlBQVk7QUFDMlIsQ0FDdlMsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC90cmFja2VkLUdFV1BvTDBDLm1qcz8zODQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlY3Vyc2l2ZVByb3h5IH0gZnJvbSBcIi4vZ2V0RXJyb3JTaGFwZS1EeVlpbDRhVC5tanNcIjtcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBtZXJnZVdpdGhvdXRPdmVycmlkZXMsIG9taXRQcm90b3R5cGUgfSBmcm9tIFwiLi91dGlscy1CSFpKY0JSdi5tanNcIjtcblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvZXJyb3IvZm9ybWF0dGVyLnRzXG5jb25zdCBkZWZhdWx0Rm9ybWF0dGVyID0gKHsgc2hhcGUgfSkgPT4ge1xuXHRyZXR1cm4gc2hhcGU7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2Vycm9yL1RSUENFcnJvci50c1xudmFyIFVua25vd25DYXVzZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7fTtcbmZ1bmN0aW9uIGdldENhdXNlRnJvbVVua25vd24oY2F1c2UpIHtcblx0aWYgKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBjYXVzZTtcblx0Y29uc3QgdHlwZSA9IHR5cGVvZiBjYXVzZTtcblx0aWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGNhdXNlID09PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuXHRpZiAodHlwZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcoY2F1c2UpKTtcblx0aWYgKGlzT2JqZWN0KGNhdXNlKSkgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFVua25vd25DYXVzZUVycm9yKCksIGNhdXNlKTtcblx0cmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKSB7XG5cdGlmIChjYXVzZSBpbnN0YW5jZW9mIFRSUENFcnJvcikgcmV0dXJuIGNhdXNlO1xuXHRpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5uYW1lID09PSBcIlRSUENFcnJvclwiKSByZXR1cm4gY2F1c2U7XG5cdGNvbnN0IHRycGNFcnJvciA9IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG5cdFx0Y2F1c2Vcblx0fSk7XG5cdGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yICYmIGNhdXNlLnN0YWNrKSB0cnBjRXJyb3Iuc3RhY2sgPSBjYXVzZS5zdGFjaztcblx0cmV0dXJuIHRycGNFcnJvcjtcbn1cbnZhciBUUlBDRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y2F1c2U7XG5cdGNvZGU7XG5cdGNvbnN0cnVjdG9yKG9wdHMpIHtcblx0XHRjb25zdCBjYXVzZSA9IGdldENhdXNlRnJvbVVua25vd24ob3B0cy5jYXVzZSk7XG5cdFx0Y29uc3QgbWVzc2FnZSA9IG9wdHMubWVzc2FnZSA/PyBjYXVzZT8ubWVzc2FnZSA/PyBvcHRzLmNvZGU7XG5cdFx0c3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcblx0XHR0aGlzLmNvZGUgPSBvcHRzLmNvZGU7XG5cdFx0dGhpcy5uYW1lID0gXCJUUlBDRXJyb3JcIjtcblx0XHR0aGlzLmNhdXNlID8/PSBjYXVzZTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC90cmFuc2Zvcm1lci50c1xuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGdldERhdGFUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lcikge1xuXHRpZiAoXCJpbnB1dFwiIGluIHRyYW5zZm9ybWVyKSByZXR1cm4gdHJhbnNmb3JtZXI7XG5cdHJldHVybiB7XG5cdFx0aW5wdXQ6IHRyYW5zZm9ybWVyLFxuXHRcdG91dHB1dDogdHJhbnNmb3JtZXJcblx0fTtcbn1cbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5jb25zdCBkZWZhdWx0VHJhbnNmb3JtZXIgPSB7XG5cdGlucHV0OiB7XG5cdFx0c2VyaWFsaXplOiAob2JqKSA9PiBvYmosXG5cdFx0ZGVzZXJpYWxpemU6IChvYmopID0+IG9ialxuXHR9LFxuXHRvdXRwdXQ6IHtcblx0XHRzZXJpYWxpemU6IChvYmopID0+IG9iaixcblx0XHRkZXNlcmlhbGl6ZTogKG9iaikgPT4gb2JqXG5cdH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbSkge1xuXHRpZiAoXCJlcnJvclwiIGluIGl0ZW0pIHJldHVybiB7XG5cdFx0Li4uaXRlbSxcblx0XHRlcnJvcjogY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoaXRlbS5lcnJvcilcblx0fTtcblx0aWYgKFwiZGF0YVwiIGluIGl0ZW0ucmVzdWx0KSByZXR1cm4ge1xuXHRcdC4uLml0ZW0sXG5cdFx0cmVzdWx0OiB7XG5cdFx0XHQuLi5pdGVtLnJlc3VsdCxcblx0XHRcdGRhdGE6IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKGl0ZW0ucmVzdWx0LmRhdGEpXG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gaXRlbTtcbn1cbi8qKlxuKiBUYWtlcyBhIHVuc2VyaWFsaXplZCBgVFJQQ1Jlc3BvbnNlYCBhbmQgc2VyaWFsaXplcyBpdCB3aXRoIHRoZSByb3V0ZXIncyB0cmFuc2Zvcm1lcnNcbioqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKGNvbmZpZywgaXRlbU9ySXRlbXMpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbU9ySXRlbXMpID8gaXRlbU9ySXRlbXMubWFwKChpdGVtKSA9PiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbSkpIDogdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlSXRlbShjb25maWcsIGl0ZW1Pckl0ZW1zKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCB0cmFuc2Zvcm1lcikge1xuXHRpZiAoXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSB0cmFuc2Zvcm1lci5kZXNlcmlhbGl6ZShyZXNwb25zZS5lcnJvcik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG9rOiBmYWxzZSxcblx0XHRcdGVycm9yOiB7XG5cdFx0XHRcdC4uLnJlc3BvbnNlLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdC4uLnJlc3BvbnNlLnJlc3VsdCxcblx0XHQuLi4oIXJlc3BvbnNlLnJlc3VsdC50eXBlIHx8IHJlc3BvbnNlLnJlc3VsdC50eXBlID09PSBcImRhdGFcIikgJiYge1xuXHRcdFx0dHlwZTogXCJkYXRhXCIsXG5cdFx0XHRkYXRhOiB0cmFuc2Zvcm1lci5kZXNlcmlhbGl6ZShyZXNwb25zZS5yZXN1bHQuZGF0YSlcblx0XHR9XG5cdH07XG5cdHJldHVybiB7XG5cdFx0b2s6IHRydWUsXG5cdFx0cmVzdWx0XG5cdH07XG59XG52YXIgVHJhbnNmb3JtUmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoXCJVbmFibGUgdG8gdHJhbnNmb3JtIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuXHR9XG59O1xuLyoqXG4qIFRyYW5zZm9ybXMgYW5kIHZhbGlkYXRlcyB0aGF0IHRoZSByZXN1bHQgaXMgYSB2YWxpZCBUUlBDUmVzcG9uc2VcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gdHJhbnNmb3JtUmVzdWx0KHJlc3BvbnNlLCB0cmFuc2Zvcm1lcikge1xuXHRsZXQgcmVzdWx0O1xuXHR0cnkge1xuXHRcdHJlc3VsdCA9IHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCB0cmFuc2Zvcm1lcik7XG5cdH0gY2F0Y2gge1xuXHRcdHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuXHR9XG5cdGlmICghcmVzdWx0Lm9rICYmICghaXNPYmplY3QocmVzdWx0LmVycm9yLmVycm9yKSB8fCB0eXBlb2YgcmVzdWx0LmVycm9yLmVycm9yW1wiY29kZVwiXSAhPT0gXCJudW1iZXJcIikpIHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuXHRpZiAocmVzdWx0Lm9rICYmICFpc09iamVjdChyZXN1bHQucmVzdWx0KSkgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcm91dGVyLnRzXG5jb25zdCBsYXp5U3ltYm9sID0gU3ltYm9sKFwibGF6eVwiKTtcbmZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0Y29uc3QgdW5jYWxsZWQgPSBTeW1ib2woKTtcblx0bGV0IHJlc3VsdCA9IHVuY2FsbGVkO1xuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChyZXN1bHQgPT09IHVuY2FsbGVkKSByZXN1bHQgPSBmbigpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59XG4vKipcbiogTGF6eSBsb2FkIGEgcm91dGVyXG4qIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3Mvc2VydmVyL21lcmdpbmctcm91dGVycyNsYXp5LWxvYWRcbiovXG5mdW5jdGlvbiBsYXp5KGltcG9ydFJvdXRlcikge1xuXHRhc3luYyBmdW5jdGlvbiByZXNvbHZlKCkge1xuXHRcdGNvbnN0IG1vZCA9IGF3YWl0IGltcG9ydFJvdXRlcigpO1xuXHRcdGlmIChpc1JvdXRlcihtb2QpKSByZXR1cm4gbW9kO1xuXHRcdGNvbnN0IHJvdXRlcnMgPSBPYmplY3QudmFsdWVzKG1vZCk7XG5cdFx0aWYgKHJvdXRlcnMubGVuZ3RoICE9PSAxIHx8ICFpc1JvdXRlcihyb3V0ZXJzWzBdKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3V0ZXIgbW9kdWxlIC0gZWl0aGVyIGRlZmluZSBleGFjdGx5IDEgZXhwb3J0IG9yIHJldHVybiB0aGUgcm91dGVyIGRpcmVjdGx5LlxcbkV4YW1wbGU6IGBsYXp5KCgpID0+IGltcG9ydCgnLi9zbG93LmpzJykudGhlbigobSkgPT4gbS5zbG93Um91dGVyKSlgXCIpO1xuXHRcdHJldHVybiByb3V0ZXJzWzBdO1xuXHR9XG5cdHJlc29sdmVbbGF6eVN5bWJvbF0gPSB0cnVlO1xuXHRyZXR1cm4gcmVzb2x2ZTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShpbnB1dCkge1xuXHRyZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcImZ1bmN0aW9uXCIgJiYgbGF6eVN5bWJvbCBpbiBpbnB1dDtcbn1cbmZ1bmN0aW9uIGlzUm91dGVyKHZhbHVlKSB7XG5cdHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgaXNPYmplY3QodmFsdWVbXCJfZGVmXCJdKSAmJiBcInJvdXRlclwiIGluIHZhbHVlW1wiX2RlZlwiXTtcbn1cbmNvbnN0IGVtcHR5Um91dGVyID0ge1xuXHRfY3R4OiBudWxsLFxuXHRfZXJyb3JTaGFwZTogbnVsbCxcblx0X21ldGE6IG51bGwsXG5cdHF1ZXJpZXM6IHt9LFxuXHRtdXRhdGlvbnM6IHt9LFxuXHRzdWJzY3JpcHRpb25zOiB7fSxcblx0ZXJyb3JGb3JtYXR0ZXI6IGRlZmF1bHRGb3JtYXR0ZXIsXG5cdHRyYW5zZm9ybWVyOiBkZWZhdWx0VHJhbnNmb3JtZXJcbn07XG4vKipcbiogUmVzZXJ2ZWQgd29yZHMgdGhhdCBjYW4ndCBiZSB1c2VkIGFzIHJvdXRlciBvciBwcm9jZWR1cmUgbmFtZXNcbiovXG5jb25zdCByZXNlcnZlZFdvcmRzID0gW1xuXHRcInRoZW5cIixcblx0XCJjYWxsXCIsXG5cdFwiYXBwbHlcIlxuXTtcbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJGYWN0b3J5KGNvbmZpZykge1xuXHRmdW5jdGlvbiBjcmVhdGVSb3V0ZXJJbm5lcihpbnB1dCkge1xuXHRcdGNvbnN0IHJlc2VydmVkV29yZHNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhpbnB1dCkuZmlsdGVyKCh2KSA9PiByZXNlcnZlZFdvcmRzLmluY2x1ZGVzKHYpKSk7XG5cdFx0aWYgKHJlc2VydmVkV29yZHNVc2VkLnNpemUgPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNlcnZlZCB3b3JkcyB1c2VkIGluIGByb3V0ZXIoe30pYCBjYWxsOiBcIiArIEFycmF5LmZyb20ocmVzZXJ2ZWRXb3Jkc1VzZWQpLmpvaW4oXCIsIFwiKSk7XG5cdFx0Y29uc3QgcHJvY2VkdXJlcyA9IG9taXRQcm90b3R5cGUoe30pO1xuXHRcdGNvbnN0IGxhenkkMSA9IG9taXRQcm90b3R5cGUoe30pO1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUxhenlMb2FkZXIob3B0cykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cmVmOiBvcHRzLnJlZixcblx0XHRcdFx0bG9hZDogb25jZShhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgcm91dGVyJDEgPSBhd2FpdCBvcHRzLnJlZigpO1xuXHRcdFx0XHRcdGNvbnN0IGxhenlQYXRoID0gWy4uLm9wdHMucGF0aCwgb3B0cy5rZXldO1xuXHRcdFx0XHRcdGNvbnN0IGxhenlLZXkgPSBsYXp5UGF0aC5qb2luKFwiLlwiKTtcblx0XHRcdFx0XHRvcHRzLmFnZ3JlZ2F0ZVtvcHRzLmtleV0gPSBzdGVwKHJvdXRlciQxLl9kZWYucmVjb3JkLCBsYXp5UGF0aCk7XG5cdFx0XHRcdFx0ZGVsZXRlIGxhenkkMVtsYXp5S2V5XTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtuZXN0ZWRLZXksIG5lc3RlZEl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKHJvdXRlciQxLl9kZWYubGF6eSkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZFJvdXRlcktleSA9IFsuLi5sYXp5UGF0aCwgbmVzdGVkS2V5XS5qb2luKFwiLlwiKTtcblx0XHRcdFx0XHRcdGxhenkkMVtuZXN0ZWRSb3V0ZXJLZXldID0gY3JlYXRlTGF6eUxvYWRlcih7XG5cdFx0XHRcdFx0XHRcdHJlZjogbmVzdGVkSXRlbS5yZWYsXG5cdFx0XHRcdFx0XHRcdHBhdGg6IGxhenlQYXRoLFxuXHRcdFx0XHRcdFx0XHRrZXk6IG5lc3RlZEtleSxcblx0XHRcdFx0XHRcdFx0YWdncmVnYXRlOiBvcHRzLmFnZ3JlZ2F0ZVtvcHRzLmtleV1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHN0ZXAoZnJvbSwgcGF0aCA9IFtdKSB7XG5cdFx0XHRjb25zdCBhZ2dyZWdhdGUgPSBvbWl0UHJvdG90eXBlKHt9KTtcblx0XHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXMoZnJvbSA/PyB7fSkpIHtcblx0XHRcdFx0aWYgKGlzTGF6eShpdGVtKSkge1xuXHRcdFx0XHRcdGxhenkkMVtbLi4ucGF0aCwga2V5XS5qb2luKFwiLlwiKV0gPSBjcmVhdGVMYXp5TG9hZGVyKHtcblx0XHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0XHRyZWY6IGl0ZW0sXG5cdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRhZ2dyZWdhdGVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNSb3V0ZXIoaXRlbSkpIHtcblx0XHRcdFx0XHRhZ2dyZWdhdGVba2V5XSA9IHN0ZXAoaXRlbS5fZGVmLnJlY29yZCwgWy4uLnBhdGgsIGtleV0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNQcm9jZWR1cmUoaXRlbSkpIHtcblx0XHRcdFx0XHRhZ2dyZWdhdGVba2V5XSA9IHN0ZXAoaXRlbSwgWy4uLnBhdGgsIGtleV0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IG5ld1BhdGggPSBbLi4ucGF0aCwga2V5XS5qb2luKFwiLlwiKTtcblx0XHRcdFx0aWYgKHByb2NlZHVyZXNbbmV3UGF0aF0pIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGtleTogJHtuZXdQYXRofWApO1xuXHRcdFx0XHRwcm9jZWR1cmVzW25ld1BhdGhdID0gaXRlbTtcblx0XHRcdFx0YWdncmVnYXRlW2tleV0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFnZ3JlZ2F0ZTtcblx0XHR9XG5cdFx0Y29uc3QgcmVjb3JkID0gc3RlcChpbnB1dCk7XG5cdFx0Y29uc3QgX2RlZiA9IHtcblx0XHRcdF9jb25maWc6IGNvbmZpZyxcblx0XHRcdHJvdXRlcjogdHJ1ZSxcblx0XHRcdHByb2NlZHVyZXMsXG5cdFx0XHRsYXp5OiBsYXp5JDEsXG5cdFx0XHQuLi5lbXB0eVJvdXRlcixcblx0XHRcdHJlY29yZFxuXHRcdH07XG5cdFx0Y29uc3Qgcm91dGVyID0ge1xuXHRcdFx0Li4ucmVjb3JkLFxuXHRcdFx0X2RlZixcblx0XHRcdGNyZWF0ZUNhbGxlcjogY3JlYXRlQ2FsbGVyRmFjdG9yeSgpKHsgX2RlZiB9KVxuXHRcdH07XG5cdFx0cmV0dXJuIHJvdXRlcjtcblx0fVxuXHRyZXR1cm4gY3JlYXRlUm91dGVySW5uZXI7XG59XG5mdW5jdGlvbiBpc1Byb2NlZHVyZShwcm9jZWR1cmVPclJvdXRlcikge1xuXHRyZXR1cm4gdHlwZW9mIHByb2NlZHVyZU9yUm91dGVyID09PSBcImZ1bmN0aW9uXCI7XG59XG4vKipcbiogQGludGVybmFsXG4qL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvY2VkdXJlQXRQYXRoKHJvdXRlciwgcGF0aCkge1xuXHRjb25zdCB7IF9kZWYgfSA9IHJvdXRlcjtcblx0bGV0IHByb2NlZHVyZSA9IF9kZWYucHJvY2VkdXJlc1twYXRoXTtcblx0d2hpbGUgKCFwcm9jZWR1cmUpIHtcblx0XHRjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhfZGVmLmxhenkpLmZpbmQoKGtleSQxKSA9PiBwYXRoLnN0YXJ0c1dpdGgoa2V5JDEpKTtcblx0XHRpZiAoIWtleSkgcmV0dXJuIG51bGw7XG5cdFx0Y29uc3QgbGF6eVJvdXRlciA9IF9kZWYubGF6eVtrZXldO1xuXHRcdGF3YWl0IGxhenlSb3V0ZXIubG9hZCgpO1xuXHRcdHByb2NlZHVyZSA9IF9kZWYucHJvY2VkdXJlc1twYXRoXTtcblx0fVxuXHRyZXR1cm4gcHJvY2VkdXJlO1xufVxuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmFzeW5jIGZ1bmN0aW9uIGNhbGxQcm9jZWR1cmUob3B0cykge1xuXHRjb25zdCB7IHR5cGUsIHBhdGggfSA9IG9wdHM7XG5cdGNvbnN0IHByb2MgPSBhd2FpdCBnZXRQcm9jZWR1cmVBdFBhdGgob3B0cy5yb3V0ZXIsIHBhdGgpO1xuXHRpZiAoIXByb2MgfHwgIWlzUHJvY2VkdXJlKHByb2MpIHx8IHByb2MuX2RlZi50eXBlICE9PSB0eXBlICYmICFvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdGNvZGU6IFwiTk9UX0ZPVU5EXCIsXG5cdFx0bWVzc2FnZTogYE5vIFwiJHt0eXBlfVwiLXByb2NlZHVyZSBvbiBwYXRoIFwiJHtwYXRofVwiYFxuXHR9KTtcblx0LyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuXHRpZiAocHJvYy5fZGVmLnR5cGUgIT09IHR5cGUgJiYgb3B0cy5hbGxvd01ldGhvZE92ZXJyaWRlICYmIHByb2MuX2RlZi50eXBlID09PSBcInN1YnNjcmlwdGlvblwiKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRjb2RlOiBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCIsXG5cdFx0bWVzc2FnZTogYE1ldGhvZCBvdmVycmlkZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdWJzY3JpcHRpb25zYFxuXHR9KTtcblx0cmV0dXJuIHByb2Mob3B0cyk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsZXJGYWN0b3J5KCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ2FsbGVySW5uZXIocm91dGVyKSB7XG5cdFx0Y29uc3QgeyBfZGVmIH0gPSByb3V0ZXI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNhbGxlcihjdHhPckNhbGxiYWNrLCBvcHRzKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUmVjdXJzaXZlUHJveHkoYXN5bmMgKHsgcGF0aCwgYXJncyB9KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKFwiLlwiKTtcblx0XHRcdFx0aWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHBhdGhbMF0gPT09IFwiX2RlZlwiKSByZXR1cm4gX2RlZjtcblx0XHRcdFx0Y29uc3QgcHJvY2VkdXJlID0gYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKHJvdXRlciwgZnVsbFBhdGgpO1xuXHRcdFx0XHRsZXQgY3R4ID0gdm9pZCAwO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghcHJvY2VkdXJlKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdGNvZGU6IFwiTk9UX0ZPVU5EXCIsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBgTm8gcHJvY2VkdXJlIGZvdW5kIG9uIHBhdGggXCIke3BhdGh9XCJgXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y3R4ID0gaXNGdW5jdGlvbihjdHhPckNhbGxiYWNrKSA/IGF3YWl0IFByb21pc2UucmVzb2x2ZShjdHhPckNhbGxiYWNrKCkpIDogY3R4T3JDYWxsYmFjaztcblx0XHRcdFx0XHRyZXR1cm4gYXdhaXQgcHJvY2VkdXJlKHtcblx0XHRcdFx0XHRcdHBhdGg6IGZ1bGxQYXRoLFxuXHRcdFx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGFzeW5jICgpID0+IGFyZ3NbMF0sXG5cdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHR0eXBlOiBwcm9jZWR1cmUuX2RlZi50eXBlLFxuXHRcdFx0XHRcdFx0c2lnbmFsOiBvcHRzPy5zaWduYWxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0XHRvcHRzPy5vbkVycm9yPy4oe1xuXHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKSxcblx0XHRcdFx0XHRcdGlucHV0OiBhcmdzWzBdLFxuXHRcdFx0XHRcdFx0cGF0aDogZnVsbFBhdGgsXG5cdFx0XHRcdFx0XHR0eXBlOiBwcm9jZWR1cmU/Ll9kZWYudHlwZSA/PyBcInVua25vd25cIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRocm93IGNhdXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9O1xufVxuZnVuY3Rpb24gbWVyZ2VSb3V0ZXJzKC4uLnJvdXRlckxpc3QpIHtcblx0Y29uc3QgcmVjb3JkID0gbWVyZ2VXaXRob3V0T3ZlcnJpZGVzKHt9LCAuLi5yb3V0ZXJMaXN0Lm1hcCgocikgPT4gci5fZGVmLnJlY29yZCkpO1xuXHRjb25zdCBlcnJvckZvcm1hdHRlciA9IHJvdXRlckxpc3QucmVkdWNlKChjdXJyZW50RXJyb3JGb3JtYXR0ZXIsIG5leHRSb3V0ZXIpID0+IHtcblx0XHRpZiAobmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIgJiYgbmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIgIT09IGRlZmF1bHRGb3JtYXR0ZXIpIHtcblx0XHRcdGlmIChjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IGRlZmF1bHRGb3JtYXR0ZXIgJiYgY3VycmVudEVycm9yRm9ybWF0dGVyICE9PSBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlcikgdGhyb3cgbmV3IEVycm9yKFwiWW91IHNlZW0gdG8gaGF2ZSBzZXZlcmFsIGVycm9yIGZvcm1hdHRlcnNcIik7XG5cdFx0XHRyZXR1cm4gbmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXI7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJyZW50RXJyb3JGb3JtYXR0ZXI7XG5cdH0sIGRlZmF1bHRGb3JtYXR0ZXIpO1xuXHRjb25zdCB0cmFuc2Zvcm1lciA9IHJvdXRlckxpc3QucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG5cdFx0aWYgKGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyICYmIGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyICE9PSBkZWZhdWx0VHJhbnNmb3JtZXIpIHtcblx0XHRcdGlmIChwcmV2ICE9PSBkZWZhdWx0VHJhbnNmb3JtZXIgJiYgcHJldiAhPT0gY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIpIHRocm93IG5ldyBFcnJvcihcIllvdSBzZWVtIHRvIGhhdmUgc2V2ZXJhbCB0cmFuc2Zvcm1lcnNcIik7XG5cdFx0XHRyZXR1cm4gY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXI7XG5cdFx0fVxuXHRcdHJldHVybiBwcmV2O1xuXHR9LCBkZWZhdWx0VHJhbnNmb3JtZXIpO1xuXHRjb25zdCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXJGYWN0b3J5KHtcblx0XHRlcnJvckZvcm1hdHRlcixcblx0XHR0cmFuc2Zvcm1lcixcblx0XHRpc0Rldjogcm91dGVyTGlzdC5ldmVyeSgocikgPT4gci5fZGVmLl9jb25maWcuaXNEZXYpLFxuXHRcdGFsbG93T3V0c2lkZU9mU2VydmVyOiByb3V0ZXJMaXN0LmV2ZXJ5KChyKSA9PiByLl9kZWYuX2NvbmZpZy5hbGxvd091dHNpZGVPZlNlcnZlciksXG5cdFx0aXNTZXJ2ZXI6IHJvdXRlckxpc3QuZXZlcnkoKHIpID0+IHIuX2RlZi5fY29uZmlnLmlzU2VydmVyKSxcblx0XHQkdHlwZXM6IHJvdXRlckxpc3RbMF0/Ll9kZWYuX2NvbmZpZy4kdHlwZXNcblx0fSkocmVjb3JkKTtcblx0cmV0dXJuIHJvdXRlcjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdHJhY2tlZC50c1xuY29uc3QgdHJhY2tlZFN5bWJvbCA9IFN5bWJvbCgpO1xuLyoqXG4qIFByb2R1Y2UgYSB0eXBlZCBzZXJ2ZXItc2VudCBldmVudCBtZXNzYWdlXG4qIEBkZXByZWNhdGVkIHVzZSBgdHJhY2tlZChpZCwgZGF0YSlgIGluc3RlYWRcbiovXG5mdW5jdGlvbiBzc2UoZXZlbnQpIHtcblx0cmV0dXJuIHRyYWNrZWQoZXZlbnQuaWQsIGV2ZW50LmRhdGEpO1xufVxuZnVuY3Rpb24gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlWzJdID09PSB0cmFja2VkU3ltYm9sO1xufVxuLyoqXG4qIEF1dG9tYXRpY2FsbHkgdHJhY2sgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBmcm9tIGEgZ2l2ZW4gaWQgaWYgdGhlIGNvbm5lY3Rpb24gaXMgbG9zdFxuKi9cbmZ1bmN0aW9uIHRyYWNrZWQoaWQsIGRhdGEpIHtcblx0aWYgKGlkID09PSBcIlwiKSB0aHJvdyBuZXcgRXJyb3IoXCJgaWRgIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZyBhcyBlbXB0eSBzdHJpbmcgaXMgdGhlIHNhbWUgYXMgbm90IHNldHRpbmcgdGhlIGlkIGF0IGFsbFwiKTtcblx0cmV0dXJuIFtcblx0XHRpZCxcblx0XHRkYXRhLFxuXHRcdHRyYWNrZWRTeW1ib2xcblx0XTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBUUlBDRXJyb3IsIGNhbGxQcm9jZWR1cmUsIGNyZWF0ZUNhbGxlckZhY3RvcnksIGNyZWF0ZVJvdXRlckZhY3RvcnksIGRlZmF1bHRGb3JtYXR0ZXIsIGRlZmF1bHRUcmFuc2Zvcm1lciwgZ2V0Q2F1c2VGcm9tVW5rbm93biwgZ2V0RGF0YVRyYW5zZm9ybWVyLCBnZXRQcm9jZWR1cmVBdFBhdGgsIGdldFRSUENFcnJvckZyb21Vbmtub3duLCBpc1RyYWNrZWRFbnZlbG9wZSwgbGF6eSwgbWVyZ2VSb3V0ZXJzLCBzc2UsIHRyYWNrZWQsIHRyYW5zZm9ybVJlc3VsdCwgdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja2VkLUdFV1BvTDBDLm1qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlUmVjdXJzaXZlUHJveHkiLCJpc0Z1bmN0aW9uIiwiaXNPYmplY3QiLCJtZXJnZVdpdGhvdXRPdmVycmlkZXMiLCJvbWl0UHJvdG90eXBlIiwiZGVmYXVsdEZvcm1hdHRlciIsInNoYXBlIiwiVW5rbm93bkNhdXNlRXJyb3IiLCJFcnJvciIsImdldENhdXNlRnJvbVVua25vd24iLCJjYXVzZSIsInR5cGUiLCJTdHJpbmciLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRUUlBDRXJyb3JGcm9tVW5rbm93biIsIlRSUENFcnJvciIsIm5hbWUiLCJ0cnBjRXJyb3IiLCJjb2RlIiwic3RhY2siLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJtZXNzYWdlIiwiZ2V0RGF0YVRyYW5zZm9ybWVyIiwidHJhbnNmb3JtZXIiLCJpbnB1dCIsIm91dHB1dCIsImRlZmF1bHRUcmFuc2Zvcm1lciIsInNlcmlhbGl6ZSIsIm9iaiIsImRlc2VyaWFsaXplIiwidHJhbnNmb3JtVFJQQ1Jlc3BvbnNlSXRlbSIsImNvbmZpZyIsIml0ZW0iLCJlcnJvciIsInJlc3VsdCIsImRhdGEiLCJ0cmFuc2Zvcm1UUlBDUmVzcG9uc2UiLCJpdGVtT3JJdGVtcyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInRyYW5zZm9ybVJlc3VsdElubmVyIiwicmVzcG9uc2UiLCJvayIsIlRyYW5zZm9ybVJlc3VsdEVycm9yIiwidHJhbnNmb3JtUmVzdWx0IiwibGF6eVN5bWJvbCIsIlN5bWJvbCIsIm9uY2UiLCJmbiIsInVuY2FsbGVkIiwibGF6eSIsImltcG9ydFJvdXRlciIsInJlc29sdmUiLCJtb2QiLCJpc1JvdXRlciIsInJvdXRlcnMiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJpc0xhenkiLCJ2YWx1ZSIsImVtcHR5Um91dGVyIiwiX2N0eCIsIl9lcnJvclNoYXBlIiwiX21ldGEiLCJxdWVyaWVzIiwibXV0YXRpb25zIiwic3Vic2NyaXB0aW9ucyIsImVycm9yRm9ybWF0dGVyIiwicmVzZXJ2ZWRXb3JkcyIsImNyZWF0ZVJvdXRlckZhY3RvcnkiLCJjcmVhdGVSb3V0ZXJJbm5lciIsInJlc2VydmVkV29yZHNVc2VkIiwiU2V0Iiwia2V5cyIsImZpbHRlciIsInYiLCJpbmNsdWRlcyIsInNpemUiLCJmcm9tIiwiam9pbiIsInByb2NlZHVyZXMiLCJsYXp5JDEiLCJjcmVhdGVMYXp5TG9hZGVyIiwicmVmIiwibG9hZCIsInJvdXRlciQxIiwibGF6eVBhdGgiLCJwYXRoIiwia2V5IiwibGF6eUtleSIsImFnZ3JlZ2F0ZSIsInN0ZXAiLCJfZGVmIiwicmVjb3JkIiwibmVzdGVkS2V5IiwibmVzdGVkSXRlbSIsImVudHJpZXMiLCJuZXN0ZWRSb3V0ZXJLZXkiLCJpc1Byb2NlZHVyZSIsIm5ld1BhdGgiLCJfY29uZmlnIiwicm91dGVyIiwiY3JlYXRlQ2FsbGVyIiwiY3JlYXRlQ2FsbGVyRmFjdG9yeSIsInByb2NlZHVyZU9yUm91dGVyIiwiZ2V0UHJvY2VkdXJlQXRQYXRoIiwicHJvY2VkdXJlIiwiZmluZCIsImtleSQxIiwic3RhcnRzV2l0aCIsImxhenlSb3V0ZXIiLCJjYWxsUHJvY2VkdXJlIiwicHJvYyIsImFsbG93TWV0aG9kT3ZlcnJpZGUiLCJjcmVhdGVDYWxsZXJJbm5lciIsImN0eE9yQ2FsbGJhY2siLCJhcmdzIiwiZnVsbFBhdGgiLCJjdHgiLCJQcm9taXNlIiwiZ2V0UmF3SW5wdXQiLCJzaWduYWwiLCJvbkVycm9yIiwibWVyZ2VSb3V0ZXJzIiwicm91dGVyTGlzdCIsInIiLCJyZWR1Y2UiLCJjdXJyZW50RXJyb3JGb3JtYXR0ZXIiLCJuZXh0Um91dGVyIiwicHJldiIsImN1cnJlbnQiLCJpc0RldiIsImV2ZXJ5IiwiYWxsb3dPdXRzaWRlT2ZTZXJ2ZXIiLCJpc1NlcnZlciIsIiR0eXBlcyIsInRyYWNrZWRTeW1ib2wiLCJzc2UiLCJldmVudCIsInRyYWNrZWQiLCJpZCIsImlzVHJhY2tlZEVudmVsb3BlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-GEWPoL0C.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPC_ERROR_CODES_BY_KEY: () => (/* binding */ TRPC_ERROR_CODES_BY_KEY),\n/* harmony export */   TRPC_ERROR_CODES_BY_NUMBER: () => (/* binding */ TRPC_ERROR_CODES_BY_NUMBER),\n/* harmony export */   abortSignalsAnyPonyfill: () => (/* binding */ abortSignalsAnyPonyfill),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   mergeWithoutOverrides: () => (/* binding */ mergeWithoutOverrides),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   omitPrototype: () => (/* binding */ omitPrototype),\n/* harmony export */   retryableRpcCodes: () => (/* binding */ retryableRpcCodes),\n/* harmony export */   run: () => (/* binding */ run),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n//#region src/unstable-core-do-not-import/rpc/codes.ts\n/**\n* JSON-RPC 2.0 Error codes\n*\n* `-32000` to `-32099` are reserved for implementation-defined server-errors.\n* For tRPC we're copying the last digits of HTTP 4XX errors.\n*/ const TRPC_ERROR_CODES_BY_KEY = {\n    PARSE_ERROR: -32700,\n    BAD_REQUEST: -32600,\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    BAD_GATEWAY: -32603,\n    SERVICE_UNAVAILABLE: -32603,\n    GATEWAY_TIMEOUT: -32603,\n    UNAUTHORIZED: -32001,\n    PAYMENT_REQUIRED: -32002,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNSUPPORTED_MEDIA_TYPE: -32015,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n    [-32700]: \"PARSE_ERROR\",\n    [-32600]: \"BAD_REQUEST\",\n    [-32603]: \"INTERNAL_SERVER_ERROR\",\n    [-32001]: \"UNAUTHORIZED\",\n    [-32002]: \"PAYMENT_REQUIRED\",\n    [-32003]: \"FORBIDDEN\",\n    [-32004]: \"NOT_FOUND\",\n    [-32005]: \"METHOD_NOT_SUPPORTED\",\n    [-32008]: \"TIMEOUT\",\n    [-32009]: \"CONFLICT\",\n    [-32012]: \"PRECONDITION_FAILED\",\n    [-32013]: \"PAYLOAD_TOO_LARGE\",\n    [-32015]: \"UNSUPPORTED_MEDIA_TYPE\",\n    [-32022]: \"UNPROCESSABLE_CONTENT\",\n    [-32029]: \"TOO_MANY_REQUESTS\",\n    [-32099]: \"CLIENT_CLOSED_REQUEST\"\n};\n/**\n* tRPC error codes that are considered retryable\n* With out of the box SSE, the client will reconnect when these errors are encountered\n*/ const retryableRpcCodes = [\n    TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n    TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n    TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n    TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n//#endregion\n//#region src/unstable-core-do-not-import/utils.ts\n/**\n* Ensures there are no duplicate keys when building a procedure.\n* @internal\n*/ function mergeWithoutOverrides(obj1, ...objs) {\n    const newObj = Object.assign(Object.create(null), obj1);\n    for (const overrides of objs)for(const key in overrides){\n        if (key in newObj && newObj[key] !== overrides[key]) throw new Error(`Duplicate key ${key}`);\n        newObj[key] = overrides[key];\n    }\n    return newObj;\n}\n/**\n* Check that value is object\n* @internal\n*/ function isObject(value) {\n    return !!value && !Array.isArray(value) && typeof value === \"object\";\n}\nfunction isFunction(fn) {\n    return typeof fn === \"function\";\n}\n/**\n* Create an object without inheriting anything from `Object.prototype`\n* @internal\n*/ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === \"function\" && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n    return asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n* Run an IIFE\n*/ const run = (fn)=>fn();\nfunction noop() {}\nfunction identity(it) {\n    return it;\n}\n/**\n* Generic runtime assertion function. Throws, if the condition is not `true`.\n*\n* Can be used as a slightly less dangerous variant of type assertions. Code\n* mistakes would be revealed at runtime then (hopefully during testing).\n*/ function assert(condition, msg = \"no additional info\") {\n    if (!condition) throw new Error(`AssertionError: ${msg}`);\n}\nfunction sleep(ms = 0) {\n    return new Promise((res)=>setTimeout(res, ms));\n}\n/**\n* Ponyfill for\n* [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n*/ function abortSignalsAnyPonyfill(signals) {\n    if (typeof AbortSignal.any === \"function\") return AbortSignal.any(signals);\n    const ac = new AbortController();\n    for (const signal of signals){\n        if (signal.aborted) {\n            trigger();\n            break;\n        }\n        signal.addEventListener(\"abort\", trigger, {\n            once: true\n        });\n    }\n    return ac.signal;\n    function trigger() {\n        ac.abort();\n        for (const signal of signals)signal.removeEventListener(\"abort\", trigger);\n    }\n}\n//#endregion\n //# sourceMappingURL=utils-BHZJcBRv.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC91dGlscy1CSFpKY0JSdi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBc0Q7QUFDdEQ7Ozs7O0FBS0EsR0FDQSxNQUFNQSwwQkFBMEI7SUFDL0JDLGFBQWEsQ0FBQztJQUNkQyxhQUFhLENBQUM7SUFDZEMsdUJBQXVCLENBQUM7SUFDeEJDLGlCQUFpQixDQUFDO0lBQ2xCQyxhQUFhLENBQUM7SUFDZEMscUJBQXFCLENBQUM7SUFDdEJDLGlCQUFpQixDQUFDO0lBQ2xCQyxjQUFjLENBQUM7SUFDZkMsa0JBQWtCLENBQUM7SUFDbkJDLFdBQVcsQ0FBQztJQUNaQyxXQUFXLENBQUM7SUFDWkMsc0JBQXNCLENBQUM7SUFDdkJDLFNBQVMsQ0FBQztJQUNWQyxVQUFVLENBQUM7SUFDWEMscUJBQXFCLENBQUM7SUFDdEJDLG1CQUFtQixDQUFDO0lBQ3BCQyx3QkFBd0IsQ0FBQztJQUN6QkMsdUJBQXVCLENBQUM7SUFDeEJDLG1CQUFtQixDQUFDO0lBQ3BCQyx1QkFBdUIsQ0FBQztBQUN6QjtBQUNBLE1BQU1DLDZCQUE2QjtJQUNsQyxDQUFDLENBQUMsTUFBTSxFQUFFO0lBQ1YsQ0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNWLENBQUMsQ0FBQyxNQUFNLEVBQUU7SUFDVixDQUFDLENBQUMsTUFBTSxFQUFFO0lBQ1YsQ0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNWLENBQUMsQ0FBQyxNQUFNLEVBQUU7SUFDVixDQUFDLENBQUMsTUFBTSxFQUFFO0lBQ1YsQ0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNWLENBQUMsQ0FBQyxNQUFNLEVBQUU7SUFDVixDQUFDLENBQUMsTUFBTSxFQUFFO0lBQ1YsQ0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNWLENBQUMsQ0FBQyxNQUFNLEVBQUU7SUFDVixDQUFDLENBQUMsTUFBTSxFQUFFO0lBQ1YsQ0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNWLENBQUMsQ0FBQyxNQUFNLEVBQUU7SUFDVixDQUFDLENBQUMsTUFBTSxFQUFFO0FBQ1g7QUFDQTs7O0FBR0EsR0FDQSxNQUFNQyxvQkFBb0I7SUFDekJ0Qix3QkFBd0JLLFdBQVc7SUFDbkNMLHdCQUF3Qk0sbUJBQW1CO0lBQzNDTix3QkFBd0JPLGVBQWU7SUFDdkNQLHdCQUF3QkcscUJBQXFCO0NBQzdDO0FBRUQsWUFBWTtBQUNaLGtEQUFrRDtBQUNsRDs7O0FBR0EsR0FDQSxTQUFTb0Isc0JBQXNCQyxJQUFJLEVBQUUsR0FBR0MsSUFBSTtJQUMzQyxNQUFNQyxTQUFTQyxPQUFPQyxNQUFNLENBQUNELE9BQU9FLE1BQU0sQ0FBQyxPQUFPTDtJQUNsRCxLQUFLLE1BQU1NLGFBQWFMLEtBQU0sSUFBSyxNQUFNTSxPQUFPRCxVQUFXO1FBQzFELElBQUlDLE9BQU9MLFVBQVVBLE1BQU0sQ0FBQ0ssSUFBSSxLQUFLRCxTQUFTLENBQUNDLElBQUksRUFBRSxNQUFNLElBQUlDLE1BQU0sQ0FBQyxjQUFjLEVBQUVELElBQUksQ0FBQztRQUMzRkwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELFNBQVMsQ0FBQ0MsSUFBSTtJQUM3QjtJQUNBLE9BQU9MO0FBQ1I7QUFDQTs7O0FBR0EsR0FDQSxTQUFTTyxTQUFTQyxLQUFLO0lBQ3RCLE9BQU8sQ0FBQyxDQUFDQSxTQUFTLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsVUFBVSxPQUFPQSxVQUFVO0FBQzdEO0FBQ0EsU0FBU0csV0FBV0MsRUFBRTtJQUNyQixPQUFPLE9BQU9BLE9BQU87QUFDdEI7QUFDQTs7O0FBR0EsR0FDQSxTQUFTQyxjQUFjQyxHQUFHO0lBQ3pCLE9BQU9iLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0UsTUFBTSxDQUFDLE9BQU9XO0FBQzNDO0FBQ0EsTUFBTUMsMEJBQTBCLE9BQU9DLFdBQVcsY0FBYyxDQUFDLENBQUNBLE9BQU9DLGFBQWE7QUFDdEYsU0FBU0MsZ0JBQWdCVixLQUFLO0lBQzdCLE9BQU9PLDJCQUEyQlIsU0FBU0MsVUFBVVEsT0FBT0MsYUFBYSxJQUFJVDtBQUM5RTtBQUNBOztBQUVBLEdBQ0EsTUFBTVcsTUFBTSxDQUFDUCxLQUFPQTtBQUNwQixTQUFTUSxRQUFRO0FBQ2pCLFNBQVNDLFNBQVNDLEVBQUU7SUFDbkIsT0FBT0E7QUFDUjtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU0MsT0FBT0MsU0FBUyxFQUFFQyxNQUFNLG9CQUFvQjtJQUNwRCxJQUFJLENBQUNELFdBQVcsTUFBTSxJQUFJbEIsTUFBTSxDQUFDLGdCQUFnQixFQUFFbUIsSUFBSSxDQUFDO0FBQ3pEO0FBQ0EsU0FBU0MsTUFBTUMsS0FBSyxDQUFDO0lBQ3BCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxNQUFRQyxXQUFXRCxLQUFLRjtBQUM3QztBQUNBOzs7QUFHQSxHQUNBLFNBQVNJLHdCQUF3QkMsT0FBTztJQUN2QyxJQUFJLE9BQU9DLFlBQVlDLEdBQUcsS0FBSyxZQUFZLE9BQU9ELFlBQVlDLEdBQUcsQ0FBQ0Y7SUFDbEUsTUFBTUcsS0FBSyxJQUFJQztJQUNmLEtBQUssTUFBTUMsVUFBVUwsUUFBUztRQUM3QixJQUFJSyxPQUFPQyxPQUFPLEVBQUU7WUFDbkJDO1lBQ0E7UUFDRDtRQUNBRixPQUFPRyxnQkFBZ0IsQ0FBQyxTQUFTRCxTQUFTO1lBQUVFLE1BQU07UUFBSztJQUN4RDtJQUNBLE9BQU9OLEdBQUdFLE1BQU07SUFDaEIsU0FBU0U7UUFDUkosR0FBR08sS0FBSztRQUNSLEtBQUssTUFBTUwsVUFBVUwsUUFBU0ssT0FBT00sbUJBQW1CLENBQUMsU0FBU0o7SUFDbkU7QUFDRDtBQUVBLFlBQVk7QUFDZ04sQ0FDNU4sMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjQuMV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC91dGlscy1CSFpKY0JSdi5tanM/YTNiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9ycGMvY29kZXMudHNcbi8qKlxuKiBKU09OLVJQQyAyLjAgRXJyb3IgY29kZXNcbipcbiogYC0zMjAwMGAgdG8gYC0zMjA5OWAgYXJlIHJlc2VydmVkIGZvciBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHNlcnZlci1lcnJvcnMuXG4qIEZvciB0UlBDIHdlJ3JlIGNvcHlpbmcgdGhlIGxhc3QgZGlnaXRzIG9mIEhUVFAgNFhYIGVycm9ycy5cbiovXG5jb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSA9IHtcblx0UEFSU0VfRVJST1I6IC0zMjcwMCxcblx0QkFEX1JFUVVFU1Q6IC0zMjYwMCxcblx0SU5URVJOQUxfU0VSVkVSX0VSUk9SOiAtMzI2MDMsXG5cdE5PVF9JTVBMRU1FTlRFRDogLTMyNjAzLFxuXHRCQURfR0FURVdBWTogLTMyNjAzLFxuXHRTRVJWSUNFX1VOQVZBSUxBQkxFOiAtMzI2MDMsXG5cdEdBVEVXQVlfVElNRU9VVDogLTMyNjAzLFxuXHRVTkFVVEhPUklaRUQ6IC0zMjAwMSxcblx0UEFZTUVOVF9SRVFVSVJFRDogLTMyMDAyLFxuXHRGT1JCSURERU46IC0zMjAwMyxcblx0Tk9UX0ZPVU5EOiAtMzIwMDQsXG5cdE1FVEhPRF9OT1RfU1VQUE9SVEVEOiAtMzIwMDUsXG5cdFRJTUVPVVQ6IC0zMjAwOCxcblx0Q09ORkxJQ1Q6IC0zMjAwOSxcblx0UFJFQ09ORElUSU9OX0ZBSUxFRDogLTMyMDEyLFxuXHRQQVlMT0FEX1RPT19MQVJHRTogLTMyMDEzLFxuXHRVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiAtMzIwMTUsXG5cdFVOUFJPQ0VTU0FCTEVfQ09OVEVOVDogLTMyMDIyLFxuXHRUT09fTUFOWV9SRVFVRVNUUzogLTMyMDI5LFxuXHRDTElFTlRfQ0xPU0VEX1JFUVVFU1Q6IC0zMjA5OVxufTtcbmNvbnN0IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSID0ge1xuXHRbLTMyNzAwXTogXCJQQVJTRV9FUlJPUlwiLFxuXHRbLTMyNjAwXTogXCJCQURfUkVRVUVTVFwiLFxuXHRbLTMyNjAzXTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcblx0Wy0zMjAwMV06IFwiVU5BVVRIT1JJWkVEXCIsXG5cdFstMzIwMDJdOiBcIlBBWU1FTlRfUkVRVUlSRURcIixcblx0Wy0zMjAwM106IFwiRk9SQklEREVOXCIsXG5cdFstMzIwMDRdOiBcIk5PVF9GT1VORFwiLFxuXHRbLTMyMDA1XTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRbLTMyMDA4XTogXCJUSU1FT1VUXCIsXG5cdFstMzIwMDldOiBcIkNPTkZMSUNUXCIsXG5cdFstMzIwMTJdOiBcIlBSRUNPTkRJVElPTl9GQUlMRURcIixcblx0Wy0zMjAxM106IFwiUEFZTE9BRF9UT09fTEFSR0VcIixcblx0Wy0zMjAxNV06IFwiVU5TVVBQT1JURURfTUVESUFfVFlQRVwiLFxuXHRbLTMyMDIyXTogXCJVTlBST0NFU1NBQkxFX0NPTlRFTlRcIixcblx0Wy0zMjAyOV06IFwiVE9PX01BTllfUkVRVUVTVFNcIixcblx0Wy0zMjA5OV06IFwiQ0xJRU5UX0NMT1NFRF9SRVFVRVNUXCJcbn07XG4vKipcbiogdFJQQyBlcnJvciBjb2RlcyB0aGF0IGFyZSBjb25zaWRlcmVkIHJldHJ5YWJsZVxuKiBXaXRoIG91dCBvZiB0aGUgYm94IFNTRSwgdGhlIGNsaWVudCB3aWxsIHJlY29ubmVjdCB3aGVuIHRoZXNlIGVycm9ycyBhcmUgZW5jb3VudGVyZWRcbiovXG5jb25zdCByZXRyeWFibGVScGNDb2RlcyA9IFtcblx0VFJQQ19FUlJPUl9DT0RFU19CWV9LRVkuQkFEX0dBVEVXQVksXG5cdFRSUENfRVJST1JfQ09ERVNfQllfS0VZLlNFUlZJQ0VfVU5BVkFJTEFCTEUsXG5cdFRSUENfRVJST1JfQ09ERVNfQllfS0VZLkdBVEVXQVlfVElNRU9VVCxcblx0VFJQQ19FUlJPUl9DT0RFU19CWV9LRVkuSU5URVJOQUxfU0VSVkVSX0VSUk9SXG5dO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3V0aWxzLnRzXG4vKipcbiogRW5zdXJlcyB0aGVyZSBhcmUgbm8gZHVwbGljYXRlIGtleXMgd2hlbiBidWlsZGluZyBhIHByb2NlZHVyZS5cbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gbWVyZ2VXaXRob3V0T3ZlcnJpZGVzKG9iajEsIC4uLm9ianMpIHtcblx0Y29uc3QgbmV3T2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvYmoxKTtcblx0Zm9yIChjb25zdCBvdmVycmlkZXMgb2Ygb2JqcykgZm9yIChjb25zdCBrZXkgaW4gb3ZlcnJpZGVzKSB7XG5cdFx0aWYgKGtleSBpbiBuZXdPYmogJiYgbmV3T2JqW2tleV0gIT09IG92ZXJyaWRlc1trZXldKSB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBrZXkgJHtrZXl9YCk7XG5cdFx0bmV3T2JqW2tleV0gPSBvdmVycmlkZXNba2V5XTtcblx0fVxuXHRyZXR1cm4gbmV3T2JqO1xufVxuLyoqXG4qIENoZWNrIHRoYXQgdmFsdWUgaXMgb2JqZWN0XG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZuKSB7XG5cdHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuKiBDcmVhdGUgYW4gb2JqZWN0IHdpdGhvdXQgaW5oZXJpdGluZyBhbnl0aGluZyBmcm9tIGBPYmplY3QucHJvdG90eXBlYFxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBvbWl0UHJvdG90eXBlKG9iaikge1xuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvYmopO1xufVxuY29uc3QgYXN5bmNJdGVyYXRvcnNTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgISFTeW1ib2wuYXN5bmNJdGVyYXRvcjtcbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh2YWx1ZSkge1xuXHRyZXR1cm4gYXN5bmNJdGVyYXRvcnNTdXBwb3J0ZWQgJiYgaXNPYmplY3QodmFsdWUpICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlO1xufVxuLyoqXG4qIFJ1biBhbiBJSUZFXG4qL1xuY29uc3QgcnVuID0gKGZuKSA9PiBmbigpO1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBpZGVudGl0eShpdCkge1xuXHRyZXR1cm4gaXQ7XG59XG4vKipcbiogR2VuZXJpYyBydW50aW1lIGFzc2VydGlvbiBmdW5jdGlvbi4gVGhyb3dzLCBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBgdHJ1ZWAuXG4qXG4qIENhbiBiZSB1c2VkIGFzIGEgc2xpZ2h0bHkgbGVzcyBkYW5nZXJvdXMgdmFyaWFudCBvZiB0eXBlIGFzc2VydGlvbnMuIENvZGVcbiogbWlzdGFrZXMgd291bGQgYmUgcmV2ZWFsZWQgYXQgcnVudGltZSB0aGVuIChob3BlZnVsbHkgZHVyaW5nIHRlc3RpbmcpLlxuKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZyA9IFwibm8gYWRkaXRpb25hbCBpbmZvXCIpIHtcblx0aWYgKCFjb25kaXRpb24pIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uRXJyb3I6ICR7bXNnfWApO1xufVxuZnVuY3Rpb24gc2xlZXAobXMgPSAwKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgbXMpKTtcbn1cbi8qKlxuKiBQb255ZmlsbCBmb3JcbiogW2BBYm9ydFNpZ25hbC5hbnlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRTaWduYWwvYW55X3N0YXRpYykuXG4qL1xuZnVuY3Rpb24gYWJvcnRTaWduYWxzQW55UG9ueWZpbGwoc2lnbmFscykge1xuXHRpZiAodHlwZW9mIEFib3J0U2lnbmFsLmFueSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gQWJvcnRTaWduYWwuYW55KHNpZ25hbHMpO1xuXHRjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0Zm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykge1xuXHRcdGlmIChzaWduYWwuYWJvcnRlZCkge1xuXHRcdFx0dHJpZ2dlcigpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdHJpZ2dlciwgeyBvbmNlOiB0cnVlIH0pO1xuXHR9XG5cdHJldHVybiBhYy5zaWduYWw7XG5cdGZ1bmN0aW9uIHRyaWdnZXIoKSB7XG5cdFx0YWMuYWJvcnQoKTtcblx0XHRmb3IgKGNvbnN0IHNpZ25hbCBvZiBzaWduYWxzKSBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRyaWdnZXIpO1xuXHR9XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVksIFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSLCBhYm9ydFNpZ25hbHNBbnlQb255ZmlsbCwgYXNzZXJ0LCBpZGVudGl0eSwgaXNBc3luY0l0ZXJhYmxlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgbWVyZ2VXaXRob3V0T3ZlcnJpZGVzLCBub29wLCBvbWl0UHJvdG90eXBlLCByZXRyeWFibGVScGNDb2RlcywgcnVuLCBzbGVlcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMtQkhaSmNCUnYubWpzLm1hcCJdLCJuYW1lcyI6WyJUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSIsIlBBUlNFX0VSUk9SIiwiQkFEX1JFUVVFU1QiLCJJTlRFUk5BTF9TRVJWRVJfRVJST1IiLCJOT1RfSU1QTEVNRU5URUQiLCJCQURfR0FURVdBWSIsIlNFUlZJQ0VfVU5BVkFJTEFCTEUiLCJHQVRFV0FZX1RJTUVPVVQiLCJVTkFVVEhPUklaRUQiLCJQQVlNRU5UX1JFUVVJUkVEIiwiRk9SQklEREVOIiwiTk9UX0ZPVU5EIiwiTUVUSE9EX05PVF9TVVBQT1JURUQiLCJUSU1FT1VUIiwiQ09ORkxJQ1QiLCJQUkVDT05ESVRJT05fRkFJTEVEIiwiUEFZTE9BRF9UT09fTEFSR0UiLCJVTlNVUFBPUlRFRF9NRURJQV9UWVBFIiwiVU5QUk9DRVNTQUJMRV9DT05URU5UIiwiVE9PX01BTllfUkVRVUVTVFMiLCJDTElFTlRfQ0xPU0VEX1JFUVVFU1QiLCJUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUiIsInJldHJ5YWJsZVJwY0NvZGVzIiwibWVyZ2VXaXRob3V0T3ZlcnJpZGVzIiwib2JqMSIsIm9ianMiLCJuZXdPYmoiLCJPYmplY3QiLCJhc3NpZ24iLCJjcmVhdGUiLCJvdmVycmlkZXMiLCJrZXkiLCJFcnJvciIsImlzT2JqZWN0IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJpc0Z1bmN0aW9uIiwiZm4iLCJvbWl0UHJvdG90eXBlIiwib2JqIiwiYXN5bmNJdGVyYXRvcnNTdXBwb3J0ZWQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiaXNBc3luY0l0ZXJhYmxlIiwicnVuIiwibm9vcCIsImlkZW50aXR5IiwiaXQiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtc2ciLCJzbGVlcCIsIm1zIiwiUHJvbWlzZSIsInJlcyIsInNldFRpbWVvdXQiLCJhYm9ydFNpZ25hbHNBbnlQb255ZmlsbCIsInNpZ25hbHMiLCJBYm9ydFNpZ25hbCIsImFueSIsImFjIiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwiYWJvcnRlZCIsInRyaWdnZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsImFib3J0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@trpc+server@11.4.1_typescript@5.8.3/node_modules/@trpc/server/dist/utils-BHZJcBRv.mjs\n");

/***/ })

};
;